
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model Field
 * 
 */
export type Field = $Result.DefaultSelection<Prisma.$FieldPayload>
/**
 * Model FieldOwnership
 * 
 */
export type FieldOwnership = $Result.DefaultSelection<Prisma.$FieldOwnershipPayload>
/**
 * Model FieldWorkerAssignment
 * 
 */
export type FieldWorkerAssignment = $Result.DefaultSelection<Prisma.$FieldWorkerAssignmentPayload>
/**
 * Model FieldWell
 * 
 */
export type FieldWell = $Result.DefaultSelection<Prisma.$FieldWellPayload>
/**
 * Model WorkerWellAssignment
 * 
 */
export type WorkerWellAssignment = $Result.DefaultSelection<Prisma.$WorkerWellAssignmentPayload>
/**
 * Model Well
 * 
 */
export type Well = $Result.DefaultSelection<Prisma.$WellPayload>
/**
 * Model Crop
 * 
 */
export type Crop = $Result.DefaultSelection<Prisma.$CropPayload>
/**
 * Model ProcessingLog
 * 
 */
export type ProcessingLog = $Result.DefaultSelection<Prisma.$ProcessingLogPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryOwnership
 * 
 */
export type InventoryOwnership = $Result.DefaultSelection<Prisma.$InventoryOwnershipPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseApproval
 * 
 */
export type PurchaseApproval = $Result.DefaultSelection<Prisma.$PurchaseApprovalPayload>
/**
 * Model PurchaseContributor
 * 
 */
export type PurchaseContributor = $Result.DefaultSelection<Prisma.$PurchaseContributorPayload>
/**
 * Model PaymentHistory
 * 
 */
export type PaymentHistory = $Result.DefaultSelection<Prisma.$PaymentHistoryPayload>
/**
 * Model InventoryTransaction
 * 
 */
export type InventoryTransaction = $Result.DefaultSelection<Prisma.$InventoryTransactionPayload>
/**
 * Model Debt
 * 
 */
export type Debt = $Result.DefaultSelection<Prisma.$DebtPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InventoryUsage
 * 
 */
export type InventoryUsage = $Result.DefaultSelection<Prisma.$InventoryUsagePayload>
/**
 * Model Process
 * 
 */
export type Process = $Result.DefaultSelection<Prisma.$ProcessPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model EquipmentOwnership
 * 
 */
export type EquipmentOwnership = $Result.DefaultSelection<Prisma.$EquipmentOwnershipPayload>
/**
 * Model EquipmentCapability
 * 
 */
export type EquipmentCapability = $Result.DefaultSelection<Prisma.$EquipmentCapabilityPayload>
/**
 * Model EquipmentUsage
 * 
 */
export type EquipmentUsage = $Result.DefaultSelection<Prisma.$EquipmentUsagePayload>
/**
 * Model ProcessCost
 * 
 */
export type ProcessCost = $Result.DefaultSelection<Prisma.$ProcessCostPayload>
/**
 * Model FieldExpense
 * 
 */
export type FieldExpense = $Result.DefaultSelection<Prisma.$FieldExpensePayload>
/**
 * Model FieldOwnerExpense
 * 
 */
export type FieldOwnerExpense = $Result.DefaultSelection<Prisma.$FieldOwnerExpensePayload>
/**
 * Model IrrigationLog
 * 
 */
export type IrrigationLog = $Result.DefaultSelection<Prisma.$IrrigationLogPayload>
/**
 * Model IrrigationFieldUsage
 * 
 */
export type IrrigationFieldUsage = $Result.DefaultSelection<Prisma.$IrrigationFieldUsagePayload>
/**
 * Model IrrigationOwnerUsage
 * 
 */
export type IrrigationOwnerUsage = $Result.DefaultSelection<Prisma.$IrrigationOwnerUsagePayload>
/**
 * Model IrrigationOwnerSummary
 * 
 */
export type IrrigationOwnerSummary = $Result.DefaultSelection<Prisma.$IrrigationOwnerSummaryPayload>
/**
 * Model IrrigationInventoryUsage
 * 
 */
export type IrrigationInventoryUsage = $Result.DefaultSelection<Prisma.$IrrigationInventoryUsagePayload>
/**
 * Model IrrigationInventoryOwnerUsage
 * 
 */
export type IrrigationInventoryOwnerUsage = $Result.DefaultSelection<Prisma.$IrrigationInventoryOwnerUsagePayload>
/**
 * Model WellBillingPeriod
 * 
 */
export type WellBillingPeriod = $Result.DefaultSelection<Prisma.$WellBillingPeriodPayload>
/**
 * Model WellBillingIrrigationUsage
 * 
 */
export type WellBillingIrrigationUsage = $Result.DefaultSelection<Prisma.$WellBillingIrrigationUsagePayload>
/**
 * Model WellBillDistribution
 * 
 */
export type WellBillDistribution = $Result.DefaultSelection<Prisma.$WellBillDistributionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  OWNER: 'OWNER',
  WORKER: 'WORKER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const FieldStatus: {
  ACTIVE: 'ACTIVE',
  FALLOW: 'FALLOW',
  HARVESTED: 'HARVESTED'
};

export type FieldStatus = (typeof FieldStatus)[keyof typeof FieldStatus]


export const WellStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MAINTENANCE: 'MAINTENANCE'
};

export type WellStatus = (typeof WellStatus)[keyof typeof WellStatus]


export const CropStatus: {
  GROWING: 'GROWING',
  HARVESTED: 'HARVESTED',
  FAILED: 'FAILED'
};

export type CropStatus = (typeof CropStatus)[keyof typeof CropStatus]


export const InventoryCategory: {
  SEED: 'SEED',
  FERTILIZER: 'FERTILIZER',
  PESTICIDE: 'PESTICIDE',
  EQUIPMENT: 'EQUIPMENT',
  FUEL: 'FUEL',
  OTHER: 'OTHER'
};

export type InventoryCategory = (typeof InventoryCategory)[keyof typeof InventoryCategory]


export const ProductCategory: {
  FERTILIZER: 'FERTILIZER',
  FEED: 'FEED',
  PESTICIDE: 'PESTICIDE',
  FUEL: 'FUEL',
  SEED: 'SEED',
  EQUIPMENT: 'EQUIPMENT',
  OTHER: 'OTHER'
};

export type ProductCategory = (typeof ProductCategory)[keyof typeof ProductCategory]


export const InventoryStatus: {
  AVAILABLE: 'AVAILABLE',
  LOW_STOCK: 'LOW_STOCK',
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  EXPIRED: 'EXPIRED'
};

export type InventoryStatus = (typeof InventoryStatus)[keyof typeof InventoryStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  CREDIT: 'CREDIT',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const DebtStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED',
  PARTIALLY_PAID: 'PARTIALLY_PAID'
};

export type DebtStatus = (typeof DebtStatus)[keyof typeof DebtStatus]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const UsageType: {
  IRRIGATION: 'IRRIGATION',
  PROCESSING: 'PROCESSING',
  GENERAL: 'GENERAL'
};

export type UsageType = (typeof UsageType)[keyof typeof UsageType]


export const ProcessType: {
  PLOWING: 'PLOWING',
  SEEDING: 'SEEDING',
  FERTILIZING: 'FERTILIZING',
  PESTICIDE: 'PESTICIDE',
  HARVESTING: 'HARVESTING',
  OTHER: 'OTHER'
};

export type ProcessType = (typeof ProcessType)[keyof typeof ProcessType]


export const ProcessStatus: {
  DRAFT: 'DRAFT',
  PENDING_INVENTORY_EQUIPMENT: 'PENDING_INVENTORY_EQUIPMENT',
  FINALIZED: 'FINALIZED',
  CANCELLED: 'CANCELLED'
};

export type ProcessStatus = (typeof ProcessStatus)[keyof typeof ProcessStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  IRRIGATION: 'IRRIGATION',
  PROCESSING: 'PROCESSING',
  INVENTORY: 'INVENTORY',
  INVOICE: 'INVOICE',
  DEBT: 'DEBT',
  APPROVAL: 'APPROVAL',
  REMINDER: 'REMINDER',
  FIELD_PROCESSING: 'FIELD_PROCESSING',
  PAYMENT_DUE: 'PAYMENT_DUE',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',
  PROCESS_COMPLETED: 'PROCESS_COMPLETED',
  TASK_ASSIGNED: 'TASK_ASSIGNED',
  INVENTORY_LOW: 'INVENTORY_LOW',
  DEBT_REMINDER: 'DEBT_REMINDER',
  IRRIGATION_SCHEDULED: 'IRRIGATION_SCHEDULED',
  IRRIGATION_COMPLETED: 'IRRIGATION_COMPLETED',
  SYSTEM_ALERT: 'SYSTEM_ALERT',
  TASK_UPDATED: 'TASK_UPDATED',
  PROCESS_UPDATED: 'PROCESS_UPDATED',
  OTHER: 'OTHER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const TransactionType: {
  PURCHASE: 'PURCHASE',
  USAGE: 'USAGE',
  TRANSFER: 'TRANSFER',
  ADJUSTMENT: 'ADJUSTMENT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const EquipmentType: {
  SEEDING: 'SEEDING',
  TILLAGE: 'TILLAGE',
  SPRAYING: 'SPRAYING',
  FERTILIZING: 'FERTILIZING',
  HARVESTING: 'HARVESTING',
  OTHER: 'OTHER'
};

export type EquipmentType = (typeof EquipmentType)[keyof typeof EquipmentType]


export const EquipmentStatus: {
  ACTIVE: 'ACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  INACTIVE: 'INACTIVE'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]


export const Unit: {
  KG: 'KG',
  TON: 'TON',
  LITRE: 'LITRE',
  ADET: 'ADET',
  CUVAL: 'CUVAL',
  BIDON: 'BIDON',
  PAKET: 'PAKET',
  METRE: 'METRE',
  METREKARE: 'METREKARE',
  DECARE: 'DECARE',
  DONUM: 'DONUM',
  HECTARE: 'HECTARE',
  DIGER: 'DIGER'
};

export type Unit = (typeof Unit)[keyof typeof Unit]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type FieldStatus = $Enums.FieldStatus

export const FieldStatus: typeof $Enums.FieldStatus

export type WellStatus = $Enums.WellStatus

export const WellStatus: typeof $Enums.WellStatus

export type CropStatus = $Enums.CropStatus

export const CropStatus: typeof $Enums.CropStatus

export type InventoryCategory = $Enums.InventoryCategory

export const InventoryCategory: typeof $Enums.InventoryCategory

export type ProductCategory = $Enums.ProductCategory

export const ProductCategory: typeof $Enums.ProductCategory

export type InventoryStatus = $Enums.InventoryStatus

export const InventoryStatus: typeof $Enums.InventoryStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type DebtStatus = $Enums.DebtStatus

export const DebtStatus: typeof $Enums.DebtStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type UsageType = $Enums.UsageType

export const UsageType: typeof $Enums.UsageType

export type ProcessType = $Enums.ProcessType

export const ProcessType: typeof $Enums.ProcessType

export type ProcessStatus = $Enums.ProcessStatus

export const ProcessStatus: typeof $Enums.ProcessStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type EquipmentType = $Enums.EquipmentType

export const EquipmentType: typeof $Enums.EquipmentType

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

export type Unit = $Enums.Unit

export const Unit: typeof $Enums.Unit

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.field`: Exposes CRUD operations for the **Field** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fields
    * const fields = await prisma.field.findMany()
    * ```
    */
  get field(): Prisma.FieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldOwnership`: Exposes CRUD operations for the **FieldOwnership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldOwnerships
    * const fieldOwnerships = await prisma.fieldOwnership.findMany()
    * ```
    */
  get fieldOwnership(): Prisma.FieldOwnershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldWorkerAssignment`: Exposes CRUD operations for the **FieldWorkerAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldWorkerAssignments
    * const fieldWorkerAssignments = await prisma.fieldWorkerAssignment.findMany()
    * ```
    */
  get fieldWorkerAssignment(): Prisma.FieldWorkerAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldWell`: Exposes CRUD operations for the **FieldWell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldWells
    * const fieldWells = await prisma.fieldWell.findMany()
    * ```
    */
  get fieldWell(): Prisma.FieldWellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workerWellAssignment`: Exposes CRUD operations for the **WorkerWellAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerWellAssignments
    * const workerWellAssignments = await prisma.workerWellAssignment.findMany()
    * ```
    */
  get workerWellAssignment(): Prisma.WorkerWellAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.well`: Exposes CRUD operations for the **Well** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wells
    * const wells = await prisma.well.findMany()
    * ```
    */
  get well(): Prisma.WellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crop`: Exposes CRUD operations for the **Crop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crops
    * const crops = await prisma.crop.findMany()
    * ```
    */
  get crop(): Prisma.CropDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processingLog`: Exposes CRUD operations for the **ProcessingLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessingLogs
    * const processingLogs = await prisma.processingLog.findMany()
    * ```
    */
  get processingLog(): Prisma.ProcessingLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryOwnership`: Exposes CRUD operations for the **InventoryOwnership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryOwnerships
    * const inventoryOwnerships = await prisma.inventoryOwnership.findMany()
    * ```
    */
  get inventoryOwnership(): Prisma.InventoryOwnershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseApproval`: Exposes CRUD operations for the **PurchaseApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseApprovals
    * const purchaseApprovals = await prisma.purchaseApproval.findMany()
    * ```
    */
  get purchaseApproval(): Prisma.PurchaseApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseContributor`: Exposes CRUD operations for the **PurchaseContributor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseContributors
    * const purchaseContributors = await prisma.purchaseContributor.findMany()
    * ```
    */
  get purchaseContributor(): Prisma.PurchaseContributorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentHistory`: Exposes CRUD operations for the **PaymentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentHistories
    * const paymentHistories = await prisma.paymentHistory.findMany()
    * ```
    */
  get paymentHistory(): Prisma.PaymentHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryTransaction`: Exposes CRUD operations for the **InventoryTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryTransactions
    * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
    * ```
    */
  get inventoryTransaction(): Prisma.InventoryTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debt`: Exposes CRUD operations for the **Debt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debts
    * const debts = await prisma.debt.findMany()
    * ```
    */
  get debt(): Prisma.DebtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryUsage`: Exposes CRUD operations for the **InventoryUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryUsages
    * const inventoryUsages = await prisma.inventoryUsage.findMany()
    * ```
    */
  get inventoryUsage(): Prisma.InventoryUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.process`: Exposes CRUD operations for the **Process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processes
    * const processes = await prisma.process.findMany()
    * ```
    */
  get process(): Prisma.ProcessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentOwnership`: Exposes CRUD operations for the **EquipmentOwnership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentOwnerships
    * const equipmentOwnerships = await prisma.equipmentOwnership.findMany()
    * ```
    */
  get equipmentOwnership(): Prisma.EquipmentOwnershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentCapability`: Exposes CRUD operations for the **EquipmentCapability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentCapabilities
    * const equipmentCapabilities = await prisma.equipmentCapability.findMany()
    * ```
    */
  get equipmentCapability(): Prisma.EquipmentCapabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentUsage`: Exposes CRUD operations for the **EquipmentUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentUsages
    * const equipmentUsages = await prisma.equipmentUsage.findMany()
    * ```
    */
  get equipmentUsage(): Prisma.EquipmentUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processCost`: Exposes CRUD operations for the **ProcessCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessCosts
    * const processCosts = await prisma.processCost.findMany()
    * ```
    */
  get processCost(): Prisma.ProcessCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldExpense`: Exposes CRUD operations for the **FieldExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldExpenses
    * const fieldExpenses = await prisma.fieldExpense.findMany()
    * ```
    */
  get fieldExpense(): Prisma.FieldExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldOwnerExpense`: Exposes CRUD operations for the **FieldOwnerExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldOwnerExpenses
    * const fieldOwnerExpenses = await prisma.fieldOwnerExpense.findMany()
    * ```
    */
  get fieldOwnerExpense(): Prisma.FieldOwnerExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationLog`: Exposes CRUD operations for the **IrrigationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationLogs
    * const irrigationLogs = await prisma.irrigationLog.findMany()
    * ```
    */
  get irrigationLog(): Prisma.IrrigationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationFieldUsage`: Exposes CRUD operations for the **IrrigationFieldUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationFieldUsages
    * const irrigationFieldUsages = await prisma.irrigationFieldUsage.findMany()
    * ```
    */
  get irrigationFieldUsage(): Prisma.IrrigationFieldUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationOwnerUsage`: Exposes CRUD operations for the **IrrigationOwnerUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationOwnerUsages
    * const irrigationOwnerUsages = await prisma.irrigationOwnerUsage.findMany()
    * ```
    */
  get irrigationOwnerUsage(): Prisma.IrrigationOwnerUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationOwnerSummary`: Exposes CRUD operations for the **IrrigationOwnerSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationOwnerSummaries
    * const irrigationOwnerSummaries = await prisma.irrigationOwnerSummary.findMany()
    * ```
    */
  get irrigationOwnerSummary(): Prisma.IrrigationOwnerSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationInventoryUsage`: Exposes CRUD operations for the **IrrigationInventoryUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationInventoryUsages
    * const irrigationInventoryUsages = await prisma.irrigationInventoryUsage.findMany()
    * ```
    */
  get irrigationInventoryUsage(): Prisma.IrrigationInventoryUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationInventoryOwnerUsage`: Exposes CRUD operations for the **IrrigationInventoryOwnerUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationInventoryOwnerUsages
    * const irrigationInventoryOwnerUsages = await prisma.irrigationInventoryOwnerUsage.findMany()
    * ```
    */
  get irrigationInventoryOwnerUsage(): Prisma.IrrigationInventoryOwnerUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellBillingPeriod`: Exposes CRUD operations for the **WellBillingPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellBillingPeriods
    * const wellBillingPeriods = await prisma.wellBillingPeriod.findMany()
    * ```
    */
  get wellBillingPeriod(): Prisma.WellBillingPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellBillingIrrigationUsage`: Exposes CRUD operations for the **WellBillingIrrigationUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellBillingIrrigationUsages
    * const wellBillingIrrigationUsages = await prisma.wellBillingIrrigationUsage.findMany()
    * ```
    */
  get wellBillingIrrigationUsage(): Prisma.WellBillingIrrigationUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellBillDistribution`: Exposes CRUD operations for the **WellBillDistribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellBillDistributions
    * const wellBillDistributions = await prisma.wellBillDistribution.findMany()
    * ```
    */
  get wellBillDistribution(): Prisma.WellBillDistributionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Season: 'Season',
    Field: 'Field',
    FieldOwnership: 'FieldOwnership',
    FieldWorkerAssignment: 'FieldWorkerAssignment',
    FieldWell: 'FieldWell',
    WorkerWellAssignment: 'WorkerWellAssignment',
    Well: 'Well',
    Crop: 'Crop',
    ProcessingLog: 'ProcessingLog',
    Inventory: 'Inventory',
    InventoryOwnership: 'InventoryOwnership',
    Purchase: 'Purchase',
    PurchaseApproval: 'PurchaseApproval',
    PurchaseContributor: 'PurchaseContributor',
    PaymentHistory: 'PaymentHistory',
    InventoryTransaction: 'InventoryTransaction',
    Debt: 'Debt',
    Invoice: 'Invoice',
    InventoryUsage: 'InventoryUsage',
    Process: 'Process',
    Notification: 'Notification',
    NotificationPreference: 'NotificationPreference',
    Equipment: 'Equipment',
    EquipmentOwnership: 'EquipmentOwnership',
    EquipmentCapability: 'EquipmentCapability',
    EquipmentUsage: 'EquipmentUsage',
    ProcessCost: 'ProcessCost',
    FieldExpense: 'FieldExpense',
    FieldOwnerExpense: 'FieldOwnerExpense',
    IrrigationLog: 'IrrigationLog',
    IrrigationFieldUsage: 'IrrigationFieldUsage',
    IrrigationOwnerUsage: 'IrrigationOwnerUsage',
    IrrigationOwnerSummary: 'IrrigationOwnerSummary',
    IrrigationInventoryUsage: 'IrrigationInventoryUsage',
    IrrigationInventoryOwnerUsage: 'IrrigationInventoryOwnerUsage',
    WellBillingPeriod: 'WellBillingPeriod',
    WellBillingIrrigationUsage: 'WellBillingIrrigationUsage',
    WellBillDistribution: 'WellBillDistribution'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "season" | "field" | "fieldOwnership" | "fieldWorkerAssignment" | "fieldWell" | "workerWellAssignment" | "well" | "crop" | "processingLog" | "inventory" | "inventoryOwnership" | "purchase" | "purchaseApproval" | "purchaseContributor" | "paymentHistory" | "inventoryTransaction" | "debt" | "invoice" | "inventoryUsage" | "process" | "notification" | "notificationPreference" | "equipment" | "equipmentOwnership" | "equipmentCapability" | "equipmentUsage" | "processCost" | "fieldExpense" | "fieldOwnerExpense" | "irrigationLog" | "irrigationFieldUsage" | "irrigationOwnerUsage" | "irrigationOwnerSummary" | "irrigationInventoryUsage" | "irrigationInventoryOwnerUsage" | "wellBillingPeriod" | "wellBillingIrrigationUsage" | "wellBillDistribution"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SeasonFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SeasonAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      Field: {
        payload: Prisma.$FieldPayload<ExtArgs>
        fields: Prisma.FieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findFirst: {
            args: Prisma.FieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findMany: {
            args: Prisma.FieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          create: {
            args: Prisma.FieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          createMany: {
            args: Prisma.FieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          update: {
            args: Prisma.FieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          deleteMany: {
            args: Prisma.FieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          aggregate: {
            args: Prisma.FieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateField>
          }
          groupBy: {
            args: Prisma.FieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldCountArgs<ExtArgs>
            result: $Utils.Optional<FieldCountAggregateOutputType> | number
          }
        }
      }
      FieldOwnership: {
        payload: Prisma.$FieldOwnershipPayload<ExtArgs>
        fields: Prisma.FieldOwnershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldOwnershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldOwnershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>
          }
          findFirst: {
            args: Prisma.FieldOwnershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldOwnershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>
          }
          findMany: {
            args: Prisma.FieldOwnershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>[]
          }
          create: {
            args: Prisma.FieldOwnershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>
          }
          createMany: {
            args: Prisma.FieldOwnershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldOwnershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>
          }
          update: {
            args: Prisma.FieldOwnershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>
          }
          deleteMany: {
            args: Prisma.FieldOwnershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldOwnershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldOwnershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnershipPayload>
          }
          aggregate: {
            args: Prisma.FieldOwnershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldOwnership>
          }
          groupBy: {
            args: Prisma.FieldOwnershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldOwnershipGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldOwnershipFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldOwnershipAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldOwnershipCountArgs<ExtArgs>
            result: $Utils.Optional<FieldOwnershipCountAggregateOutputType> | number
          }
        }
      }
      FieldWorkerAssignment: {
        payload: Prisma.$FieldWorkerAssignmentPayload<ExtArgs>
        fields: Prisma.FieldWorkerAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldWorkerAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldWorkerAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>
          }
          findFirst: {
            args: Prisma.FieldWorkerAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldWorkerAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>
          }
          findMany: {
            args: Prisma.FieldWorkerAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>[]
          }
          create: {
            args: Prisma.FieldWorkerAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>
          }
          createMany: {
            args: Prisma.FieldWorkerAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldWorkerAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>
          }
          update: {
            args: Prisma.FieldWorkerAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.FieldWorkerAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldWorkerAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldWorkerAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWorkerAssignmentPayload>
          }
          aggregate: {
            args: Prisma.FieldWorkerAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldWorkerAssignment>
          }
          groupBy: {
            args: Prisma.FieldWorkerAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldWorkerAssignmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldWorkerAssignmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldWorkerAssignmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldWorkerAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<FieldWorkerAssignmentCountAggregateOutputType> | number
          }
        }
      }
      FieldWell: {
        payload: Prisma.$FieldWellPayload<ExtArgs>
        fields: Prisma.FieldWellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldWellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldWellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>
          }
          findFirst: {
            args: Prisma.FieldWellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldWellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>
          }
          findMany: {
            args: Prisma.FieldWellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>[]
          }
          create: {
            args: Prisma.FieldWellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>
          }
          createMany: {
            args: Prisma.FieldWellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldWellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>
          }
          update: {
            args: Prisma.FieldWellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>
          }
          deleteMany: {
            args: Prisma.FieldWellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldWellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldWellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldWellPayload>
          }
          aggregate: {
            args: Prisma.FieldWellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldWell>
          }
          groupBy: {
            args: Prisma.FieldWellGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldWellGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldWellFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldWellAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldWellCountArgs<ExtArgs>
            result: $Utils.Optional<FieldWellCountAggregateOutputType> | number
          }
        }
      }
      WorkerWellAssignment: {
        payload: Prisma.$WorkerWellAssignmentPayload<ExtArgs>
        fields: Prisma.WorkerWellAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerWellAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerWellAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>
          }
          findFirst: {
            args: Prisma.WorkerWellAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerWellAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>
          }
          findMany: {
            args: Prisma.WorkerWellAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>[]
          }
          create: {
            args: Prisma.WorkerWellAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>
          }
          createMany: {
            args: Prisma.WorkerWellAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkerWellAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>
          }
          update: {
            args: Prisma.WorkerWellAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.WorkerWellAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerWellAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerWellAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerWellAssignmentPayload>
          }
          aggregate: {
            args: Prisma.WorkerWellAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerWellAssignment>
          }
          groupBy: {
            args: Prisma.WorkerWellAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerWellAssignmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WorkerWellAssignmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WorkerWellAssignmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WorkerWellAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerWellAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Well: {
        payload: Prisma.$WellPayload<ExtArgs>
        fields: Prisma.WellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>
          }
          findFirst: {
            args: Prisma.WellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>
          }
          findMany: {
            args: Prisma.WellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>[]
          }
          create: {
            args: Prisma.WellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>
          }
          createMany: {
            args: Prisma.WellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>
          }
          update: {
            args: Prisma.WellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>
          }
          deleteMany: {
            args: Prisma.WellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellPayload>
          }
          aggregate: {
            args: Prisma.WellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWell>
          }
          groupBy: {
            args: Prisma.WellGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WellFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WellAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WellCountArgs<ExtArgs>
            result: $Utils.Optional<WellCountAggregateOutputType> | number
          }
        }
      }
      Crop: {
        payload: Prisma.$CropPayload<ExtArgs>
        fields: Prisma.CropFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CropFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CropFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findFirst: {
            args: Prisma.CropFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CropFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          findMany: {
            args: Prisma.CropFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>[]
          }
          create: {
            args: Prisma.CropCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          createMany: {
            args: Prisma.CropCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CropDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          update: {
            args: Prisma.CropUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          deleteMany: {
            args: Prisma.CropDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CropUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CropUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CropPayload>
          }
          aggregate: {
            args: Prisma.CropAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrop>
          }
          groupBy: {
            args: Prisma.CropGroupByArgs<ExtArgs>
            result: $Utils.Optional<CropGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CropFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CropAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CropCountArgs<ExtArgs>
            result: $Utils.Optional<CropCountAggregateOutputType> | number
          }
        }
      }
      ProcessingLog: {
        payload: Prisma.$ProcessingLogPayload<ExtArgs>
        fields: Prisma.ProcessingLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessingLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessingLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>
          }
          findFirst: {
            args: Prisma.ProcessingLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessingLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>
          }
          findMany: {
            args: Prisma.ProcessingLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>[]
          }
          create: {
            args: Prisma.ProcessingLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>
          }
          createMany: {
            args: Prisma.ProcessingLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessingLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>
          }
          update: {
            args: Prisma.ProcessingLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>
          }
          deleteMany: {
            args: Prisma.ProcessingLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessingLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessingLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessingLogPayload>
          }
          aggregate: {
            args: Prisma.ProcessingLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessingLog>
          }
          groupBy: {
            args: Prisma.ProcessingLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessingLogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProcessingLogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProcessingLogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProcessingLogCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessingLogCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InventoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InventoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryOwnership: {
        payload: Prisma.$InventoryOwnershipPayload<ExtArgs>
        fields: Prisma.InventoryOwnershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryOwnershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryOwnershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>
          }
          findFirst: {
            args: Prisma.InventoryOwnershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryOwnershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>
          }
          findMany: {
            args: Prisma.InventoryOwnershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>[]
          }
          create: {
            args: Prisma.InventoryOwnershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>
          }
          createMany: {
            args: Prisma.InventoryOwnershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryOwnershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>
          }
          update: {
            args: Prisma.InventoryOwnershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>
          }
          deleteMany: {
            args: Prisma.InventoryOwnershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryOwnershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryOwnershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryOwnershipPayload>
          }
          aggregate: {
            args: Prisma.InventoryOwnershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryOwnership>
          }
          groupBy: {
            args: Prisma.InventoryOwnershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryOwnershipGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InventoryOwnershipFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InventoryOwnershipAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InventoryOwnershipCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryOwnershipCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PurchaseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PurchaseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseApproval: {
        payload: Prisma.$PurchaseApprovalPayload<ExtArgs>
        fields: Prisma.PurchaseApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>
          }
          findFirst: {
            args: Prisma.PurchaseApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>
          }
          findMany: {
            args: Prisma.PurchaseApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>[]
          }
          create: {
            args: Prisma.PurchaseApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>
          }
          createMany: {
            args: Prisma.PurchaseApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>
          }
          update: {
            args: Prisma.PurchaseApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseApprovalPayload>
          }
          aggregate: {
            args: Prisma.PurchaseApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseApproval>
          }
          groupBy: {
            args: Prisma.PurchaseApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseApprovalGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PurchaseApprovalFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PurchaseApprovalAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PurchaseApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseApprovalCountAggregateOutputType> | number
          }
        }
      }
      PurchaseContributor: {
        payload: Prisma.$PurchaseContributorPayload<ExtArgs>
        fields: Prisma.PurchaseContributorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseContributorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseContributorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>
          }
          findFirst: {
            args: Prisma.PurchaseContributorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseContributorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>
          }
          findMany: {
            args: Prisma.PurchaseContributorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>[]
          }
          create: {
            args: Prisma.PurchaseContributorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>
          }
          createMany: {
            args: Prisma.PurchaseContributorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseContributorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>
          }
          update: {
            args: Prisma.PurchaseContributorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseContributorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseContributorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseContributorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseContributorPayload>
          }
          aggregate: {
            args: Prisma.PurchaseContributorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseContributor>
          }
          groupBy: {
            args: Prisma.PurchaseContributorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseContributorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PurchaseContributorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PurchaseContributorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PurchaseContributorCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseContributorCountAggregateOutputType> | number
          }
        }
      }
      PaymentHistory: {
        payload: Prisma.$PaymentHistoryPayload<ExtArgs>
        fields: Prisma.PaymentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          findFirst: {
            args: Prisma.PaymentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          findMany: {
            args: Prisma.PaymentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>[]
          }
          create: {
            args: Prisma.PaymentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          createMany: {
            args: Prisma.PaymentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          update: {
            args: Prisma.PaymentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PaymentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          aggregate: {
            args: Prisma.PaymentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentHistory>
          }
          groupBy: {
            args: Prisma.PaymentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentHistoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PaymentHistoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PaymentHistoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PaymentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentHistoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryTransaction: {
        payload: Prisma.$InventoryTransactionPayload<ExtArgs>
        fields: Prisma.InventoryTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findFirst: {
            args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findMany: {
            args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          create: {
            args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          createMany: {
            args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          update: {
            args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          aggregate: {
            args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryTransaction>
          }
          groupBy: {
            args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InventoryTransactionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InventoryTransactionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InventoryTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionCountAggregateOutputType> | number
          }
        }
      }
      Debt: {
        payload: Prisma.$DebtPayload<ExtArgs>
        fields: Prisma.DebtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          findFirst: {
            args: Prisma.DebtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          findMany: {
            args: Prisma.DebtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>[]
          }
          create: {
            args: Prisma.DebtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          createMany: {
            args: Prisma.DebtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DebtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          update: {
            args: Prisma.DebtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          deleteMany: {
            args: Prisma.DebtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DebtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          aggregate: {
            args: Prisma.DebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebt>
          }
          groupBy: {
            args: Prisma.DebtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DebtFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DebtAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DebtCountArgs<ExtArgs>
            result: $Utils.Optional<DebtCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InvoiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InvoiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InventoryUsage: {
        payload: Prisma.$InventoryUsagePayload<ExtArgs>
        fields: Prisma.InventoryUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          findFirst: {
            args: Prisma.InventoryUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          findMany: {
            args: Prisma.InventoryUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>[]
          }
          create: {
            args: Prisma.InventoryUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          createMany: {
            args: Prisma.InventoryUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          update: {
            args: Prisma.InventoryUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          deleteMany: {
            args: Prisma.InventoryUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          aggregate: {
            args: Prisma.InventoryUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryUsage>
          }
          groupBy: {
            args: Prisma.InventoryUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InventoryUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InventoryUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InventoryUsageCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryUsageCountAggregateOutputType> | number
          }
        }
      }
      Process: {
        payload: Prisma.$ProcessPayload<ExtArgs>
        fields: Prisma.ProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findFirst: {
            args: Prisma.ProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findMany: {
            args: Prisma.ProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          create: {
            args: Prisma.ProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          createMany: {
            args: Prisma.ProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          update: {
            args: Prisma.ProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          aggregate: {
            args: Prisma.ProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcess>
          }
          groupBy: {
            args: Prisma.ProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProcessFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProcessAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationPreferenceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationPreferenceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EquipmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EquipmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      EquipmentOwnership: {
        payload: Prisma.$EquipmentOwnershipPayload<ExtArgs>
        fields: Prisma.EquipmentOwnershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentOwnershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentOwnershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>
          }
          findFirst: {
            args: Prisma.EquipmentOwnershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentOwnershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>
          }
          findMany: {
            args: Prisma.EquipmentOwnershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>[]
          }
          create: {
            args: Prisma.EquipmentOwnershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>
          }
          createMany: {
            args: Prisma.EquipmentOwnershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EquipmentOwnershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>
          }
          update: {
            args: Prisma.EquipmentOwnershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentOwnershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentOwnershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentOwnershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentOwnershipPayload>
          }
          aggregate: {
            args: Prisma.EquipmentOwnershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentOwnership>
          }
          groupBy: {
            args: Prisma.EquipmentOwnershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentOwnershipGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EquipmentOwnershipFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EquipmentOwnershipAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EquipmentOwnershipCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentOwnershipCountAggregateOutputType> | number
          }
        }
      }
      EquipmentCapability: {
        payload: Prisma.$EquipmentCapabilityPayload<ExtArgs>
        fields: Prisma.EquipmentCapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentCapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentCapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>
          }
          findFirst: {
            args: Prisma.EquipmentCapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentCapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>
          }
          findMany: {
            args: Prisma.EquipmentCapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>[]
          }
          create: {
            args: Prisma.EquipmentCapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>
          }
          createMany: {
            args: Prisma.EquipmentCapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EquipmentCapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>
          }
          update: {
            args: Prisma.EquipmentCapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentCapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentCapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentCapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentCapabilityPayload>
          }
          aggregate: {
            args: Prisma.EquipmentCapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentCapability>
          }
          groupBy: {
            args: Prisma.EquipmentCapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCapabilityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EquipmentCapabilityFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EquipmentCapabilityAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EquipmentCapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCapabilityCountAggregateOutputType> | number
          }
        }
      }
      EquipmentUsage: {
        payload: Prisma.$EquipmentUsagePayload<ExtArgs>
        fields: Prisma.EquipmentUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>
          }
          findFirst: {
            args: Prisma.EquipmentUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>
          }
          findMany: {
            args: Prisma.EquipmentUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>[]
          }
          create: {
            args: Prisma.EquipmentUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>
          }
          createMany: {
            args: Prisma.EquipmentUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EquipmentUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>
          }
          update: {
            args: Prisma.EquipmentUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>
          }
          deleteMany: {
            args: Prisma.EquipmentUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentUsagePayload>
          }
          aggregate: {
            args: Prisma.EquipmentUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentUsage>
          }
          groupBy: {
            args: Prisma.EquipmentUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EquipmentUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EquipmentUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EquipmentUsageCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentUsageCountAggregateOutputType> | number
          }
        }
      }
      ProcessCost: {
        payload: Prisma.$ProcessCostPayload<ExtArgs>
        fields: Prisma.ProcessCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>
          }
          findFirst: {
            args: Prisma.ProcessCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>
          }
          findMany: {
            args: Prisma.ProcessCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>[]
          }
          create: {
            args: Prisma.ProcessCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>
          }
          createMany: {
            args: Prisma.ProcessCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcessCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>
          }
          update: {
            args: Prisma.ProcessCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>
          }
          deleteMany: {
            args: Prisma.ProcessCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCostPayload>
          }
          aggregate: {
            args: Prisma.ProcessCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessCost>
          }
          groupBy: {
            args: Prisma.ProcessCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessCostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProcessCostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProcessCostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProcessCostCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCostCountAggregateOutputType> | number
          }
        }
      }
      FieldExpense: {
        payload: Prisma.$FieldExpensePayload<ExtArgs>
        fields: Prisma.FieldExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>
          }
          findFirst: {
            args: Prisma.FieldExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>
          }
          findMany: {
            args: Prisma.FieldExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>[]
          }
          create: {
            args: Prisma.FieldExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>
          }
          createMany: {
            args: Prisma.FieldExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>
          }
          update: {
            args: Prisma.FieldExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>
          }
          deleteMany: {
            args: Prisma.FieldExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldExpensePayload>
          }
          aggregate: {
            args: Prisma.FieldExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldExpense>
          }
          groupBy: {
            args: Prisma.FieldExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldExpenseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldExpenseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldExpenseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<FieldExpenseCountAggregateOutputType> | number
          }
        }
      }
      FieldOwnerExpense: {
        payload: Prisma.$FieldOwnerExpensePayload<ExtArgs>
        fields: Prisma.FieldOwnerExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldOwnerExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldOwnerExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>
          }
          findFirst: {
            args: Prisma.FieldOwnerExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldOwnerExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>
          }
          findMany: {
            args: Prisma.FieldOwnerExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>[]
          }
          create: {
            args: Prisma.FieldOwnerExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>
          }
          createMany: {
            args: Prisma.FieldOwnerExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FieldOwnerExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>
          }
          update: {
            args: Prisma.FieldOwnerExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>
          }
          deleteMany: {
            args: Prisma.FieldOwnerExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldOwnerExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FieldOwnerExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOwnerExpensePayload>
          }
          aggregate: {
            args: Prisma.FieldOwnerExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldOwnerExpense>
          }
          groupBy: {
            args: Prisma.FieldOwnerExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldOwnerExpenseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FieldOwnerExpenseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FieldOwnerExpenseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FieldOwnerExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<FieldOwnerExpenseCountAggregateOutputType> | number
          }
        }
      }
      IrrigationLog: {
        payload: Prisma.$IrrigationLogPayload<ExtArgs>
        fields: Prisma.IrrigationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>
          }
          findFirst: {
            args: Prisma.IrrigationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>
          }
          findMany: {
            args: Prisma.IrrigationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>[]
          }
          create: {
            args: Prisma.IrrigationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>
          }
          createMany: {
            args: Prisma.IrrigationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IrrigationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>
          }
          update: {
            args: Prisma.IrrigationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>
          }
          deleteMany: {
            args: Prisma.IrrigationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IrrigationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationLogPayload>
          }
          aggregate: {
            args: Prisma.IrrigationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationLog>
          }
          groupBy: {
            args: Prisma.IrrigationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationLogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IrrigationLogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IrrigationLogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IrrigationLogCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationLogCountAggregateOutputType> | number
          }
        }
      }
      IrrigationFieldUsage: {
        payload: Prisma.$IrrigationFieldUsagePayload<ExtArgs>
        fields: Prisma.IrrigationFieldUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationFieldUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationFieldUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>
          }
          findFirst: {
            args: Prisma.IrrigationFieldUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationFieldUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>
          }
          findMany: {
            args: Prisma.IrrigationFieldUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>[]
          }
          create: {
            args: Prisma.IrrigationFieldUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>
          }
          createMany: {
            args: Prisma.IrrigationFieldUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IrrigationFieldUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>
          }
          update: {
            args: Prisma.IrrigationFieldUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>
          }
          deleteMany: {
            args: Prisma.IrrigationFieldUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationFieldUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IrrigationFieldUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationFieldUsagePayload>
          }
          aggregate: {
            args: Prisma.IrrigationFieldUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationFieldUsage>
          }
          groupBy: {
            args: Prisma.IrrigationFieldUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationFieldUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IrrigationFieldUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IrrigationFieldUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IrrigationFieldUsageCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationFieldUsageCountAggregateOutputType> | number
          }
        }
      }
      IrrigationOwnerUsage: {
        payload: Prisma.$IrrigationOwnerUsagePayload<ExtArgs>
        fields: Prisma.IrrigationOwnerUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationOwnerUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationOwnerUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>
          }
          findFirst: {
            args: Prisma.IrrigationOwnerUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationOwnerUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>
          }
          findMany: {
            args: Prisma.IrrigationOwnerUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>[]
          }
          create: {
            args: Prisma.IrrigationOwnerUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>
          }
          createMany: {
            args: Prisma.IrrigationOwnerUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IrrigationOwnerUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>
          }
          update: {
            args: Prisma.IrrigationOwnerUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>
          }
          deleteMany: {
            args: Prisma.IrrigationOwnerUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationOwnerUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IrrigationOwnerUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerUsagePayload>
          }
          aggregate: {
            args: Prisma.IrrigationOwnerUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationOwnerUsage>
          }
          groupBy: {
            args: Prisma.IrrigationOwnerUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationOwnerUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IrrigationOwnerUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IrrigationOwnerUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IrrigationOwnerUsageCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationOwnerUsageCountAggregateOutputType> | number
          }
        }
      }
      IrrigationOwnerSummary: {
        payload: Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>
        fields: Prisma.IrrigationOwnerSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationOwnerSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationOwnerSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>
          }
          findFirst: {
            args: Prisma.IrrigationOwnerSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationOwnerSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>
          }
          findMany: {
            args: Prisma.IrrigationOwnerSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>[]
          }
          create: {
            args: Prisma.IrrigationOwnerSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>
          }
          createMany: {
            args: Prisma.IrrigationOwnerSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IrrigationOwnerSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>
          }
          update: {
            args: Prisma.IrrigationOwnerSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>
          }
          deleteMany: {
            args: Prisma.IrrigationOwnerSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationOwnerSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IrrigationOwnerSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationOwnerSummaryPayload>
          }
          aggregate: {
            args: Prisma.IrrigationOwnerSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationOwnerSummary>
          }
          groupBy: {
            args: Prisma.IrrigationOwnerSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationOwnerSummaryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IrrigationOwnerSummaryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IrrigationOwnerSummaryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IrrigationOwnerSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationOwnerSummaryCountAggregateOutputType> | number
          }
        }
      }
      IrrigationInventoryUsage: {
        payload: Prisma.$IrrigationInventoryUsagePayload<ExtArgs>
        fields: Prisma.IrrigationInventoryUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationInventoryUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationInventoryUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>
          }
          findFirst: {
            args: Prisma.IrrigationInventoryUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationInventoryUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>
          }
          findMany: {
            args: Prisma.IrrigationInventoryUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>[]
          }
          create: {
            args: Prisma.IrrigationInventoryUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>
          }
          createMany: {
            args: Prisma.IrrigationInventoryUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IrrigationInventoryUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>
          }
          update: {
            args: Prisma.IrrigationInventoryUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>
          }
          deleteMany: {
            args: Prisma.IrrigationInventoryUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationInventoryUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IrrigationInventoryUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryUsagePayload>
          }
          aggregate: {
            args: Prisma.IrrigationInventoryUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationInventoryUsage>
          }
          groupBy: {
            args: Prisma.IrrigationInventoryUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationInventoryUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IrrigationInventoryUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IrrigationInventoryUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IrrigationInventoryUsageCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationInventoryUsageCountAggregateOutputType> | number
          }
        }
      }
      IrrigationInventoryOwnerUsage: {
        payload: Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>
        fields: Prisma.IrrigationInventoryOwnerUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationInventoryOwnerUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationInventoryOwnerUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>
          }
          findFirst: {
            args: Prisma.IrrigationInventoryOwnerUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationInventoryOwnerUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>
          }
          findMany: {
            args: Prisma.IrrigationInventoryOwnerUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>[]
          }
          create: {
            args: Prisma.IrrigationInventoryOwnerUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>
          }
          createMany: {
            args: Prisma.IrrigationInventoryOwnerUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IrrigationInventoryOwnerUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>
          }
          update: {
            args: Prisma.IrrigationInventoryOwnerUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>
          }
          deleteMany: {
            args: Prisma.IrrigationInventoryOwnerUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationInventoryOwnerUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IrrigationInventoryOwnerUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationInventoryOwnerUsagePayload>
          }
          aggregate: {
            args: Prisma.IrrigationInventoryOwnerUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationInventoryOwnerUsage>
          }
          groupBy: {
            args: Prisma.IrrigationInventoryOwnerUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationInventoryOwnerUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.IrrigationInventoryOwnerUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.IrrigationInventoryOwnerUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.IrrigationInventoryOwnerUsageCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationInventoryOwnerUsageCountAggregateOutputType> | number
          }
        }
      }
      WellBillingPeriod: {
        payload: Prisma.$WellBillingPeriodPayload<ExtArgs>
        fields: Prisma.WellBillingPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellBillingPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellBillingPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>
          }
          findFirst: {
            args: Prisma.WellBillingPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellBillingPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>
          }
          findMany: {
            args: Prisma.WellBillingPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>[]
          }
          create: {
            args: Prisma.WellBillingPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>
          }
          createMany: {
            args: Prisma.WellBillingPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WellBillingPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>
          }
          update: {
            args: Prisma.WellBillingPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>
          }
          deleteMany: {
            args: Prisma.WellBillingPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellBillingPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WellBillingPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingPeriodPayload>
          }
          aggregate: {
            args: Prisma.WellBillingPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellBillingPeriod>
          }
          groupBy: {
            args: Prisma.WellBillingPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellBillingPeriodGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WellBillingPeriodFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WellBillingPeriodAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WellBillingPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<WellBillingPeriodCountAggregateOutputType> | number
          }
        }
      }
      WellBillingIrrigationUsage: {
        payload: Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>
        fields: Prisma.WellBillingIrrigationUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellBillingIrrigationUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellBillingIrrigationUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>
          }
          findFirst: {
            args: Prisma.WellBillingIrrigationUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellBillingIrrigationUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>
          }
          findMany: {
            args: Prisma.WellBillingIrrigationUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>[]
          }
          create: {
            args: Prisma.WellBillingIrrigationUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>
          }
          createMany: {
            args: Prisma.WellBillingIrrigationUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WellBillingIrrigationUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>
          }
          update: {
            args: Prisma.WellBillingIrrigationUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>
          }
          deleteMany: {
            args: Prisma.WellBillingIrrigationUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellBillingIrrigationUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WellBillingIrrigationUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillingIrrigationUsagePayload>
          }
          aggregate: {
            args: Prisma.WellBillingIrrigationUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellBillingIrrigationUsage>
          }
          groupBy: {
            args: Prisma.WellBillingIrrigationUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellBillingIrrigationUsageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WellBillingIrrigationUsageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WellBillingIrrigationUsageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WellBillingIrrigationUsageCountArgs<ExtArgs>
            result: $Utils.Optional<WellBillingIrrigationUsageCountAggregateOutputType> | number
          }
        }
      }
      WellBillDistribution: {
        payload: Prisma.$WellBillDistributionPayload<ExtArgs>
        fields: Prisma.WellBillDistributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellBillDistributionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellBillDistributionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>
          }
          findFirst: {
            args: Prisma.WellBillDistributionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellBillDistributionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>
          }
          findMany: {
            args: Prisma.WellBillDistributionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>[]
          }
          create: {
            args: Prisma.WellBillDistributionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>
          }
          createMany: {
            args: Prisma.WellBillDistributionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WellBillDistributionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>
          }
          update: {
            args: Prisma.WellBillDistributionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>
          }
          deleteMany: {
            args: Prisma.WellBillDistributionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellBillDistributionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WellBillDistributionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellBillDistributionPayload>
          }
          aggregate: {
            args: Prisma.WellBillDistributionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellBillDistribution>
          }
          groupBy: {
            args: Prisma.WellBillDistributionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellBillDistributionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WellBillDistributionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WellBillDistributionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WellBillDistributionCountArgs<ExtArgs>
            result: $Utils.Optional<WellBillDistributionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    season?: SeasonOmit
    field?: FieldOmit
    fieldOwnership?: FieldOwnershipOmit
    fieldWorkerAssignment?: FieldWorkerAssignmentOmit
    fieldWell?: FieldWellOmit
    workerWellAssignment?: WorkerWellAssignmentOmit
    well?: WellOmit
    crop?: CropOmit
    processingLog?: ProcessingLogOmit
    inventory?: InventoryOmit
    inventoryOwnership?: InventoryOwnershipOmit
    purchase?: PurchaseOmit
    purchaseApproval?: PurchaseApprovalOmit
    purchaseContributor?: PurchaseContributorOmit
    paymentHistory?: PaymentHistoryOmit
    inventoryTransaction?: InventoryTransactionOmit
    debt?: DebtOmit
    invoice?: InvoiceOmit
    inventoryUsage?: InventoryUsageOmit
    process?: ProcessOmit
    notification?: NotificationOmit
    notificationPreference?: NotificationPreferenceOmit
    equipment?: EquipmentOmit
    equipmentOwnership?: EquipmentOwnershipOmit
    equipmentCapability?: EquipmentCapabilityOmit
    equipmentUsage?: EquipmentUsageOmit
    processCost?: ProcessCostOmit
    fieldExpense?: FieldExpenseOmit
    fieldOwnerExpense?: FieldOwnerExpenseOmit
    irrigationLog?: IrrigationLogOmit
    irrigationFieldUsage?: IrrigationFieldUsageOmit
    irrigationOwnerUsage?: IrrigationOwnerUsageOmit
    irrigationOwnerSummary?: IrrigationOwnerSummaryOmit
    irrigationInventoryUsage?: IrrigationInventoryUsageOmit
    irrigationInventoryOwnerUsage?: IrrigationInventoryOwnerUsageOmit
    wellBillingPeriod?: WellBillingPeriodOmit
    wellBillingIrrigationUsage?: WellBillingIrrigationUsageOmit
    wellBillDistribution?: WellBillDistributionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    irrigationLogs: number
    ownedFields: number
    assignedFields: number
    inventoryOwnership: number
    debtsAsCreditor: number
    debtsAsDebtor: number
    purchaseContributions: number
    receivedNotifications: number
    sentNotifications: number
    inventoryUsages: number
    processes: number
    invoicesPurchased: number
    paymentsMade: number
    paymentsReceived: number
    inventoryTransactions: number
    seasons: number
    purchaseApprovals: number
    equipmentOwnerships: number
    equipmentUsages: number
    fieldOwnerExpenses: number
    wellAssignments: number
    irrigationOwnerUsages: number
    irrigationInventoryOwnerUsages: number
    irrigationOwnerSummaries: number
    wellBillDistributions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationLogs?: boolean | UserCountOutputTypeCountIrrigationLogsArgs
    ownedFields?: boolean | UserCountOutputTypeCountOwnedFieldsArgs
    assignedFields?: boolean | UserCountOutputTypeCountAssignedFieldsArgs
    inventoryOwnership?: boolean | UserCountOutputTypeCountInventoryOwnershipArgs
    debtsAsCreditor?: boolean | UserCountOutputTypeCountDebtsAsCreditorArgs
    debtsAsDebtor?: boolean | UserCountOutputTypeCountDebtsAsDebtorArgs
    purchaseContributions?: boolean | UserCountOutputTypeCountPurchaseContributionsArgs
    receivedNotifications?: boolean | UserCountOutputTypeCountReceivedNotificationsArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    inventoryUsages?: boolean | UserCountOutputTypeCountInventoryUsagesArgs
    processes?: boolean | UserCountOutputTypeCountProcessesArgs
    invoicesPurchased?: boolean | UserCountOutputTypeCountInvoicesPurchasedArgs
    paymentsMade?: boolean | UserCountOutputTypeCountPaymentsMadeArgs
    paymentsReceived?: boolean | UserCountOutputTypeCountPaymentsReceivedArgs
    inventoryTransactions?: boolean | UserCountOutputTypeCountInventoryTransactionsArgs
    seasons?: boolean | UserCountOutputTypeCountSeasonsArgs
    purchaseApprovals?: boolean | UserCountOutputTypeCountPurchaseApprovalsArgs
    equipmentOwnerships?: boolean | UserCountOutputTypeCountEquipmentOwnershipsArgs
    equipmentUsages?: boolean | UserCountOutputTypeCountEquipmentUsagesArgs
    fieldOwnerExpenses?: boolean | UserCountOutputTypeCountFieldOwnerExpensesArgs
    wellAssignments?: boolean | UserCountOutputTypeCountWellAssignmentsArgs
    irrigationOwnerUsages?: boolean | UserCountOutputTypeCountIrrigationOwnerUsagesArgs
    irrigationInventoryOwnerUsages?: boolean | UserCountOutputTypeCountIrrigationInventoryOwnerUsagesArgs
    irrigationOwnerSummaries?: boolean | UserCountOutputTypeCountIrrigationOwnerSummariesArgs
    wellBillDistributions?: boolean | UserCountOutputTypeCountWellBillDistributionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIrrigationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWorkerAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryOwnershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryOwnershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtsAsCreditorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtsAsDebtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseContributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseContributorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesPurchasedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEquipmentOwnershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentOwnershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEquipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFieldOwnerExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnerExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWellAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWellAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIrrigationOwnerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationOwnerUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIrrigationInventoryOwnerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationInventoryOwnerUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIrrigationOwnerSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationOwnerSummaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWellBillDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillDistributionWhereInput
  }


  /**
   * Count Type SeasonCountOutputType
   */

  export type SeasonCountOutputType = {
    fields: number
    crops: number
    purchases: number
    inventoryTransactions: number
    processes: number
    irrigationLogs: number
    fieldExpenses: number
    notifications: number
  }

  export type SeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fields?: boolean | SeasonCountOutputTypeCountFieldsArgs
    crops?: boolean | SeasonCountOutputTypeCountCropsArgs
    purchases?: boolean | SeasonCountOutputTypeCountPurchasesArgs
    inventoryTransactions?: boolean | SeasonCountOutputTypeCountInventoryTransactionsArgs
    processes?: boolean | SeasonCountOutputTypeCountProcessesArgs
    irrigationLogs?: boolean | SeasonCountOutputTypeCountIrrigationLogsArgs
    fieldExpenses?: boolean | SeasonCountOutputTypeCountFieldExpensesArgs
    notifications?: boolean | SeasonCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountCropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountInventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountIrrigationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationLogWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountFieldExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldExpenseWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type FieldCountOutputType
   */

  export type FieldCountOutputType = {
    owners: number
    workerAssignments: number
    crops: number
    fieldWells: number
    processingLogs: number
    processCosts: number
    inventoryUsages: number
    processes: number
    fieldExpenses: number
    notifications: number
    irrigationFieldUsages: number
    wellBillDistributions: number
  }

  export type FieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners?: boolean | FieldCountOutputTypeCountOwnersArgs
    workerAssignments?: boolean | FieldCountOutputTypeCountWorkerAssignmentsArgs
    crops?: boolean | FieldCountOutputTypeCountCropsArgs
    fieldWells?: boolean | FieldCountOutputTypeCountFieldWellsArgs
    processingLogs?: boolean | FieldCountOutputTypeCountProcessingLogsArgs
    processCosts?: boolean | FieldCountOutputTypeCountProcessCostsArgs
    inventoryUsages?: boolean | FieldCountOutputTypeCountInventoryUsagesArgs
    processes?: boolean | FieldCountOutputTypeCountProcessesArgs
    fieldExpenses?: boolean | FieldCountOutputTypeCountFieldExpensesArgs
    notifications?: boolean | FieldCountOutputTypeCountNotificationsArgs
    irrigationFieldUsages?: boolean | FieldCountOutputTypeCountIrrigationFieldUsagesArgs
    wellBillDistributions?: boolean | FieldCountOutputTypeCountWellBillDistributionsArgs
  }

  // Custom InputTypes
  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldCountOutputType
     */
    select?: FieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnershipWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountWorkerAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWorkerAssignmentWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountCropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFieldWellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWellWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountProcessingLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingLogWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountProcessCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessCostWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountInventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFieldExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldExpenseWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountIrrigationFieldUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationFieldUsageWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountWellBillDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillDistributionWhereInput
  }


  /**
   * Count Type FieldOwnershipCountOutputType
   */

  export type FieldOwnershipCountOutputType = {
    ownerExpenses: number
  }

  export type FieldOwnershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerExpenses?: boolean | FieldOwnershipCountOutputTypeCountOwnerExpensesArgs
  }

  // Custom InputTypes
  /**
   * FieldOwnershipCountOutputType without action
   */
  export type FieldOwnershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnershipCountOutputType
     */
    select?: FieldOwnershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldOwnershipCountOutputType without action
   */
  export type FieldOwnershipCountOutputTypeCountOwnerExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnerExpenseWhereInput
  }


  /**
   * Count Type WellCountOutputType
   */

  export type WellCountOutputType = {
    fieldWells: number
    notifications: number
    irrigationLogs: number
    wellBillingPeriods: number
    workerAssignments: number
  }

  export type WellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fieldWells?: boolean | WellCountOutputTypeCountFieldWellsArgs
    notifications?: boolean | WellCountOutputTypeCountNotificationsArgs
    irrigationLogs?: boolean | WellCountOutputTypeCountIrrigationLogsArgs
    wellBillingPeriods?: boolean | WellCountOutputTypeCountWellBillingPeriodsArgs
    workerAssignments?: boolean | WellCountOutputTypeCountWorkerAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * WellCountOutputType without action
   */
  export type WellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellCountOutputType
     */
    select?: WellCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WellCountOutputType without action
   */
  export type WellCountOutputTypeCountFieldWellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWellWhereInput
  }

  /**
   * WellCountOutputType without action
   */
  export type WellCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * WellCountOutputType without action
   */
  export type WellCountOutputTypeCountIrrigationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationLogWhereInput
  }

  /**
   * WellCountOutputType without action
   */
  export type WellCountOutputTypeCountWellBillingPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillingPeriodWhereInput
  }

  /**
   * WellCountOutputType without action
   */
  export type WellCountOutputTypeCountWorkerAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWellAssignmentWhereInput
  }


  /**
   * Count Type CropCountOutputType
   */

  export type CropCountOutputType = {
    notifications: number
  }

  export type CropCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | CropCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CropCountOutputType
     */
    select?: CropCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CropCountOutputType without action
   */
  export type CropCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ProcessingLogCountOutputType
   */

  export type ProcessingLogCountOutputType = {
    notifications: number
  }

  export type ProcessingLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | ProcessingLogCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ProcessingLogCountOutputType without action
   */
  export type ProcessingLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLogCountOutputType
     */
    select?: ProcessingLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessingLogCountOutputType without action
   */
  export type ProcessingLogCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    ownerships: number
    usages: number
    inventoryTransactions: number
    notifications: number
    irrigationInventoryUsages: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerships?: boolean | InventoryCountOutputTypeCountOwnershipsArgs
    usages?: boolean | InventoryCountOutputTypeCountUsagesArgs
    inventoryTransactions?: boolean | InventoryCountOutputTypeCountInventoryTransactionsArgs
    notifications?: boolean | InventoryCountOutputTypeCountNotificationsArgs
    irrigationInventoryUsages?: boolean | InventoryCountOutputTypeCountIrrigationInventoryUsagesArgs
  }

  // Custom InputTypes
  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountOwnershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryOwnershipWhereInput
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountIrrigationInventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationInventoryUsageWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    contributors: number
    debts: number
    invoices: number
    inventoryTransactions: number
    approvals: number
    notifications: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributors?: boolean | PurchaseCountOutputTypeCountContributorsArgs
    debts?: boolean | PurchaseCountOutputTypeCountDebtsArgs
    invoices?: boolean | PurchaseCountOutputTypeCountInvoicesArgs
    inventoryTransactions?: boolean | PurchaseCountOutputTypeCountInventoryTransactionsArgs
    approvals?: boolean | PurchaseCountOutputTypeCountApprovalsArgs
    notifications?: boolean | PurchaseCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountContributorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseContributorWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountDebtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountInventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseApprovalWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PurchaseApprovalCountOutputType
   */

  export type PurchaseApprovalCountOutputType = {
    notifications: number
  }

  export type PurchaseApprovalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | PurchaseApprovalCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseApprovalCountOutputType without action
   */
  export type PurchaseApprovalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApprovalCountOutputType
     */
    select?: PurchaseApprovalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseApprovalCountOutputType without action
   */
  export type PurchaseApprovalCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PurchaseContributorCountOutputType
   */

  export type PurchaseContributorCountOutputType = {
    paymentHistory: number
    notifications: number
  }

  export type PurchaseContributorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentHistory?: boolean | PurchaseContributorCountOutputTypeCountPaymentHistoryArgs
    notifications?: boolean | PurchaseContributorCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseContributorCountOutputType without action
   */
  export type PurchaseContributorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributorCountOutputType
     */
    select?: PurchaseContributorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseContributorCountOutputType without action
   */
  export type PurchaseContributorCountOutputTypeCountPaymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentHistoryWhereInput
  }

  /**
   * PurchaseContributorCountOutputType without action
   */
  export type PurchaseContributorCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PaymentHistoryCountOutputType
   */

  export type PaymentHistoryCountOutputType = {
    notifications: number
  }

  export type PaymentHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | PaymentHistoryCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PaymentHistoryCountOutputType without action
   */
  export type PaymentHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistoryCountOutputType
     */
    select?: PaymentHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentHistoryCountOutputType without action
   */
  export type PaymentHistoryCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InventoryTransactionCountOutputType
   */

  export type InventoryTransactionCountOutputType = {
    notifications: number
  }

  export type InventoryTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | InventoryTransactionCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * InventoryTransactionCountOutputType without action
   */
  export type InventoryTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransactionCountOutputType
     */
    select?: InventoryTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryTransactionCountOutputType without action
   */
  export type InventoryTransactionCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type DebtCountOutputType
   */

  export type DebtCountOutputType = {
    paymentHistory: number
    wellBillDistributions: number
    notifications: number
  }

  export type DebtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentHistory?: boolean | DebtCountOutputTypeCountPaymentHistoryArgs
    wellBillDistributions?: boolean | DebtCountOutputTypeCountWellBillDistributionsArgs
    notifications?: boolean | DebtCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtCountOutputType
     */
    select?: DebtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountPaymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentHistoryWhereInput
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountWellBillDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillDistributionWhereInput
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    debts: number
    notifications: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debts?: boolean | InvoiceCountOutputTypeCountDebtsArgs
    notifications?: boolean | InvoiceCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountDebtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InventoryUsageCountOutputType
   */

  export type InventoryUsageCountOutputType = {
    notifications: number
  }

  export type InventoryUsageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | InventoryUsageCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * InventoryUsageCountOutputType without action
   */
  export type InventoryUsageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsageCountOutputType
     */
    select?: InventoryUsageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryUsageCountOutputType without action
   */
  export type InventoryUsageCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ProcessCountOutputType
   */

  export type ProcessCountOutputType = {
    inventoryUsages: number
    equipmentUsages: number
    processCosts: number
    notifications: number
  }

  export type ProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryUsages?: boolean | ProcessCountOutputTypeCountInventoryUsagesArgs
    equipmentUsages?: boolean | ProcessCountOutputTypeCountEquipmentUsagesArgs
    processCosts?: boolean | ProcessCountOutputTypeCountProcessCostsArgs
    notifications?: boolean | ProcessCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCountOutputType
     */
    select?: ProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountInventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountEquipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentUsageWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountProcessCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessCostWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    ownerships: number
    capabilities: number
    usages: number
    notifications: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerships?: boolean | EquipmentCountOutputTypeCountOwnershipsArgs
    capabilities?: boolean | EquipmentCountOutputTypeCountCapabilitiesArgs
    usages?: boolean | EquipmentCountOutputTypeCountUsagesArgs
    notifications?: boolean | EquipmentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountOwnershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentOwnershipWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCapabilityWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentUsageWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type EquipmentUsageCountOutputType
   */

  export type EquipmentUsageCountOutputType = {
    notifications: number
  }

  export type EquipmentUsageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | EquipmentUsageCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentUsageCountOutputType without action
   */
  export type EquipmentUsageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsageCountOutputType
     */
    select?: EquipmentUsageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentUsageCountOutputType without action
   */
  export type EquipmentUsageCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ProcessCostCountOutputType
   */

  export type ProcessCostCountOutputType = {
    ownerExpenses: number
    notifications: number
  }

  export type ProcessCostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerExpenses?: boolean | ProcessCostCountOutputTypeCountOwnerExpensesArgs
    notifications?: boolean | ProcessCostCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ProcessCostCountOutputType without action
   */
  export type ProcessCostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCostCountOutputType
     */
    select?: ProcessCostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessCostCountOutputType without action
   */
  export type ProcessCostCountOutputTypeCountOwnerExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnerExpenseWhereInput
  }

  /**
   * ProcessCostCountOutputType without action
   */
  export type ProcessCostCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type FieldExpenseCountOutputType
   */

  export type FieldExpenseCountOutputType = {
    notifications: number
  }

  export type FieldExpenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | FieldExpenseCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * FieldExpenseCountOutputType without action
   */
  export type FieldExpenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpenseCountOutputType
     */
    select?: FieldExpenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldExpenseCountOutputType without action
   */
  export type FieldExpenseCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type FieldOwnerExpenseCountOutputType
   */

  export type FieldOwnerExpenseCountOutputType = {
    notifications: number
  }

  export type FieldOwnerExpenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | FieldOwnerExpenseCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * FieldOwnerExpenseCountOutputType without action
   */
  export type FieldOwnerExpenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpenseCountOutputType
     */
    select?: FieldOwnerExpenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldOwnerExpenseCountOutputType without action
   */
  export type FieldOwnerExpenseCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type IrrigationLogCountOutputType
   */

  export type IrrigationLogCountOutputType = {
    fieldUsages: number
    inventoryUsages: number
    billingUsages: number
    ownerSummaries: number
    notifications: number
  }

  export type IrrigationLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fieldUsages?: boolean | IrrigationLogCountOutputTypeCountFieldUsagesArgs
    inventoryUsages?: boolean | IrrigationLogCountOutputTypeCountInventoryUsagesArgs
    billingUsages?: boolean | IrrigationLogCountOutputTypeCountBillingUsagesArgs
    ownerSummaries?: boolean | IrrigationLogCountOutputTypeCountOwnerSummariesArgs
    notifications?: boolean | IrrigationLogCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * IrrigationLogCountOutputType without action
   */
  export type IrrigationLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLogCountOutputType
     */
    select?: IrrigationLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IrrigationLogCountOutputType without action
   */
  export type IrrigationLogCountOutputTypeCountFieldUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationFieldUsageWhereInput
  }

  /**
   * IrrigationLogCountOutputType without action
   */
  export type IrrigationLogCountOutputTypeCountInventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationInventoryUsageWhereInput
  }

  /**
   * IrrigationLogCountOutputType without action
   */
  export type IrrigationLogCountOutputTypeCountBillingUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillingIrrigationUsageWhereInput
  }

  /**
   * IrrigationLogCountOutputType without action
   */
  export type IrrigationLogCountOutputTypeCountOwnerSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationOwnerSummaryWhereInput
  }

  /**
   * IrrigationLogCountOutputType without action
   */
  export type IrrigationLogCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type IrrigationFieldUsageCountOutputType
   */

  export type IrrigationFieldUsageCountOutputType = {
    ownerUsages: number
  }

  export type IrrigationFieldUsageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerUsages?: boolean | IrrigationFieldUsageCountOutputTypeCountOwnerUsagesArgs
  }

  // Custom InputTypes
  /**
   * IrrigationFieldUsageCountOutputType without action
   */
  export type IrrigationFieldUsageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsageCountOutputType
     */
    select?: IrrigationFieldUsageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IrrigationFieldUsageCountOutputType without action
   */
  export type IrrigationFieldUsageCountOutputTypeCountOwnerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationOwnerUsageWhereInput
  }


  /**
   * Count Type IrrigationInventoryUsageCountOutputType
   */

  export type IrrigationInventoryUsageCountOutputType = {
    ownerUsages: number
  }

  export type IrrigationInventoryUsageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerUsages?: boolean | IrrigationInventoryUsageCountOutputTypeCountOwnerUsagesArgs
  }

  // Custom InputTypes
  /**
   * IrrigationInventoryUsageCountOutputType without action
   */
  export type IrrigationInventoryUsageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsageCountOutputType
     */
    select?: IrrigationInventoryUsageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IrrigationInventoryUsageCountOutputType without action
   */
  export type IrrigationInventoryUsageCountOutputTypeCountOwnerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationInventoryOwnerUsageWhereInput
  }


  /**
   * Count Type WellBillingPeriodCountOutputType
   */

  export type WellBillingPeriodCountOutputType = {
    irrigationUsages: number
    distributions: number
  }

  export type WellBillingPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationUsages?: boolean | WellBillingPeriodCountOutputTypeCountIrrigationUsagesArgs
    distributions?: boolean | WellBillingPeriodCountOutputTypeCountDistributionsArgs
  }

  // Custom InputTypes
  /**
   * WellBillingPeriodCountOutputType without action
   */
  export type WellBillingPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriodCountOutputType
     */
    select?: WellBillingPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WellBillingPeriodCountOutputType without action
   */
  export type WellBillingPeriodCountOutputTypeCountIrrigationUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillingIrrigationUsageWhereInput
  }

  /**
   * WellBillingPeriodCountOutputType without action
   */
  export type WellBillingPeriodCountOutputTypeCountDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillDistributionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    irrigationLogs?: boolean | User$irrigationLogsArgs<ExtArgs>
    ownedFields?: boolean | User$ownedFieldsArgs<ExtArgs>
    assignedFields?: boolean | User$assignedFieldsArgs<ExtArgs>
    inventoryOwnership?: boolean | User$inventoryOwnershipArgs<ExtArgs>
    debtsAsCreditor?: boolean | User$debtsAsCreditorArgs<ExtArgs>
    debtsAsDebtor?: boolean | User$debtsAsDebtorArgs<ExtArgs>
    purchaseContributions?: boolean | User$purchaseContributionsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    inventoryUsages?: boolean | User$inventoryUsagesArgs<ExtArgs>
    processes?: boolean | User$processesArgs<ExtArgs>
    invoicesPurchased?: boolean | User$invoicesPurchasedArgs<ExtArgs>
    paymentsMade?: boolean | User$paymentsMadeArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    inventoryTransactions?: boolean | User$inventoryTransactionsArgs<ExtArgs>
    seasons?: boolean | User$seasonsArgs<ExtArgs>
    purchaseApprovals?: boolean | User$purchaseApprovalsArgs<ExtArgs>
    equipmentOwnerships?: boolean | User$equipmentOwnershipsArgs<ExtArgs>
    equipmentUsages?: boolean | User$equipmentUsagesArgs<ExtArgs>
    fieldOwnerExpenses?: boolean | User$fieldOwnerExpensesArgs<ExtArgs>
    wellAssignments?: boolean | User$wellAssignmentsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    irrigationOwnerUsages?: boolean | User$irrigationOwnerUsagesArgs<ExtArgs>
    irrigationInventoryOwnerUsages?: boolean | User$irrigationInventoryOwnerUsagesArgs<ExtArgs>
    irrigationOwnerSummaries?: boolean | User$irrigationOwnerSummariesArgs<ExtArgs>
    wellBillDistributions?: boolean | User$wellBillDistributionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationLogs?: boolean | User$irrigationLogsArgs<ExtArgs>
    ownedFields?: boolean | User$ownedFieldsArgs<ExtArgs>
    assignedFields?: boolean | User$assignedFieldsArgs<ExtArgs>
    inventoryOwnership?: boolean | User$inventoryOwnershipArgs<ExtArgs>
    debtsAsCreditor?: boolean | User$debtsAsCreditorArgs<ExtArgs>
    debtsAsDebtor?: boolean | User$debtsAsDebtorArgs<ExtArgs>
    purchaseContributions?: boolean | User$purchaseContributionsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    inventoryUsages?: boolean | User$inventoryUsagesArgs<ExtArgs>
    processes?: boolean | User$processesArgs<ExtArgs>
    invoicesPurchased?: boolean | User$invoicesPurchasedArgs<ExtArgs>
    paymentsMade?: boolean | User$paymentsMadeArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    inventoryTransactions?: boolean | User$inventoryTransactionsArgs<ExtArgs>
    seasons?: boolean | User$seasonsArgs<ExtArgs>
    purchaseApprovals?: boolean | User$purchaseApprovalsArgs<ExtArgs>
    equipmentOwnerships?: boolean | User$equipmentOwnershipsArgs<ExtArgs>
    equipmentUsages?: boolean | User$equipmentUsagesArgs<ExtArgs>
    fieldOwnerExpenses?: boolean | User$fieldOwnerExpensesArgs<ExtArgs>
    wellAssignments?: boolean | User$wellAssignmentsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    irrigationOwnerUsages?: boolean | User$irrigationOwnerUsagesArgs<ExtArgs>
    irrigationInventoryOwnerUsages?: boolean | User$irrigationInventoryOwnerUsagesArgs<ExtArgs>
    irrigationOwnerSummaries?: boolean | User$irrigationOwnerSummariesArgs<ExtArgs>
    wellBillDistributions?: boolean | User$wellBillDistributionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      irrigationLogs: Prisma.$IrrigationLogPayload<ExtArgs>[]
      ownedFields: Prisma.$FieldOwnershipPayload<ExtArgs>[]
      assignedFields: Prisma.$FieldWorkerAssignmentPayload<ExtArgs>[]
      inventoryOwnership: Prisma.$InventoryOwnershipPayload<ExtArgs>[]
      debtsAsCreditor: Prisma.$DebtPayload<ExtArgs>[]
      debtsAsDebtor: Prisma.$DebtPayload<ExtArgs>[]
      purchaseContributions: Prisma.$PurchaseContributorPayload<ExtArgs>[]
      receivedNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      inventoryUsages: Prisma.$InventoryUsagePayload<ExtArgs>[]
      processes: Prisma.$ProcessPayload<ExtArgs>[]
      invoicesPurchased: Prisma.$InvoicePayload<ExtArgs>[]
      paymentsMade: Prisma.$PaymentHistoryPayload<ExtArgs>[]
      paymentsReceived: Prisma.$PaymentHistoryPayload<ExtArgs>[]
      inventoryTransactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      seasons: Prisma.$SeasonPayload<ExtArgs>[]
      purchaseApprovals: Prisma.$PurchaseApprovalPayload<ExtArgs>[]
      equipmentOwnerships: Prisma.$EquipmentOwnershipPayload<ExtArgs>[]
      equipmentUsages: Prisma.$EquipmentUsagePayload<ExtArgs>[]
      fieldOwnerExpenses: Prisma.$FieldOwnerExpensePayload<ExtArgs>[]
      wellAssignments: Prisma.$WorkerWellAssignmentPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      irrigationOwnerUsages: Prisma.$IrrigationOwnerUsagePayload<ExtArgs>[]
      irrigationInventoryOwnerUsages: Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>[]
      irrigationOwnerSummaries: Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>[]
      wellBillDistributions: Prisma.$WellBillDistributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    irrigationLogs<T extends User$irrigationLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$irrigationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedFields<T extends User$ownedFieldsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedFields<T extends User$assignedFieldsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryOwnership<T extends User$inventoryOwnershipArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryOwnershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debtsAsCreditor<T extends User$debtsAsCreditorArgs<ExtArgs> = {}>(args?: Subset<T, User$debtsAsCreditorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debtsAsDebtor<T extends User$debtsAsDebtorArgs<ExtArgs> = {}>(args?: Subset<T, User$debtsAsDebtorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseContributions<T extends User$purchaseContributionsArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseContributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedNotifications<T extends User$receivedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryUsages<T extends User$inventoryUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processes<T extends User$processesArgs<ExtArgs> = {}>(args?: Subset<T, User$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoicesPurchased<T extends User$invoicesPurchasedArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesPurchasedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsMade<T extends User$paymentsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsReceived<T extends User$paymentsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryTransactions<T extends User$inventoryTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seasons<T extends User$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, User$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseApprovals<T extends User$purchaseApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentOwnerships<T extends User$equipmentOwnershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$equipmentOwnershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentUsages<T extends User$equipmentUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$equipmentUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fieldOwnerExpenses<T extends User$fieldOwnerExpensesArgs<ExtArgs> = {}>(args?: Subset<T, User$fieldOwnerExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellAssignments<T extends User$wellAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$wellAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreferences<T extends User$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferencesArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    irrigationOwnerUsages<T extends User$irrigationOwnerUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$irrigationOwnerUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    irrigationInventoryOwnerUsages<T extends User$irrigationInventoryOwnerUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$irrigationInventoryOwnerUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    irrigationOwnerSummaries<T extends User$irrigationOwnerSummariesArgs<ExtArgs> = {}>(args?: Subset<T, User$irrigationOwnerSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellBillDistributions<T extends User$wellBillDistributionsArgs<ExtArgs> = {}>(args?: Subset<T, User$wellBillDistributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'Status'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.irrigationLogs
   */
  export type User$irrigationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    where?: IrrigationLogWhereInput
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    cursor?: IrrigationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationLogScalarFieldEnum | IrrigationLogScalarFieldEnum[]
  }

  /**
   * User.ownedFields
   */
  export type User$ownedFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    where?: FieldOwnershipWhereInput
    orderBy?: FieldOwnershipOrderByWithRelationInput | FieldOwnershipOrderByWithRelationInput[]
    cursor?: FieldOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldOwnershipScalarFieldEnum | FieldOwnershipScalarFieldEnum[]
  }

  /**
   * User.assignedFields
   */
  export type User$assignedFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    where?: FieldWorkerAssignmentWhereInput
    orderBy?: FieldWorkerAssignmentOrderByWithRelationInput | FieldWorkerAssignmentOrderByWithRelationInput[]
    cursor?: FieldWorkerAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldWorkerAssignmentScalarFieldEnum | FieldWorkerAssignmentScalarFieldEnum[]
  }

  /**
   * User.inventoryOwnership
   */
  export type User$inventoryOwnershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    where?: InventoryOwnershipWhereInput
    orderBy?: InventoryOwnershipOrderByWithRelationInput | InventoryOwnershipOrderByWithRelationInput[]
    cursor?: InventoryOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryOwnershipScalarFieldEnum | InventoryOwnershipScalarFieldEnum[]
  }

  /**
   * User.debtsAsCreditor
   */
  export type User$debtsAsCreditorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    cursor?: DebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * User.debtsAsDebtor
   */
  export type User$debtsAsDebtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    cursor?: DebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * User.purchaseContributions
   */
  export type User$purchaseContributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    where?: PurchaseContributorWhereInput
    orderBy?: PurchaseContributorOrderByWithRelationInput | PurchaseContributorOrderByWithRelationInput[]
    cursor?: PurchaseContributorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseContributorScalarFieldEnum | PurchaseContributorScalarFieldEnum[]
  }

  /**
   * User.receivedNotifications
   */
  export type User$receivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.inventoryUsages
   */
  export type User$inventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    cursor?: InventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * User.processes
   */
  export type User$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * User.invoicesPurchased
   */
  export type User$invoicesPurchasedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.paymentsMade
   */
  export type User$paymentsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    where?: PaymentHistoryWhereInput
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    cursor?: PaymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * User.paymentsReceived
   */
  export type User$paymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    where?: PaymentHistoryWhereInput
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    cursor?: PaymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * User.inventoryTransactions
   */
  export type User$inventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * User.seasons
   */
  export type User$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    cursor?: SeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * User.purchaseApprovals
   */
  export type User$purchaseApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    where?: PurchaseApprovalWhereInput
    orderBy?: PurchaseApprovalOrderByWithRelationInput | PurchaseApprovalOrderByWithRelationInput[]
    cursor?: PurchaseApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseApprovalScalarFieldEnum | PurchaseApprovalScalarFieldEnum[]
  }

  /**
   * User.equipmentOwnerships
   */
  export type User$equipmentOwnershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    where?: EquipmentOwnershipWhereInput
    orderBy?: EquipmentOwnershipOrderByWithRelationInput | EquipmentOwnershipOrderByWithRelationInput[]
    cursor?: EquipmentOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentOwnershipScalarFieldEnum | EquipmentOwnershipScalarFieldEnum[]
  }

  /**
   * User.equipmentUsages
   */
  export type User$equipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    where?: EquipmentUsageWhereInput
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    cursor?: EquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentUsageScalarFieldEnum | EquipmentUsageScalarFieldEnum[]
  }

  /**
   * User.fieldOwnerExpenses
   */
  export type User$fieldOwnerExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    where?: FieldOwnerExpenseWhereInput
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    cursor?: FieldOwnerExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldOwnerExpenseScalarFieldEnum | FieldOwnerExpenseScalarFieldEnum[]
  }

  /**
   * User.wellAssignments
   */
  export type User$wellAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    where?: WorkerWellAssignmentWhereInput
    orderBy?: WorkerWellAssignmentOrderByWithRelationInput | WorkerWellAssignmentOrderByWithRelationInput[]
    cursor?: WorkerWellAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerWellAssignmentScalarFieldEnum | WorkerWellAssignmentScalarFieldEnum[]
  }

  /**
   * User.notificationPreferences
   */
  export type User$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.irrigationOwnerUsages
   */
  export type User$irrigationOwnerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    where?: IrrigationOwnerUsageWhereInput
    orderBy?: IrrigationOwnerUsageOrderByWithRelationInput | IrrigationOwnerUsageOrderByWithRelationInput[]
    cursor?: IrrigationOwnerUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationOwnerUsageScalarFieldEnum | IrrigationOwnerUsageScalarFieldEnum[]
  }

  /**
   * User.irrigationInventoryOwnerUsages
   */
  export type User$irrigationInventoryOwnerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    where?: IrrigationInventoryOwnerUsageWhereInput
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithRelationInput | IrrigationInventoryOwnerUsageOrderByWithRelationInput[]
    cursor?: IrrigationInventoryOwnerUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationInventoryOwnerUsageScalarFieldEnum | IrrigationInventoryOwnerUsageScalarFieldEnum[]
  }

  /**
   * User.irrigationOwnerSummaries
   */
  export type User$irrigationOwnerSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    where?: IrrigationOwnerSummaryWhereInput
    orderBy?: IrrigationOwnerSummaryOrderByWithRelationInput | IrrigationOwnerSummaryOrderByWithRelationInput[]
    cursor?: IrrigationOwnerSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationOwnerSummaryScalarFieldEnum | IrrigationOwnerSummaryScalarFieldEnum[]
  }

  /**
   * User.wellBillDistributions
   */
  export type User$wellBillDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    where?: WellBillDistributionWhereInput
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    cursor?: WellBillDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    creatorId: number
    _all: number
  }


  export type SeasonMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    creatorId: string
    _count: SeasonCountAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    fields?: boolean | Season$fieldsArgs<ExtArgs>
    crops?: boolean | Season$cropsArgs<ExtArgs>
    purchases?: boolean | Season$purchasesArgs<ExtArgs>
    inventoryTransactions?: boolean | Season$inventoryTransactionsArgs<ExtArgs>
    processes?: boolean | Season$processesArgs<ExtArgs>
    irrigationLogs?: boolean | Season$irrigationLogsArgs<ExtArgs>
    fieldExpenses?: boolean | Season$fieldExpensesArgs<ExtArgs>
    notifications?: boolean | Season$notificationsArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>



  export type SeasonSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
  }

  export type SeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "description" | "isActive" | "createdAt" | "updatedAt" | "creatorId", ExtArgs["result"]["season"]>
  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    fields?: boolean | Season$fieldsArgs<ExtArgs>
    crops?: boolean | Season$cropsArgs<ExtArgs>
    purchases?: boolean | Season$purchasesArgs<ExtArgs>
    inventoryTransactions?: boolean | Season$inventoryTransactionsArgs<ExtArgs>
    processes?: boolean | Season$processesArgs<ExtArgs>
    irrigationLogs?: boolean | Season$irrigationLogsArgs<ExtArgs>
    fieldExpenses?: boolean | Season$fieldExpensesArgs<ExtArgs>
    notifications?: boolean | Season$notificationsArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.$FieldPayload<ExtArgs>[]
      crops: Prisma.$CropPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      inventoryTransactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      processes: Prisma.$ProcessPayload<ExtArgs>[]
      irrigationLogs: Prisma.$IrrigationLogPayload<ExtArgs>[]
      fieldExpenses: Prisma.$FieldExpensePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      creatorId: string
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * @param {SeasonFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const season = await prisma.season.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SeasonFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Season.
     * @param {SeasonAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const season = await prisma.season.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SeasonAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fields<T extends Season$fieldsArgs<ExtArgs> = {}>(args?: Subset<T, Season$fieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crops<T extends Season$cropsArgs<ExtArgs> = {}>(args?: Subset<T, Season$cropsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends Season$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Season$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryTransactions<T extends Season$inventoryTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Season$inventoryTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processes<T extends Season$processesArgs<ExtArgs> = {}>(args?: Subset<T, Season$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    irrigationLogs<T extends Season$irrigationLogsArgs<ExtArgs> = {}>(args?: Subset<T, Season$irrigationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fieldExpenses<T extends Season$fieldExpensesArgs<ExtArgs> = {}>(args?: Subset<T, Season$fieldExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Season$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Season$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'String'>
    readonly name: FieldRef<"Season", 'String'>
    readonly startDate: FieldRef<"Season", 'DateTime'>
    readonly endDate: FieldRef<"Season", 'DateTime'>
    readonly description: FieldRef<"Season", 'String'>
    readonly isActive: FieldRef<"Season", 'Boolean'>
    readonly createdAt: FieldRef<"Season", 'DateTime'>
    readonly updatedAt: FieldRef<"Season", 'DateTime'>
    readonly creatorId: FieldRef<"Season", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to delete.
     */
    limit?: number
  }

  /**
   * Season findRaw
   */
  export type SeasonFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Season aggregateRaw
   */
  export type SeasonAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Season.fields
   */
  export type Season$fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    cursor?: FieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Season.crops
   */
  export type Season$cropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    where?: CropWhereInput
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    cursor?: CropWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Season.purchases
   */
  export type Season$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Season.inventoryTransactions
   */
  export type Season$inventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Season.processes
   */
  export type Season$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Season.irrigationLogs
   */
  export type Season$irrigationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    where?: IrrigationLogWhereInput
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    cursor?: IrrigationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationLogScalarFieldEnum | IrrigationLogScalarFieldEnum[]
  }

  /**
   * Season.fieldExpenses
   */
  export type Season$fieldExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    where?: FieldExpenseWhereInput
    orderBy?: FieldExpenseOrderByWithRelationInput | FieldExpenseOrderByWithRelationInput[]
    cursor?: FieldExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldExpenseScalarFieldEnum | FieldExpenseScalarFieldEnum[]
  }

  /**
   * Season.notifications
   */
  export type Season$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model Field
   */

  export type AggregateField = {
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  export type FieldAvgAggregateOutputType = {
    size: number | null
  }

  export type FieldSumAggregateOutputType = {
    size: number | null
  }

  export type FieldMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    size: number | null
    coordinates: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
  }

  export type FieldMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    size: number | null
    coordinates: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
  }

  export type FieldCountAggregateOutputType = {
    id: number
    name: number
    location: number
    size: number
    coordinates: number
    status: number
    createdAt: number
    updatedAt: number
    seasonId: number
    _all: number
  }


  export type FieldAvgAggregateInputType = {
    size?: true
  }

  export type FieldSumAggregateInputType = {
    size?: true
  }

  export type FieldMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    size?: true
    coordinates?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
  }

  export type FieldMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    size?: true
    coordinates?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
  }

  export type FieldCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    size?: true
    coordinates?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    _all?: true
  }

  export type FieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Field to aggregate.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fields
    **/
    _count?: true | FieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldMaxAggregateInputType
  }

  export type GetFieldAggregateType<T extends FieldAggregateArgs> = {
        [P in keyof T & keyof AggregateField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateField[P]>
      : GetScalarType<T[P], AggregateField[P]>
  }




  export type FieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithAggregationInput | FieldOrderByWithAggregationInput[]
    by: FieldScalarFieldEnum[] | FieldScalarFieldEnum
    having?: FieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldCountAggregateInputType | true
    _avg?: FieldAvgAggregateInputType
    _sum?: FieldSumAggregateInputType
    _min?: FieldMinAggregateInputType
    _max?: FieldMaxAggregateInputType
  }

  export type FieldGroupByOutputType = {
    id: string
    name: string
    location: string
    size: number
    coordinates: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    seasonId: string | null
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  type GetFieldGroupByPayload<T extends FieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldGroupByOutputType[P]>
            : GetScalarType<T[P], FieldGroupByOutputType[P]>
        }
      >
    >


  export type FieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    size?: boolean
    coordinates?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
    season?: boolean | Field$seasonArgs<ExtArgs>
    owners?: boolean | Field$ownersArgs<ExtArgs>
    workerAssignments?: boolean | Field$workerAssignmentsArgs<ExtArgs>
    crops?: boolean | Field$cropsArgs<ExtArgs>
    fieldWells?: boolean | Field$fieldWellsArgs<ExtArgs>
    processingLogs?: boolean | Field$processingLogsArgs<ExtArgs>
    processCosts?: boolean | Field$processCostsArgs<ExtArgs>
    inventoryUsages?: boolean | Field$inventoryUsagesArgs<ExtArgs>
    processes?: boolean | Field$processesArgs<ExtArgs>
    fieldExpenses?: boolean | Field$fieldExpensesArgs<ExtArgs>
    notifications?: boolean | Field$notificationsArgs<ExtArgs>
    irrigationFieldUsages?: boolean | Field$irrigationFieldUsagesArgs<ExtArgs>
    wellBillDistributions?: boolean | Field$wellBillDistributionsArgs<ExtArgs>
    _count?: boolean | FieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>



  export type FieldSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    size?: boolean
    coordinates?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
  }

  export type FieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "size" | "coordinates" | "status" | "createdAt" | "updatedAt" | "seasonId", ExtArgs["result"]["field"]>
  export type FieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | Field$seasonArgs<ExtArgs>
    owners?: boolean | Field$ownersArgs<ExtArgs>
    workerAssignments?: boolean | Field$workerAssignmentsArgs<ExtArgs>
    crops?: boolean | Field$cropsArgs<ExtArgs>
    fieldWells?: boolean | Field$fieldWellsArgs<ExtArgs>
    processingLogs?: boolean | Field$processingLogsArgs<ExtArgs>
    processCosts?: boolean | Field$processCostsArgs<ExtArgs>
    inventoryUsages?: boolean | Field$inventoryUsagesArgs<ExtArgs>
    processes?: boolean | Field$processesArgs<ExtArgs>
    fieldExpenses?: boolean | Field$fieldExpensesArgs<ExtArgs>
    notifications?: boolean | Field$notificationsArgs<ExtArgs>
    irrigationFieldUsages?: boolean | Field$irrigationFieldUsagesArgs<ExtArgs>
    wellBillDistributions?: boolean | Field$wellBillDistributionsArgs<ExtArgs>
    _count?: boolean | FieldCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Field"
    objects: {
      season: Prisma.$SeasonPayload<ExtArgs> | null
      owners: Prisma.$FieldOwnershipPayload<ExtArgs>[]
      workerAssignments: Prisma.$FieldWorkerAssignmentPayload<ExtArgs>[]
      crops: Prisma.$CropPayload<ExtArgs>[]
      fieldWells: Prisma.$FieldWellPayload<ExtArgs>[]
      processingLogs: Prisma.$ProcessingLogPayload<ExtArgs>[]
      processCosts: Prisma.$ProcessCostPayload<ExtArgs>[]
      inventoryUsages: Prisma.$InventoryUsagePayload<ExtArgs>[]
      processes: Prisma.$ProcessPayload<ExtArgs>[]
      fieldExpenses: Prisma.$FieldExpensePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      irrigationFieldUsages: Prisma.$IrrigationFieldUsagePayload<ExtArgs>[]
      wellBillDistributions: Prisma.$WellBillDistributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      size: number
      coordinates: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      seasonId: string | null
    }, ExtArgs["result"]["field"]>
    composites: {}
  }

  type FieldGetPayload<S extends boolean | null | undefined | FieldDefaultArgs> = $Result.GetResult<Prisma.$FieldPayload, S>

  type FieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldCountAggregateInputType | true
    }

  export interface FieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Field'], meta: { name: 'Field' } }
    /**
     * Find zero or one Field that matches the filter.
     * @param {FieldFindUniqueArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldFindUniqueArgs>(args: SelectSubset<T, FieldFindUniqueArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Field that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldFindUniqueOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Field that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldFindFirstArgs>(args?: SelectSubset<T, FieldFindFirstArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Field that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.field.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWithIdOnly = await prisma.field.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldFindManyArgs>(args?: SelectSubset<T, FieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Field.
     * @param {FieldCreateArgs} args - Arguments to create a Field.
     * @example
     * // Create one Field
     * const Field = await prisma.field.create({
     *   data: {
     *     // ... data to create a Field
     *   }
     * })
     * 
     */
    create<T extends FieldCreateArgs>(args: SelectSubset<T, FieldCreateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fields.
     * @param {FieldCreateManyArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldCreateManyArgs>(args?: SelectSubset<T, FieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Field.
     * @param {FieldDeleteArgs} args - Arguments to delete one Field.
     * @example
     * // Delete one Field
     * const Field = await prisma.field.delete({
     *   where: {
     *     // ... filter to delete one Field
     *   }
     * })
     * 
     */
    delete<T extends FieldDeleteArgs>(args: SelectSubset<T, FieldDeleteArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Field.
     * @param {FieldUpdateArgs} args - Arguments to update one Field.
     * @example
     * // Update one Field
     * const field = await prisma.field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldUpdateArgs>(args: SelectSubset<T, FieldUpdateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fields.
     * @param {FieldDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldDeleteManyArgs>(args?: SelectSubset<T, FieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldUpdateManyArgs>(args: SelectSubset<T, FieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Field.
     * @param {FieldUpsertArgs} args - Arguments to update or create a Field.
     * @example
     * // Update or create a Field
     * const field = await prisma.field.upsert({
     *   create: {
     *     // ... data to create a Field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Field we want to update
     *   }
     * })
     */
    upsert<T extends FieldUpsertArgs>(args: SelectSubset<T, FieldUpsertArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fields that matches the filter.
     * @param {FieldFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const field = await prisma.field.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Field.
     * @param {FieldAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const field = await prisma.field.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldCountArgs} args - Arguments to filter Fields to count.
     * @example
     * // Count the number of Fields
     * const count = await prisma.field.count({
     *   where: {
     *     // ... the filter for the Fields we want to count
     *   }
     * })
    **/
    count<T extends FieldCountArgs>(
      args?: Subset<T, FieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldAggregateArgs>(args: Subset<T, FieldAggregateArgs>): Prisma.PrismaPromise<GetFieldAggregateType<T>>

    /**
     * Group by Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldGroupByArgs['orderBy'] }
        : { orderBy?: FieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Field model
   */
  readonly fields: FieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    season<T extends Field$seasonArgs<ExtArgs> = {}>(args?: Subset<T, Field$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owners<T extends Field$ownersArgs<ExtArgs> = {}>(args?: Subset<T, Field$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerAssignments<T extends Field$workerAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Field$workerAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crops<T extends Field$cropsArgs<ExtArgs> = {}>(args?: Subset<T, Field$cropsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fieldWells<T extends Field$fieldWellsArgs<ExtArgs> = {}>(args?: Subset<T, Field$fieldWellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processingLogs<T extends Field$processingLogsArgs<ExtArgs> = {}>(args?: Subset<T, Field$processingLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processCosts<T extends Field$processCostsArgs<ExtArgs> = {}>(args?: Subset<T, Field$processCostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryUsages<T extends Field$inventoryUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Field$inventoryUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processes<T extends Field$processesArgs<ExtArgs> = {}>(args?: Subset<T, Field$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fieldExpenses<T extends Field$fieldExpensesArgs<ExtArgs> = {}>(args?: Subset<T, Field$fieldExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Field$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Field$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    irrigationFieldUsages<T extends Field$irrigationFieldUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Field$irrigationFieldUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellBillDistributions<T extends Field$wellBillDistributionsArgs<ExtArgs> = {}>(args?: Subset<T, Field$wellBillDistributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Field model
   */
  interface FieldFieldRefs {
    readonly id: FieldRef<"Field", 'String'>
    readonly name: FieldRef<"Field", 'String'>
    readonly location: FieldRef<"Field", 'String'>
    readonly size: FieldRef<"Field", 'Float'>
    readonly coordinates: FieldRef<"Field", 'String'>
    readonly status: FieldRef<"Field", 'String'>
    readonly createdAt: FieldRef<"Field", 'DateTime'>
    readonly updatedAt: FieldRef<"Field", 'DateTime'>
    readonly seasonId: FieldRef<"Field", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Field findUnique
   */
  export type FieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findUniqueOrThrow
   */
  export type FieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findFirst
   */
  export type FieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findFirstOrThrow
   */
  export type FieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findMany
   */
  export type FieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Fields to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field create
   */
  export type FieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to create a Field.
     */
    data: XOR<FieldCreateInput, FieldUncheckedCreateInput>
  }

  /**
   * Field createMany
   */
  export type FieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
  }

  /**
   * Field update
   */
  export type FieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to update a Field.
     */
    data: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
    /**
     * Choose, which Field to update.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field updateMany
   */
  export type FieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
  }

  /**
   * Field upsert
   */
  export type FieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The filter to search for the Field to update in case it exists.
     */
    where: FieldWhereUniqueInput
    /**
     * In case the Field found by the `where` argument doesn't exist, create a new Field with this data.
     */
    create: XOR<FieldCreateInput, FieldUncheckedCreateInput>
    /**
     * In case the Field was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
  }

  /**
   * Field delete
   */
  export type FieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter which Field to delete.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field deleteMany
   */
  export type FieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fields to delete
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to delete.
     */
    limit?: number
  }

  /**
   * Field findRaw
   */
  export type FieldFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Field aggregateRaw
   */
  export type FieldAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Field.season
   */
  export type Field$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * Field.owners
   */
  export type Field$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    where?: FieldOwnershipWhereInput
    orderBy?: FieldOwnershipOrderByWithRelationInput | FieldOwnershipOrderByWithRelationInput[]
    cursor?: FieldOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldOwnershipScalarFieldEnum | FieldOwnershipScalarFieldEnum[]
  }

  /**
   * Field.workerAssignments
   */
  export type Field$workerAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    where?: FieldWorkerAssignmentWhereInput
    orderBy?: FieldWorkerAssignmentOrderByWithRelationInput | FieldWorkerAssignmentOrderByWithRelationInput[]
    cursor?: FieldWorkerAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldWorkerAssignmentScalarFieldEnum | FieldWorkerAssignmentScalarFieldEnum[]
  }

  /**
   * Field.crops
   */
  export type Field$cropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    where?: CropWhereInput
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    cursor?: CropWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Field.fieldWells
   */
  export type Field$fieldWellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    where?: FieldWellWhereInput
    orderBy?: FieldWellOrderByWithRelationInput | FieldWellOrderByWithRelationInput[]
    cursor?: FieldWellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldWellScalarFieldEnum | FieldWellScalarFieldEnum[]
  }

  /**
   * Field.processingLogs
   */
  export type Field$processingLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    where?: ProcessingLogWhereInput
    orderBy?: ProcessingLogOrderByWithRelationInput | ProcessingLogOrderByWithRelationInput[]
    cursor?: ProcessingLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessingLogScalarFieldEnum | ProcessingLogScalarFieldEnum[]
  }

  /**
   * Field.processCosts
   */
  export type Field$processCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    where?: ProcessCostWhereInput
    orderBy?: ProcessCostOrderByWithRelationInput | ProcessCostOrderByWithRelationInput[]
    cursor?: ProcessCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessCostScalarFieldEnum | ProcessCostScalarFieldEnum[]
  }

  /**
   * Field.inventoryUsages
   */
  export type Field$inventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    cursor?: InventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * Field.processes
   */
  export type Field$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Field.fieldExpenses
   */
  export type Field$fieldExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    where?: FieldExpenseWhereInput
    orderBy?: FieldExpenseOrderByWithRelationInput | FieldExpenseOrderByWithRelationInput[]
    cursor?: FieldExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldExpenseScalarFieldEnum | FieldExpenseScalarFieldEnum[]
  }

  /**
   * Field.notifications
   */
  export type Field$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Field.irrigationFieldUsages
   */
  export type Field$irrigationFieldUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    where?: IrrigationFieldUsageWhereInput
    orderBy?: IrrigationFieldUsageOrderByWithRelationInput | IrrigationFieldUsageOrderByWithRelationInput[]
    cursor?: IrrigationFieldUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationFieldUsageScalarFieldEnum | IrrigationFieldUsageScalarFieldEnum[]
  }

  /**
   * Field.wellBillDistributions
   */
  export type Field$wellBillDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    where?: WellBillDistributionWhereInput
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    cursor?: WellBillDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * Field without action
   */
  export type FieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
  }


  /**
   * Model FieldOwnership
   */

  export type AggregateFieldOwnership = {
    _count: FieldOwnershipCountAggregateOutputType | null
    _avg: FieldOwnershipAvgAggregateOutputType | null
    _sum: FieldOwnershipSumAggregateOutputType | null
    _min: FieldOwnershipMinAggregateOutputType | null
    _max: FieldOwnershipMaxAggregateOutputType | null
  }

  export type FieldOwnershipAvgAggregateOutputType = {
    percentage: number | null
  }

  export type FieldOwnershipSumAggregateOutputType = {
    percentage: number | null
  }

  export type FieldOwnershipMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    percentage: number | null
    fieldId: string | null
    userId: string | null
  }

  export type FieldOwnershipMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    percentage: number | null
    fieldId: string | null
    userId: string | null
  }

  export type FieldOwnershipCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    percentage: number
    fieldId: number
    userId: number
    _all: number
  }


  export type FieldOwnershipAvgAggregateInputType = {
    percentage?: true
  }

  export type FieldOwnershipSumAggregateInputType = {
    percentage?: true
  }

  export type FieldOwnershipMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    percentage?: true
    fieldId?: true
    userId?: true
  }

  export type FieldOwnershipMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    percentage?: true
    fieldId?: true
    userId?: true
  }

  export type FieldOwnershipCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    percentage?: true
    fieldId?: true
    userId?: true
    _all?: true
  }

  export type FieldOwnershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOwnership to aggregate.
     */
    where?: FieldOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerships to fetch.
     */
    orderBy?: FieldOwnershipOrderByWithRelationInput | FieldOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldOwnerships
    **/
    _count?: true | FieldOwnershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldOwnershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldOwnershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldOwnershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldOwnershipMaxAggregateInputType
  }

  export type GetFieldOwnershipAggregateType<T extends FieldOwnershipAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldOwnership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldOwnership[P]>
      : GetScalarType<T[P], AggregateFieldOwnership[P]>
  }




  export type FieldOwnershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnershipWhereInput
    orderBy?: FieldOwnershipOrderByWithAggregationInput | FieldOwnershipOrderByWithAggregationInput[]
    by: FieldOwnershipScalarFieldEnum[] | FieldOwnershipScalarFieldEnum
    having?: FieldOwnershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldOwnershipCountAggregateInputType | true
    _avg?: FieldOwnershipAvgAggregateInputType
    _sum?: FieldOwnershipSumAggregateInputType
    _min?: FieldOwnershipMinAggregateInputType
    _max?: FieldOwnershipMaxAggregateInputType
  }

  export type FieldOwnershipGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    percentage: number
    fieldId: string
    userId: string
    _count: FieldOwnershipCountAggregateOutputType | null
    _avg: FieldOwnershipAvgAggregateOutputType | null
    _sum: FieldOwnershipSumAggregateOutputType | null
    _min: FieldOwnershipMinAggregateOutputType | null
    _max: FieldOwnershipMaxAggregateOutputType | null
  }

  type GetFieldOwnershipGroupByPayload<T extends FieldOwnershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldOwnershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldOwnershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldOwnershipGroupByOutputType[P]>
            : GetScalarType<T[P], FieldOwnershipGroupByOutputType[P]>
        }
      >
    >


  export type FieldOwnershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    percentage?: boolean
    fieldId?: boolean
    userId?: boolean
    field?: boolean | FieldDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    ownerExpenses?: boolean | FieldOwnership$ownerExpensesArgs<ExtArgs>
    _count?: boolean | FieldOwnershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldOwnership"]>



  export type FieldOwnershipSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    percentage?: boolean
    fieldId?: boolean
    userId?: boolean
  }

  export type FieldOwnershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "percentage" | "fieldId" | "userId", ExtArgs["result"]["fieldOwnership"]>
  export type FieldOwnershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | FieldDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    ownerExpenses?: boolean | FieldOwnership$ownerExpensesArgs<ExtArgs>
    _count?: boolean | FieldOwnershipCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FieldOwnershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldOwnership"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      ownerExpenses: Prisma.$FieldOwnerExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      percentage: number
      fieldId: string
      userId: string
    }, ExtArgs["result"]["fieldOwnership"]>
    composites: {}
  }

  type FieldOwnershipGetPayload<S extends boolean | null | undefined | FieldOwnershipDefaultArgs> = $Result.GetResult<Prisma.$FieldOwnershipPayload, S>

  type FieldOwnershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldOwnershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldOwnershipCountAggregateInputType | true
    }

  export interface FieldOwnershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldOwnership'], meta: { name: 'FieldOwnership' } }
    /**
     * Find zero or one FieldOwnership that matches the filter.
     * @param {FieldOwnershipFindUniqueArgs} args - Arguments to find a FieldOwnership
     * @example
     * // Get one FieldOwnership
     * const fieldOwnership = await prisma.fieldOwnership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldOwnershipFindUniqueArgs>(args: SelectSubset<T, FieldOwnershipFindUniqueArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldOwnership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldOwnershipFindUniqueOrThrowArgs} args - Arguments to find a FieldOwnership
     * @example
     * // Get one FieldOwnership
     * const fieldOwnership = await prisma.fieldOwnership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldOwnershipFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldOwnershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOwnership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipFindFirstArgs} args - Arguments to find a FieldOwnership
     * @example
     * // Get one FieldOwnership
     * const fieldOwnership = await prisma.fieldOwnership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldOwnershipFindFirstArgs>(args?: SelectSubset<T, FieldOwnershipFindFirstArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOwnership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipFindFirstOrThrowArgs} args - Arguments to find a FieldOwnership
     * @example
     * // Get one FieldOwnership
     * const fieldOwnership = await prisma.fieldOwnership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldOwnershipFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldOwnershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldOwnerships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldOwnerships
     * const fieldOwnerships = await prisma.fieldOwnership.findMany()
     * 
     * // Get first 10 FieldOwnerships
     * const fieldOwnerships = await prisma.fieldOwnership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldOwnershipWithIdOnly = await prisma.fieldOwnership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldOwnershipFindManyArgs>(args?: SelectSubset<T, FieldOwnershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldOwnership.
     * @param {FieldOwnershipCreateArgs} args - Arguments to create a FieldOwnership.
     * @example
     * // Create one FieldOwnership
     * const FieldOwnership = await prisma.fieldOwnership.create({
     *   data: {
     *     // ... data to create a FieldOwnership
     *   }
     * })
     * 
     */
    create<T extends FieldOwnershipCreateArgs>(args: SelectSubset<T, FieldOwnershipCreateArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldOwnerships.
     * @param {FieldOwnershipCreateManyArgs} args - Arguments to create many FieldOwnerships.
     * @example
     * // Create many FieldOwnerships
     * const fieldOwnership = await prisma.fieldOwnership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldOwnershipCreateManyArgs>(args?: SelectSubset<T, FieldOwnershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldOwnership.
     * @param {FieldOwnershipDeleteArgs} args - Arguments to delete one FieldOwnership.
     * @example
     * // Delete one FieldOwnership
     * const FieldOwnership = await prisma.fieldOwnership.delete({
     *   where: {
     *     // ... filter to delete one FieldOwnership
     *   }
     * })
     * 
     */
    delete<T extends FieldOwnershipDeleteArgs>(args: SelectSubset<T, FieldOwnershipDeleteArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldOwnership.
     * @param {FieldOwnershipUpdateArgs} args - Arguments to update one FieldOwnership.
     * @example
     * // Update one FieldOwnership
     * const fieldOwnership = await prisma.fieldOwnership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldOwnershipUpdateArgs>(args: SelectSubset<T, FieldOwnershipUpdateArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldOwnerships.
     * @param {FieldOwnershipDeleteManyArgs} args - Arguments to filter FieldOwnerships to delete.
     * @example
     * // Delete a few FieldOwnerships
     * const { count } = await prisma.fieldOwnership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldOwnershipDeleteManyArgs>(args?: SelectSubset<T, FieldOwnershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldOwnerships
     * const fieldOwnership = await prisma.fieldOwnership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldOwnershipUpdateManyArgs>(args: SelectSubset<T, FieldOwnershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldOwnership.
     * @param {FieldOwnershipUpsertArgs} args - Arguments to update or create a FieldOwnership.
     * @example
     * // Update or create a FieldOwnership
     * const fieldOwnership = await prisma.fieldOwnership.upsert({
     *   create: {
     *     // ... data to create a FieldOwnership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldOwnership we want to update
     *   }
     * })
     */
    upsert<T extends FieldOwnershipUpsertArgs>(args: SelectSubset<T, FieldOwnershipUpsertArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldOwnerships that matches the filter.
     * @param {FieldOwnershipFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fieldOwnership = await prisma.fieldOwnership.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldOwnershipFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FieldOwnership.
     * @param {FieldOwnershipAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fieldOwnership = await prisma.fieldOwnership.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldOwnershipAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FieldOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipCountArgs} args - Arguments to filter FieldOwnerships to count.
     * @example
     * // Count the number of FieldOwnerships
     * const count = await prisma.fieldOwnership.count({
     *   where: {
     *     // ... the filter for the FieldOwnerships we want to count
     *   }
     * })
    **/
    count<T extends FieldOwnershipCountArgs>(
      args?: Subset<T, FieldOwnershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldOwnershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldOwnershipAggregateArgs>(args: Subset<T, FieldOwnershipAggregateArgs>): Prisma.PrismaPromise<GetFieldOwnershipAggregateType<T>>

    /**
     * Group by FieldOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldOwnershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldOwnershipGroupByArgs['orderBy'] }
        : { orderBy?: FieldOwnershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldOwnershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldOwnershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldOwnership model
   */
  readonly fields: FieldOwnershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldOwnership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldOwnershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ownerExpenses<T extends FieldOwnership$ownerExpensesArgs<ExtArgs> = {}>(args?: Subset<T, FieldOwnership$ownerExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldOwnership model
   */
  interface FieldOwnershipFieldRefs {
    readonly id: FieldRef<"FieldOwnership", 'String'>
    readonly createdAt: FieldRef<"FieldOwnership", 'DateTime'>
    readonly updatedAt: FieldRef<"FieldOwnership", 'DateTime'>
    readonly percentage: FieldRef<"FieldOwnership", 'Float'>
    readonly fieldId: FieldRef<"FieldOwnership", 'String'>
    readonly userId: FieldRef<"FieldOwnership", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldOwnership findUnique
   */
  export type FieldOwnershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnership to fetch.
     */
    where: FieldOwnershipWhereUniqueInput
  }

  /**
   * FieldOwnership findUniqueOrThrow
   */
  export type FieldOwnershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnership to fetch.
     */
    where: FieldOwnershipWhereUniqueInput
  }

  /**
   * FieldOwnership findFirst
   */
  export type FieldOwnershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnership to fetch.
     */
    where?: FieldOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerships to fetch.
     */
    orderBy?: FieldOwnershipOrderByWithRelationInput | FieldOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOwnerships.
     */
    cursor?: FieldOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOwnerships.
     */
    distinct?: FieldOwnershipScalarFieldEnum | FieldOwnershipScalarFieldEnum[]
  }

  /**
   * FieldOwnership findFirstOrThrow
   */
  export type FieldOwnershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnership to fetch.
     */
    where?: FieldOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerships to fetch.
     */
    orderBy?: FieldOwnershipOrderByWithRelationInput | FieldOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOwnerships.
     */
    cursor?: FieldOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOwnerships.
     */
    distinct?: FieldOwnershipScalarFieldEnum | FieldOwnershipScalarFieldEnum[]
  }

  /**
   * FieldOwnership findMany
   */
  export type FieldOwnershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnerships to fetch.
     */
    where?: FieldOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerships to fetch.
     */
    orderBy?: FieldOwnershipOrderByWithRelationInput | FieldOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldOwnerships.
     */
    cursor?: FieldOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerships.
     */
    skip?: number
    distinct?: FieldOwnershipScalarFieldEnum | FieldOwnershipScalarFieldEnum[]
  }

  /**
   * FieldOwnership create
   */
  export type FieldOwnershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldOwnership.
     */
    data: XOR<FieldOwnershipCreateInput, FieldOwnershipUncheckedCreateInput>
  }

  /**
   * FieldOwnership createMany
   */
  export type FieldOwnershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldOwnerships.
     */
    data: FieldOwnershipCreateManyInput | FieldOwnershipCreateManyInput[]
  }

  /**
   * FieldOwnership update
   */
  export type FieldOwnershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldOwnership.
     */
    data: XOR<FieldOwnershipUpdateInput, FieldOwnershipUncheckedUpdateInput>
    /**
     * Choose, which FieldOwnership to update.
     */
    where: FieldOwnershipWhereUniqueInput
  }

  /**
   * FieldOwnership updateMany
   */
  export type FieldOwnershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldOwnerships.
     */
    data: XOR<FieldOwnershipUpdateManyMutationInput, FieldOwnershipUncheckedUpdateManyInput>
    /**
     * Filter which FieldOwnerships to update
     */
    where?: FieldOwnershipWhereInput
    /**
     * Limit how many FieldOwnerships to update.
     */
    limit?: number
  }

  /**
   * FieldOwnership upsert
   */
  export type FieldOwnershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldOwnership to update in case it exists.
     */
    where: FieldOwnershipWhereUniqueInput
    /**
     * In case the FieldOwnership found by the `where` argument doesn't exist, create a new FieldOwnership with this data.
     */
    create: XOR<FieldOwnershipCreateInput, FieldOwnershipUncheckedCreateInput>
    /**
     * In case the FieldOwnership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldOwnershipUpdateInput, FieldOwnershipUncheckedUpdateInput>
  }

  /**
   * FieldOwnership delete
   */
  export type FieldOwnershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
    /**
     * Filter which FieldOwnership to delete.
     */
    where: FieldOwnershipWhereUniqueInput
  }

  /**
   * FieldOwnership deleteMany
   */
  export type FieldOwnershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOwnerships to delete
     */
    where?: FieldOwnershipWhereInput
    /**
     * Limit how many FieldOwnerships to delete.
     */
    limit?: number
  }

  /**
   * FieldOwnership findRaw
   */
  export type FieldOwnershipFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldOwnership aggregateRaw
   */
  export type FieldOwnershipAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldOwnership.ownerExpenses
   */
  export type FieldOwnership$ownerExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    where?: FieldOwnerExpenseWhereInput
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    cursor?: FieldOwnerExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldOwnerExpenseScalarFieldEnum | FieldOwnerExpenseScalarFieldEnum[]
  }

  /**
   * FieldOwnership without action
   */
  export type FieldOwnershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnership
     */
    select?: FieldOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnership
     */
    omit?: FieldOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnershipInclude<ExtArgs> | null
  }


  /**
   * Model FieldWorkerAssignment
   */

  export type AggregateFieldWorkerAssignment = {
    _count: FieldWorkerAssignmentCountAggregateOutputType | null
    _min: FieldWorkerAssignmentMinAggregateOutputType | null
    _max: FieldWorkerAssignmentMaxAggregateOutputType | null
  }

  export type FieldWorkerAssignmentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fieldId: string | null
    userId: string | null
  }

  export type FieldWorkerAssignmentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fieldId: string | null
    userId: string | null
  }

  export type FieldWorkerAssignmentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fieldId: number
    userId: number
    _all: number
  }


  export type FieldWorkerAssignmentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
    userId?: true
  }

  export type FieldWorkerAssignmentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
    userId?: true
  }

  export type FieldWorkerAssignmentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
    userId?: true
    _all?: true
  }

  export type FieldWorkerAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldWorkerAssignment to aggregate.
     */
    where?: FieldWorkerAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWorkerAssignments to fetch.
     */
    orderBy?: FieldWorkerAssignmentOrderByWithRelationInput | FieldWorkerAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWorkerAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWorkerAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWorkerAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldWorkerAssignments
    **/
    _count?: true | FieldWorkerAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldWorkerAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldWorkerAssignmentMaxAggregateInputType
  }

  export type GetFieldWorkerAssignmentAggregateType<T extends FieldWorkerAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldWorkerAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldWorkerAssignment[P]>
      : GetScalarType<T[P], AggregateFieldWorkerAssignment[P]>
  }




  export type FieldWorkerAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWorkerAssignmentWhereInput
    orderBy?: FieldWorkerAssignmentOrderByWithAggregationInput | FieldWorkerAssignmentOrderByWithAggregationInput[]
    by: FieldWorkerAssignmentScalarFieldEnum[] | FieldWorkerAssignmentScalarFieldEnum
    having?: FieldWorkerAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldWorkerAssignmentCountAggregateInputType | true
    _min?: FieldWorkerAssignmentMinAggregateInputType
    _max?: FieldWorkerAssignmentMaxAggregateInputType
  }

  export type FieldWorkerAssignmentGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    fieldId: string
    userId: string
    _count: FieldWorkerAssignmentCountAggregateOutputType | null
    _min: FieldWorkerAssignmentMinAggregateOutputType | null
    _max: FieldWorkerAssignmentMaxAggregateOutputType | null
  }

  type GetFieldWorkerAssignmentGroupByPayload<T extends FieldWorkerAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldWorkerAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldWorkerAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldWorkerAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], FieldWorkerAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type FieldWorkerAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldId?: boolean
    userId?: boolean
    field?: boolean | FieldDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldWorkerAssignment"]>



  export type FieldWorkerAssignmentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldId?: boolean
    userId?: boolean
  }

  export type FieldWorkerAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "fieldId" | "userId", ExtArgs["result"]["fieldWorkerAssignment"]>
  export type FieldWorkerAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | FieldDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FieldWorkerAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldWorkerAssignment"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      fieldId: string
      userId: string
    }, ExtArgs["result"]["fieldWorkerAssignment"]>
    composites: {}
  }

  type FieldWorkerAssignmentGetPayload<S extends boolean | null | undefined | FieldWorkerAssignmentDefaultArgs> = $Result.GetResult<Prisma.$FieldWorkerAssignmentPayload, S>

  type FieldWorkerAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldWorkerAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldWorkerAssignmentCountAggregateInputType | true
    }

  export interface FieldWorkerAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldWorkerAssignment'], meta: { name: 'FieldWorkerAssignment' } }
    /**
     * Find zero or one FieldWorkerAssignment that matches the filter.
     * @param {FieldWorkerAssignmentFindUniqueArgs} args - Arguments to find a FieldWorkerAssignment
     * @example
     * // Get one FieldWorkerAssignment
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldWorkerAssignmentFindUniqueArgs>(args: SelectSubset<T, FieldWorkerAssignmentFindUniqueArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldWorkerAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldWorkerAssignmentFindUniqueOrThrowArgs} args - Arguments to find a FieldWorkerAssignment
     * @example
     * // Get one FieldWorkerAssignment
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldWorkerAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldWorkerAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldWorkerAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentFindFirstArgs} args - Arguments to find a FieldWorkerAssignment
     * @example
     * // Get one FieldWorkerAssignment
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldWorkerAssignmentFindFirstArgs>(args?: SelectSubset<T, FieldWorkerAssignmentFindFirstArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldWorkerAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentFindFirstOrThrowArgs} args - Arguments to find a FieldWorkerAssignment
     * @example
     * // Get one FieldWorkerAssignment
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldWorkerAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldWorkerAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldWorkerAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldWorkerAssignments
     * const fieldWorkerAssignments = await prisma.fieldWorkerAssignment.findMany()
     * 
     * // Get first 10 FieldWorkerAssignments
     * const fieldWorkerAssignments = await prisma.fieldWorkerAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWorkerAssignmentWithIdOnly = await prisma.fieldWorkerAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldWorkerAssignmentFindManyArgs>(args?: SelectSubset<T, FieldWorkerAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldWorkerAssignment.
     * @param {FieldWorkerAssignmentCreateArgs} args - Arguments to create a FieldWorkerAssignment.
     * @example
     * // Create one FieldWorkerAssignment
     * const FieldWorkerAssignment = await prisma.fieldWorkerAssignment.create({
     *   data: {
     *     // ... data to create a FieldWorkerAssignment
     *   }
     * })
     * 
     */
    create<T extends FieldWorkerAssignmentCreateArgs>(args: SelectSubset<T, FieldWorkerAssignmentCreateArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldWorkerAssignments.
     * @param {FieldWorkerAssignmentCreateManyArgs} args - Arguments to create many FieldWorkerAssignments.
     * @example
     * // Create many FieldWorkerAssignments
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldWorkerAssignmentCreateManyArgs>(args?: SelectSubset<T, FieldWorkerAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldWorkerAssignment.
     * @param {FieldWorkerAssignmentDeleteArgs} args - Arguments to delete one FieldWorkerAssignment.
     * @example
     * // Delete one FieldWorkerAssignment
     * const FieldWorkerAssignment = await prisma.fieldWorkerAssignment.delete({
     *   where: {
     *     // ... filter to delete one FieldWorkerAssignment
     *   }
     * })
     * 
     */
    delete<T extends FieldWorkerAssignmentDeleteArgs>(args: SelectSubset<T, FieldWorkerAssignmentDeleteArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldWorkerAssignment.
     * @param {FieldWorkerAssignmentUpdateArgs} args - Arguments to update one FieldWorkerAssignment.
     * @example
     * // Update one FieldWorkerAssignment
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldWorkerAssignmentUpdateArgs>(args: SelectSubset<T, FieldWorkerAssignmentUpdateArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldWorkerAssignments.
     * @param {FieldWorkerAssignmentDeleteManyArgs} args - Arguments to filter FieldWorkerAssignments to delete.
     * @example
     * // Delete a few FieldWorkerAssignments
     * const { count } = await prisma.fieldWorkerAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldWorkerAssignmentDeleteManyArgs>(args?: SelectSubset<T, FieldWorkerAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldWorkerAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldWorkerAssignments
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldWorkerAssignmentUpdateManyArgs>(args: SelectSubset<T, FieldWorkerAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldWorkerAssignment.
     * @param {FieldWorkerAssignmentUpsertArgs} args - Arguments to update or create a FieldWorkerAssignment.
     * @example
     * // Update or create a FieldWorkerAssignment
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.upsert({
     *   create: {
     *     // ... data to create a FieldWorkerAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldWorkerAssignment we want to update
     *   }
     * })
     */
    upsert<T extends FieldWorkerAssignmentUpsertArgs>(args: SelectSubset<T, FieldWorkerAssignmentUpsertArgs<ExtArgs>>): Prisma__FieldWorkerAssignmentClient<$Result.GetResult<Prisma.$FieldWorkerAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldWorkerAssignments that matches the filter.
     * @param {FieldWorkerAssignmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldWorkerAssignmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FieldWorkerAssignment.
     * @param {FieldWorkerAssignmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fieldWorkerAssignment = await prisma.fieldWorkerAssignment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldWorkerAssignmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FieldWorkerAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentCountArgs} args - Arguments to filter FieldWorkerAssignments to count.
     * @example
     * // Count the number of FieldWorkerAssignments
     * const count = await prisma.fieldWorkerAssignment.count({
     *   where: {
     *     // ... the filter for the FieldWorkerAssignments we want to count
     *   }
     * })
    **/
    count<T extends FieldWorkerAssignmentCountArgs>(
      args?: Subset<T, FieldWorkerAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldWorkerAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldWorkerAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldWorkerAssignmentAggregateArgs>(args: Subset<T, FieldWorkerAssignmentAggregateArgs>): Prisma.PrismaPromise<GetFieldWorkerAssignmentAggregateType<T>>

    /**
     * Group by FieldWorkerAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWorkerAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldWorkerAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldWorkerAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: FieldWorkerAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldWorkerAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldWorkerAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldWorkerAssignment model
   */
  readonly fields: FieldWorkerAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldWorkerAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldWorkerAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldWorkerAssignment model
   */
  interface FieldWorkerAssignmentFieldRefs {
    readonly id: FieldRef<"FieldWorkerAssignment", 'String'>
    readonly createdAt: FieldRef<"FieldWorkerAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"FieldWorkerAssignment", 'DateTime'>
    readonly fieldId: FieldRef<"FieldWorkerAssignment", 'String'>
    readonly userId: FieldRef<"FieldWorkerAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldWorkerAssignment findUnique
   */
  export type FieldWorkerAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FieldWorkerAssignment to fetch.
     */
    where: FieldWorkerAssignmentWhereUniqueInput
  }

  /**
   * FieldWorkerAssignment findUniqueOrThrow
   */
  export type FieldWorkerAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FieldWorkerAssignment to fetch.
     */
    where: FieldWorkerAssignmentWhereUniqueInput
  }

  /**
   * FieldWorkerAssignment findFirst
   */
  export type FieldWorkerAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FieldWorkerAssignment to fetch.
     */
    where?: FieldWorkerAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWorkerAssignments to fetch.
     */
    orderBy?: FieldWorkerAssignmentOrderByWithRelationInput | FieldWorkerAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldWorkerAssignments.
     */
    cursor?: FieldWorkerAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWorkerAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWorkerAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldWorkerAssignments.
     */
    distinct?: FieldWorkerAssignmentScalarFieldEnum | FieldWorkerAssignmentScalarFieldEnum[]
  }

  /**
   * FieldWorkerAssignment findFirstOrThrow
   */
  export type FieldWorkerAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FieldWorkerAssignment to fetch.
     */
    where?: FieldWorkerAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWorkerAssignments to fetch.
     */
    orderBy?: FieldWorkerAssignmentOrderByWithRelationInput | FieldWorkerAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldWorkerAssignments.
     */
    cursor?: FieldWorkerAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWorkerAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWorkerAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldWorkerAssignments.
     */
    distinct?: FieldWorkerAssignmentScalarFieldEnum | FieldWorkerAssignmentScalarFieldEnum[]
  }

  /**
   * FieldWorkerAssignment findMany
   */
  export type FieldWorkerAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FieldWorkerAssignments to fetch.
     */
    where?: FieldWorkerAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWorkerAssignments to fetch.
     */
    orderBy?: FieldWorkerAssignmentOrderByWithRelationInput | FieldWorkerAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldWorkerAssignments.
     */
    cursor?: FieldWorkerAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWorkerAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWorkerAssignments.
     */
    skip?: number
    distinct?: FieldWorkerAssignmentScalarFieldEnum | FieldWorkerAssignmentScalarFieldEnum[]
  }

  /**
   * FieldWorkerAssignment create
   */
  export type FieldWorkerAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldWorkerAssignment.
     */
    data: XOR<FieldWorkerAssignmentCreateInput, FieldWorkerAssignmentUncheckedCreateInput>
  }

  /**
   * FieldWorkerAssignment createMany
   */
  export type FieldWorkerAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldWorkerAssignments.
     */
    data: FieldWorkerAssignmentCreateManyInput | FieldWorkerAssignmentCreateManyInput[]
  }

  /**
   * FieldWorkerAssignment update
   */
  export type FieldWorkerAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldWorkerAssignment.
     */
    data: XOR<FieldWorkerAssignmentUpdateInput, FieldWorkerAssignmentUncheckedUpdateInput>
    /**
     * Choose, which FieldWorkerAssignment to update.
     */
    where: FieldWorkerAssignmentWhereUniqueInput
  }

  /**
   * FieldWorkerAssignment updateMany
   */
  export type FieldWorkerAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldWorkerAssignments.
     */
    data: XOR<FieldWorkerAssignmentUpdateManyMutationInput, FieldWorkerAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which FieldWorkerAssignments to update
     */
    where?: FieldWorkerAssignmentWhereInput
    /**
     * Limit how many FieldWorkerAssignments to update.
     */
    limit?: number
  }

  /**
   * FieldWorkerAssignment upsert
   */
  export type FieldWorkerAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldWorkerAssignment to update in case it exists.
     */
    where: FieldWorkerAssignmentWhereUniqueInput
    /**
     * In case the FieldWorkerAssignment found by the `where` argument doesn't exist, create a new FieldWorkerAssignment with this data.
     */
    create: XOR<FieldWorkerAssignmentCreateInput, FieldWorkerAssignmentUncheckedCreateInput>
    /**
     * In case the FieldWorkerAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldWorkerAssignmentUpdateInput, FieldWorkerAssignmentUncheckedUpdateInput>
  }

  /**
   * FieldWorkerAssignment delete
   */
  export type FieldWorkerAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
    /**
     * Filter which FieldWorkerAssignment to delete.
     */
    where: FieldWorkerAssignmentWhereUniqueInput
  }

  /**
   * FieldWorkerAssignment deleteMany
   */
  export type FieldWorkerAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldWorkerAssignments to delete
     */
    where?: FieldWorkerAssignmentWhereInput
    /**
     * Limit how many FieldWorkerAssignments to delete.
     */
    limit?: number
  }

  /**
   * FieldWorkerAssignment findRaw
   */
  export type FieldWorkerAssignmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldWorkerAssignment aggregateRaw
   */
  export type FieldWorkerAssignmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldWorkerAssignment without action
   */
  export type FieldWorkerAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWorkerAssignment
     */
    select?: FieldWorkerAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWorkerAssignment
     */
    omit?: FieldWorkerAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWorkerAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model FieldWell
   */

  export type AggregateFieldWell = {
    _count: FieldWellCountAggregateOutputType | null
    _min: FieldWellMinAggregateOutputType | null
    _max: FieldWellMaxAggregateOutputType | null
  }

  export type FieldWellMinAggregateOutputType = {
    id: string | null
    fieldId: string | null
    wellId: string | null
    createdAt: Date | null
  }

  export type FieldWellMaxAggregateOutputType = {
    id: string | null
    fieldId: string | null
    wellId: string | null
    createdAt: Date | null
  }

  export type FieldWellCountAggregateOutputType = {
    id: number
    fieldId: number
    wellId: number
    createdAt: number
    _all: number
  }


  export type FieldWellMinAggregateInputType = {
    id?: true
    fieldId?: true
    wellId?: true
    createdAt?: true
  }

  export type FieldWellMaxAggregateInputType = {
    id?: true
    fieldId?: true
    wellId?: true
    createdAt?: true
  }

  export type FieldWellCountAggregateInputType = {
    id?: true
    fieldId?: true
    wellId?: true
    createdAt?: true
    _all?: true
  }

  export type FieldWellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldWell to aggregate.
     */
    where?: FieldWellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWells to fetch.
     */
    orderBy?: FieldWellOrderByWithRelationInput | FieldWellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldWells
    **/
    _count?: true | FieldWellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldWellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldWellMaxAggregateInputType
  }

  export type GetFieldWellAggregateType<T extends FieldWellAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldWell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldWell[P]>
      : GetScalarType<T[P], AggregateFieldWell[P]>
  }




  export type FieldWellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWellWhereInput
    orderBy?: FieldWellOrderByWithAggregationInput | FieldWellOrderByWithAggregationInput[]
    by: FieldWellScalarFieldEnum[] | FieldWellScalarFieldEnum
    having?: FieldWellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldWellCountAggregateInputType | true
    _min?: FieldWellMinAggregateInputType
    _max?: FieldWellMaxAggregateInputType
  }

  export type FieldWellGroupByOutputType = {
    id: string
    fieldId: string
    wellId: string
    createdAt: Date
    _count: FieldWellCountAggregateOutputType | null
    _min: FieldWellMinAggregateOutputType | null
    _max: FieldWellMaxAggregateOutputType | null
  }

  type GetFieldWellGroupByPayload<T extends FieldWellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldWellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldWellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldWellGroupByOutputType[P]>
            : GetScalarType<T[P], FieldWellGroupByOutputType[P]>
        }
      >
    >


  export type FieldWellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    wellId?: boolean
    createdAt?: boolean
    field?: boolean | FieldDefaultArgs<ExtArgs>
    well?: boolean | WellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldWell"]>



  export type FieldWellSelectScalar = {
    id?: boolean
    fieldId?: boolean
    wellId?: boolean
    createdAt?: boolean
  }

  export type FieldWellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldId" | "wellId" | "createdAt", ExtArgs["result"]["fieldWell"]>
  export type FieldWellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | FieldDefaultArgs<ExtArgs>
    well?: boolean | WellDefaultArgs<ExtArgs>
  }

  export type $FieldWellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldWell"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs>
      well: Prisma.$WellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldId: string
      wellId: string
      createdAt: Date
    }, ExtArgs["result"]["fieldWell"]>
    composites: {}
  }

  type FieldWellGetPayload<S extends boolean | null | undefined | FieldWellDefaultArgs> = $Result.GetResult<Prisma.$FieldWellPayload, S>

  type FieldWellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldWellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldWellCountAggregateInputType | true
    }

  export interface FieldWellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldWell'], meta: { name: 'FieldWell' } }
    /**
     * Find zero or one FieldWell that matches the filter.
     * @param {FieldWellFindUniqueArgs} args - Arguments to find a FieldWell
     * @example
     * // Get one FieldWell
     * const fieldWell = await prisma.fieldWell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldWellFindUniqueArgs>(args: SelectSubset<T, FieldWellFindUniqueArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldWell that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldWellFindUniqueOrThrowArgs} args - Arguments to find a FieldWell
     * @example
     * // Get one FieldWell
     * const fieldWell = await prisma.fieldWell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldWellFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldWellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldWell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellFindFirstArgs} args - Arguments to find a FieldWell
     * @example
     * // Get one FieldWell
     * const fieldWell = await prisma.fieldWell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldWellFindFirstArgs>(args?: SelectSubset<T, FieldWellFindFirstArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldWell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellFindFirstOrThrowArgs} args - Arguments to find a FieldWell
     * @example
     * // Get one FieldWell
     * const fieldWell = await prisma.fieldWell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldWellFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldWellFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldWells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldWells
     * const fieldWells = await prisma.fieldWell.findMany()
     * 
     * // Get first 10 FieldWells
     * const fieldWells = await prisma.fieldWell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWellWithIdOnly = await prisma.fieldWell.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldWellFindManyArgs>(args?: SelectSubset<T, FieldWellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldWell.
     * @param {FieldWellCreateArgs} args - Arguments to create a FieldWell.
     * @example
     * // Create one FieldWell
     * const FieldWell = await prisma.fieldWell.create({
     *   data: {
     *     // ... data to create a FieldWell
     *   }
     * })
     * 
     */
    create<T extends FieldWellCreateArgs>(args: SelectSubset<T, FieldWellCreateArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldWells.
     * @param {FieldWellCreateManyArgs} args - Arguments to create many FieldWells.
     * @example
     * // Create many FieldWells
     * const fieldWell = await prisma.fieldWell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldWellCreateManyArgs>(args?: SelectSubset<T, FieldWellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldWell.
     * @param {FieldWellDeleteArgs} args - Arguments to delete one FieldWell.
     * @example
     * // Delete one FieldWell
     * const FieldWell = await prisma.fieldWell.delete({
     *   where: {
     *     // ... filter to delete one FieldWell
     *   }
     * })
     * 
     */
    delete<T extends FieldWellDeleteArgs>(args: SelectSubset<T, FieldWellDeleteArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldWell.
     * @param {FieldWellUpdateArgs} args - Arguments to update one FieldWell.
     * @example
     * // Update one FieldWell
     * const fieldWell = await prisma.fieldWell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldWellUpdateArgs>(args: SelectSubset<T, FieldWellUpdateArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldWells.
     * @param {FieldWellDeleteManyArgs} args - Arguments to filter FieldWells to delete.
     * @example
     * // Delete a few FieldWells
     * const { count } = await prisma.fieldWell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldWellDeleteManyArgs>(args?: SelectSubset<T, FieldWellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldWells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldWells
     * const fieldWell = await prisma.fieldWell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldWellUpdateManyArgs>(args: SelectSubset<T, FieldWellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldWell.
     * @param {FieldWellUpsertArgs} args - Arguments to update or create a FieldWell.
     * @example
     * // Update or create a FieldWell
     * const fieldWell = await prisma.fieldWell.upsert({
     *   create: {
     *     // ... data to create a FieldWell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldWell we want to update
     *   }
     * })
     */
    upsert<T extends FieldWellUpsertArgs>(args: SelectSubset<T, FieldWellUpsertArgs<ExtArgs>>): Prisma__FieldWellClient<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldWells that matches the filter.
     * @param {FieldWellFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fieldWell = await prisma.fieldWell.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldWellFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FieldWell.
     * @param {FieldWellAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fieldWell = await prisma.fieldWell.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldWellAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FieldWells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellCountArgs} args - Arguments to filter FieldWells to count.
     * @example
     * // Count the number of FieldWells
     * const count = await prisma.fieldWell.count({
     *   where: {
     *     // ... the filter for the FieldWells we want to count
     *   }
     * })
    **/
    count<T extends FieldWellCountArgs>(
      args?: Subset<T, FieldWellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldWellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldWell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldWellAggregateArgs>(args: Subset<T, FieldWellAggregateArgs>): Prisma.PrismaPromise<GetFieldWellAggregateType<T>>

    /**
     * Group by FieldWell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldWellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldWellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldWellGroupByArgs['orderBy'] }
        : { orderBy?: FieldWellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldWellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldWellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldWell model
   */
  readonly fields: FieldWellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldWell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldWellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    well<T extends WellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellDefaultArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldWell model
   */
  interface FieldWellFieldRefs {
    readonly id: FieldRef<"FieldWell", 'String'>
    readonly fieldId: FieldRef<"FieldWell", 'String'>
    readonly wellId: FieldRef<"FieldWell", 'String'>
    readonly createdAt: FieldRef<"FieldWell", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FieldWell findUnique
   */
  export type FieldWellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * Filter, which FieldWell to fetch.
     */
    where: FieldWellWhereUniqueInput
  }

  /**
   * FieldWell findUniqueOrThrow
   */
  export type FieldWellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * Filter, which FieldWell to fetch.
     */
    where: FieldWellWhereUniqueInput
  }

  /**
   * FieldWell findFirst
   */
  export type FieldWellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * Filter, which FieldWell to fetch.
     */
    where?: FieldWellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWells to fetch.
     */
    orderBy?: FieldWellOrderByWithRelationInput | FieldWellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldWells.
     */
    cursor?: FieldWellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldWells.
     */
    distinct?: FieldWellScalarFieldEnum | FieldWellScalarFieldEnum[]
  }

  /**
   * FieldWell findFirstOrThrow
   */
  export type FieldWellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * Filter, which FieldWell to fetch.
     */
    where?: FieldWellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWells to fetch.
     */
    orderBy?: FieldWellOrderByWithRelationInput | FieldWellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldWells.
     */
    cursor?: FieldWellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldWells.
     */
    distinct?: FieldWellScalarFieldEnum | FieldWellScalarFieldEnum[]
  }

  /**
   * FieldWell findMany
   */
  export type FieldWellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * Filter, which FieldWells to fetch.
     */
    where?: FieldWellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldWells to fetch.
     */
    orderBy?: FieldWellOrderByWithRelationInput | FieldWellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldWells.
     */
    cursor?: FieldWellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldWells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldWells.
     */
    skip?: number
    distinct?: FieldWellScalarFieldEnum | FieldWellScalarFieldEnum[]
  }

  /**
   * FieldWell create
   */
  export type FieldWellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldWell.
     */
    data: XOR<FieldWellCreateInput, FieldWellUncheckedCreateInput>
  }

  /**
   * FieldWell createMany
   */
  export type FieldWellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldWells.
     */
    data: FieldWellCreateManyInput | FieldWellCreateManyInput[]
  }

  /**
   * FieldWell update
   */
  export type FieldWellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldWell.
     */
    data: XOR<FieldWellUpdateInput, FieldWellUncheckedUpdateInput>
    /**
     * Choose, which FieldWell to update.
     */
    where: FieldWellWhereUniqueInput
  }

  /**
   * FieldWell updateMany
   */
  export type FieldWellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldWells.
     */
    data: XOR<FieldWellUpdateManyMutationInput, FieldWellUncheckedUpdateManyInput>
    /**
     * Filter which FieldWells to update
     */
    where?: FieldWellWhereInput
    /**
     * Limit how many FieldWells to update.
     */
    limit?: number
  }

  /**
   * FieldWell upsert
   */
  export type FieldWellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldWell to update in case it exists.
     */
    where: FieldWellWhereUniqueInput
    /**
     * In case the FieldWell found by the `where` argument doesn't exist, create a new FieldWell with this data.
     */
    create: XOR<FieldWellCreateInput, FieldWellUncheckedCreateInput>
    /**
     * In case the FieldWell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldWellUpdateInput, FieldWellUncheckedUpdateInput>
  }

  /**
   * FieldWell delete
   */
  export type FieldWellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    /**
     * Filter which FieldWell to delete.
     */
    where: FieldWellWhereUniqueInput
  }

  /**
   * FieldWell deleteMany
   */
  export type FieldWellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldWells to delete
     */
    where?: FieldWellWhereInput
    /**
     * Limit how many FieldWells to delete.
     */
    limit?: number
  }

  /**
   * FieldWell findRaw
   */
  export type FieldWellFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldWell aggregateRaw
   */
  export type FieldWellAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldWell without action
   */
  export type FieldWellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
  }


  /**
   * Model WorkerWellAssignment
   */

  export type AggregateWorkerWellAssignment = {
    _count: WorkerWellAssignmentCountAggregateOutputType | null
    _min: WorkerWellAssignmentMinAggregateOutputType | null
    _max: WorkerWellAssignmentMaxAggregateOutputType | null
  }

  export type WorkerWellAssignmentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workerId: string | null
    wellId: string | null
  }

  export type WorkerWellAssignmentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workerId: string | null
    wellId: string | null
  }

  export type WorkerWellAssignmentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    workerId: number
    wellId: number
    _all: number
  }


  export type WorkerWellAssignmentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workerId?: true
    wellId?: true
  }

  export type WorkerWellAssignmentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workerId?: true
    wellId?: true
  }

  export type WorkerWellAssignmentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workerId?: true
    wellId?: true
    _all?: true
  }

  export type WorkerWellAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerWellAssignment to aggregate.
     */
    where?: WorkerWellAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerWellAssignments to fetch.
     */
    orderBy?: WorkerWellAssignmentOrderByWithRelationInput | WorkerWellAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWellAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerWellAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerWellAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerWellAssignments
    **/
    _count?: true | WorkerWellAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerWellAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerWellAssignmentMaxAggregateInputType
  }

  export type GetWorkerWellAssignmentAggregateType<T extends WorkerWellAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerWellAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerWellAssignment[P]>
      : GetScalarType<T[P], AggregateWorkerWellAssignment[P]>
  }




  export type WorkerWellAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWellAssignmentWhereInput
    orderBy?: WorkerWellAssignmentOrderByWithAggregationInput | WorkerWellAssignmentOrderByWithAggregationInput[]
    by: WorkerWellAssignmentScalarFieldEnum[] | WorkerWellAssignmentScalarFieldEnum
    having?: WorkerWellAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerWellAssignmentCountAggregateInputType | true
    _min?: WorkerWellAssignmentMinAggregateInputType
    _max?: WorkerWellAssignmentMaxAggregateInputType
  }

  export type WorkerWellAssignmentGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    workerId: string
    wellId: string
    _count: WorkerWellAssignmentCountAggregateOutputType | null
    _min: WorkerWellAssignmentMinAggregateOutputType | null
    _max: WorkerWellAssignmentMaxAggregateOutputType | null
  }

  type GetWorkerWellAssignmentGroupByPayload<T extends WorkerWellAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerWellAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerWellAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerWellAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerWellAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type WorkerWellAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workerId?: boolean
    wellId?: boolean
    worker?: boolean | UserDefaultArgs<ExtArgs>
    well?: boolean | WellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerWellAssignment"]>



  export type WorkerWellAssignmentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workerId?: boolean
    wellId?: boolean
  }

  export type WorkerWellAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "workerId" | "wellId", ExtArgs["result"]["workerWellAssignment"]>
  export type WorkerWellAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worker?: boolean | UserDefaultArgs<ExtArgs>
    well?: boolean | WellDefaultArgs<ExtArgs>
  }

  export type $WorkerWellAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerWellAssignment"
    objects: {
      worker: Prisma.$UserPayload<ExtArgs>
      well: Prisma.$WellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      workerId: string
      wellId: string
    }, ExtArgs["result"]["workerWellAssignment"]>
    composites: {}
  }

  type WorkerWellAssignmentGetPayload<S extends boolean | null | undefined | WorkerWellAssignmentDefaultArgs> = $Result.GetResult<Prisma.$WorkerWellAssignmentPayload, S>

  type WorkerWellAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerWellAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerWellAssignmentCountAggregateInputType | true
    }

  export interface WorkerWellAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerWellAssignment'], meta: { name: 'WorkerWellAssignment' } }
    /**
     * Find zero or one WorkerWellAssignment that matches the filter.
     * @param {WorkerWellAssignmentFindUniqueArgs} args - Arguments to find a WorkerWellAssignment
     * @example
     * // Get one WorkerWellAssignment
     * const workerWellAssignment = await prisma.workerWellAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerWellAssignmentFindUniqueArgs>(args: SelectSubset<T, WorkerWellAssignmentFindUniqueArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkerWellAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerWellAssignmentFindUniqueOrThrowArgs} args - Arguments to find a WorkerWellAssignment
     * @example
     * // Get one WorkerWellAssignment
     * const workerWellAssignment = await prisma.workerWellAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerWellAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerWellAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerWellAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentFindFirstArgs} args - Arguments to find a WorkerWellAssignment
     * @example
     * // Get one WorkerWellAssignment
     * const workerWellAssignment = await prisma.workerWellAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerWellAssignmentFindFirstArgs>(args?: SelectSubset<T, WorkerWellAssignmentFindFirstArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerWellAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentFindFirstOrThrowArgs} args - Arguments to find a WorkerWellAssignment
     * @example
     * // Get one WorkerWellAssignment
     * const workerWellAssignment = await prisma.workerWellAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerWellAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerWellAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerWellAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerWellAssignments
     * const workerWellAssignments = await prisma.workerWellAssignment.findMany()
     * 
     * // Get first 10 WorkerWellAssignments
     * const workerWellAssignments = await prisma.workerWellAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWellAssignmentWithIdOnly = await prisma.workerWellAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerWellAssignmentFindManyArgs>(args?: SelectSubset<T, WorkerWellAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkerWellAssignment.
     * @param {WorkerWellAssignmentCreateArgs} args - Arguments to create a WorkerWellAssignment.
     * @example
     * // Create one WorkerWellAssignment
     * const WorkerWellAssignment = await prisma.workerWellAssignment.create({
     *   data: {
     *     // ... data to create a WorkerWellAssignment
     *   }
     * })
     * 
     */
    create<T extends WorkerWellAssignmentCreateArgs>(args: SelectSubset<T, WorkerWellAssignmentCreateArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkerWellAssignments.
     * @param {WorkerWellAssignmentCreateManyArgs} args - Arguments to create many WorkerWellAssignments.
     * @example
     * // Create many WorkerWellAssignments
     * const workerWellAssignment = await prisma.workerWellAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerWellAssignmentCreateManyArgs>(args?: SelectSubset<T, WorkerWellAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkerWellAssignment.
     * @param {WorkerWellAssignmentDeleteArgs} args - Arguments to delete one WorkerWellAssignment.
     * @example
     * // Delete one WorkerWellAssignment
     * const WorkerWellAssignment = await prisma.workerWellAssignment.delete({
     *   where: {
     *     // ... filter to delete one WorkerWellAssignment
     *   }
     * })
     * 
     */
    delete<T extends WorkerWellAssignmentDeleteArgs>(args: SelectSubset<T, WorkerWellAssignmentDeleteArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkerWellAssignment.
     * @param {WorkerWellAssignmentUpdateArgs} args - Arguments to update one WorkerWellAssignment.
     * @example
     * // Update one WorkerWellAssignment
     * const workerWellAssignment = await prisma.workerWellAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerWellAssignmentUpdateArgs>(args: SelectSubset<T, WorkerWellAssignmentUpdateArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkerWellAssignments.
     * @param {WorkerWellAssignmentDeleteManyArgs} args - Arguments to filter WorkerWellAssignments to delete.
     * @example
     * // Delete a few WorkerWellAssignments
     * const { count } = await prisma.workerWellAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerWellAssignmentDeleteManyArgs>(args?: SelectSubset<T, WorkerWellAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerWellAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerWellAssignments
     * const workerWellAssignment = await prisma.workerWellAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerWellAssignmentUpdateManyArgs>(args: SelectSubset<T, WorkerWellAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkerWellAssignment.
     * @param {WorkerWellAssignmentUpsertArgs} args - Arguments to update or create a WorkerWellAssignment.
     * @example
     * // Update or create a WorkerWellAssignment
     * const workerWellAssignment = await prisma.workerWellAssignment.upsert({
     *   create: {
     *     // ... data to create a WorkerWellAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerWellAssignment we want to update
     *   }
     * })
     */
    upsert<T extends WorkerWellAssignmentUpsertArgs>(args: SelectSubset<T, WorkerWellAssignmentUpsertArgs<ExtArgs>>): Prisma__WorkerWellAssignmentClient<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerWellAssignments that matches the filter.
     * @param {WorkerWellAssignmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const workerWellAssignment = await prisma.workerWellAssignment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WorkerWellAssignmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WorkerWellAssignment.
     * @param {WorkerWellAssignmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const workerWellAssignment = await prisma.workerWellAssignment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WorkerWellAssignmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WorkerWellAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentCountArgs} args - Arguments to filter WorkerWellAssignments to count.
     * @example
     * // Count the number of WorkerWellAssignments
     * const count = await prisma.workerWellAssignment.count({
     *   where: {
     *     // ... the filter for the WorkerWellAssignments we want to count
     *   }
     * })
    **/
    count<T extends WorkerWellAssignmentCountArgs>(
      args?: Subset<T, WorkerWellAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerWellAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerWellAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerWellAssignmentAggregateArgs>(args: Subset<T, WorkerWellAssignmentAggregateArgs>): Prisma.PrismaPromise<GetWorkerWellAssignmentAggregateType<T>>

    /**
     * Group by WorkerWellAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerWellAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerWellAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerWellAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: WorkerWellAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerWellAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerWellAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerWellAssignment model
   */
  readonly fields: WorkerWellAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerWellAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerWellAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    worker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    well<T extends WellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellDefaultArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerWellAssignment model
   */
  interface WorkerWellAssignmentFieldRefs {
    readonly id: FieldRef<"WorkerWellAssignment", 'String'>
    readonly createdAt: FieldRef<"WorkerWellAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkerWellAssignment", 'DateTime'>
    readonly workerId: FieldRef<"WorkerWellAssignment", 'String'>
    readonly wellId: FieldRef<"WorkerWellAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkerWellAssignment findUnique
   */
  export type WorkerWellAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkerWellAssignment to fetch.
     */
    where: WorkerWellAssignmentWhereUniqueInput
  }

  /**
   * WorkerWellAssignment findUniqueOrThrow
   */
  export type WorkerWellAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkerWellAssignment to fetch.
     */
    where: WorkerWellAssignmentWhereUniqueInput
  }

  /**
   * WorkerWellAssignment findFirst
   */
  export type WorkerWellAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkerWellAssignment to fetch.
     */
    where?: WorkerWellAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerWellAssignments to fetch.
     */
    orderBy?: WorkerWellAssignmentOrderByWithRelationInput | WorkerWellAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerWellAssignments.
     */
    cursor?: WorkerWellAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerWellAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerWellAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerWellAssignments.
     */
    distinct?: WorkerWellAssignmentScalarFieldEnum | WorkerWellAssignmentScalarFieldEnum[]
  }

  /**
   * WorkerWellAssignment findFirstOrThrow
   */
  export type WorkerWellAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkerWellAssignment to fetch.
     */
    where?: WorkerWellAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerWellAssignments to fetch.
     */
    orderBy?: WorkerWellAssignmentOrderByWithRelationInput | WorkerWellAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerWellAssignments.
     */
    cursor?: WorkerWellAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerWellAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerWellAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerWellAssignments.
     */
    distinct?: WorkerWellAssignmentScalarFieldEnum | WorkerWellAssignmentScalarFieldEnum[]
  }

  /**
   * WorkerWellAssignment findMany
   */
  export type WorkerWellAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkerWellAssignments to fetch.
     */
    where?: WorkerWellAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerWellAssignments to fetch.
     */
    orderBy?: WorkerWellAssignmentOrderByWithRelationInput | WorkerWellAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerWellAssignments.
     */
    cursor?: WorkerWellAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerWellAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerWellAssignments.
     */
    skip?: number
    distinct?: WorkerWellAssignmentScalarFieldEnum | WorkerWellAssignmentScalarFieldEnum[]
  }

  /**
   * WorkerWellAssignment create
   */
  export type WorkerWellAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerWellAssignment.
     */
    data: XOR<WorkerWellAssignmentCreateInput, WorkerWellAssignmentUncheckedCreateInput>
  }

  /**
   * WorkerWellAssignment createMany
   */
  export type WorkerWellAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerWellAssignments.
     */
    data: WorkerWellAssignmentCreateManyInput | WorkerWellAssignmentCreateManyInput[]
  }

  /**
   * WorkerWellAssignment update
   */
  export type WorkerWellAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerWellAssignment.
     */
    data: XOR<WorkerWellAssignmentUpdateInput, WorkerWellAssignmentUncheckedUpdateInput>
    /**
     * Choose, which WorkerWellAssignment to update.
     */
    where: WorkerWellAssignmentWhereUniqueInput
  }

  /**
   * WorkerWellAssignment updateMany
   */
  export type WorkerWellAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerWellAssignments.
     */
    data: XOR<WorkerWellAssignmentUpdateManyMutationInput, WorkerWellAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which WorkerWellAssignments to update
     */
    where?: WorkerWellAssignmentWhereInput
    /**
     * Limit how many WorkerWellAssignments to update.
     */
    limit?: number
  }

  /**
   * WorkerWellAssignment upsert
   */
  export type WorkerWellAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerWellAssignment to update in case it exists.
     */
    where: WorkerWellAssignmentWhereUniqueInput
    /**
     * In case the WorkerWellAssignment found by the `where` argument doesn't exist, create a new WorkerWellAssignment with this data.
     */
    create: XOR<WorkerWellAssignmentCreateInput, WorkerWellAssignmentUncheckedCreateInput>
    /**
     * In case the WorkerWellAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerWellAssignmentUpdateInput, WorkerWellAssignmentUncheckedUpdateInput>
  }

  /**
   * WorkerWellAssignment delete
   */
  export type WorkerWellAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    /**
     * Filter which WorkerWellAssignment to delete.
     */
    where: WorkerWellAssignmentWhereUniqueInput
  }

  /**
   * WorkerWellAssignment deleteMany
   */
  export type WorkerWellAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerWellAssignments to delete
     */
    where?: WorkerWellAssignmentWhereInput
    /**
     * Limit how many WorkerWellAssignments to delete.
     */
    limit?: number
  }

  /**
   * WorkerWellAssignment findRaw
   */
  export type WorkerWellAssignmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WorkerWellAssignment aggregateRaw
   */
  export type WorkerWellAssignmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WorkerWellAssignment without action
   */
  export type WorkerWellAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Well
   */

  export type AggregateWell = {
    _count: WellCountAggregateOutputType | null
    _avg: WellAvgAggregateOutputType | null
    _sum: WellSumAggregateOutputType | null
    _min: WellMinAggregateOutputType | null
    _max: WellMaxAggregateOutputType | null
  }

  export type WellAvgAggregateOutputType = {
    depth: number | null
    capacity: number | null
  }

  export type WellSumAggregateOutputType = {
    depth: number | null
    capacity: number | null
  }

  export type WellMinAggregateOutputType = {
    id: string | null
    name: string | null
    depth: number | null
    capacity: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellMaxAggregateOutputType = {
    id: string | null
    name: string | null
    depth: number | null
    capacity: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellCountAggregateOutputType = {
    id: number
    name: number
    depth: number
    capacity: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellAvgAggregateInputType = {
    depth?: true
    capacity?: true
  }

  export type WellSumAggregateInputType = {
    depth?: true
    capacity?: true
  }

  export type WellMinAggregateInputType = {
    id?: true
    name?: true
    depth?: true
    capacity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellMaxAggregateInputType = {
    id?: true
    name?: true
    depth?: true
    capacity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellCountAggregateInputType = {
    id?: true
    name?: true
    depth?: true
    capacity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Well to aggregate.
     */
    where?: WellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wells to fetch.
     */
    orderBy?: WellOrderByWithRelationInput | WellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wells
    **/
    _count?: true | WellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellMaxAggregateInputType
  }

  export type GetWellAggregateType<T extends WellAggregateArgs> = {
        [P in keyof T & keyof AggregateWell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWell[P]>
      : GetScalarType<T[P], AggregateWell[P]>
  }




  export type WellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellWhereInput
    orderBy?: WellOrderByWithAggregationInput | WellOrderByWithAggregationInput[]
    by: WellScalarFieldEnum[] | WellScalarFieldEnum
    having?: WellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellCountAggregateInputType | true
    _avg?: WellAvgAggregateInputType
    _sum?: WellSumAggregateInputType
    _min?: WellMinAggregateInputType
    _max?: WellMaxAggregateInputType
  }

  export type WellGroupByOutputType = {
    id: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: WellCountAggregateOutputType | null
    _avg: WellAvgAggregateOutputType | null
    _sum: WellSumAggregateOutputType | null
    _min: WellMinAggregateOutputType | null
    _max: WellMaxAggregateOutputType | null
  }

  type GetWellGroupByPayload<T extends WellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellGroupByOutputType[P]>
            : GetScalarType<T[P], WellGroupByOutputType[P]>
        }
      >
    >


  export type WellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    depth?: boolean
    capacity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldWells?: boolean | Well$fieldWellsArgs<ExtArgs>
    notifications?: boolean | Well$notificationsArgs<ExtArgs>
    irrigationLogs?: boolean | Well$irrigationLogsArgs<ExtArgs>
    wellBillingPeriods?: boolean | Well$wellBillingPeriodsArgs<ExtArgs>
    workerAssignments?: boolean | Well$workerAssignmentsArgs<ExtArgs>
    _count?: boolean | WellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["well"]>



  export type WellSelectScalar = {
    id?: boolean
    name?: boolean
    depth?: boolean
    capacity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "depth" | "capacity" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["well"]>
  export type WellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fieldWells?: boolean | Well$fieldWellsArgs<ExtArgs>
    notifications?: boolean | Well$notificationsArgs<ExtArgs>
    irrigationLogs?: boolean | Well$irrigationLogsArgs<ExtArgs>
    wellBillingPeriods?: boolean | Well$wellBillingPeriodsArgs<ExtArgs>
    workerAssignments?: boolean | Well$workerAssignmentsArgs<ExtArgs>
    _count?: boolean | WellCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Well"
    objects: {
      fieldWells: Prisma.$FieldWellPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      irrigationLogs: Prisma.$IrrigationLogPayload<ExtArgs>[]
      wellBillingPeriods: Prisma.$WellBillingPeriodPayload<ExtArgs>[]
      workerAssignments: Prisma.$WorkerWellAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      depth: number
      capacity: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["well"]>
    composites: {}
  }

  type WellGetPayload<S extends boolean | null | undefined | WellDefaultArgs> = $Result.GetResult<Prisma.$WellPayload, S>

  type WellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellCountAggregateInputType | true
    }

  export interface WellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Well'], meta: { name: 'Well' } }
    /**
     * Find zero or one Well that matches the filter.
     * @param {WellFindUniqueArgs} args - Arguments to find a Well
     * @example
     * // Get one Well
     * const well = await prisma.well.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellFindUniqueArgs>(args: SelectSubset<T, WellFindUniqueArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Well that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellFindUniqueOrThrowArgs} args - Arguments to find a Well
     * @example
     * // Get one Well
     * const well = await prisma.well.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellFindUniqueOrThrowArgs>(args: SelectSubset<T, WellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Well that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellFindFirstArgs} args - Arguments to find a Well
     * @example
     * // Get one Well
     * const well = await prisma.well.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellFindFirstArgs>(args?: SelectSubset<T, WellFindFirstArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Well that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellFindFirstOrThrowArgs} args - Arguments to find a Well
     * @example
     * // Get one Well
     * const well = await prisma.well.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellFindFirstOrThrowArgs>(args?: SelectSubset<T, WellFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wells
     * const wells = await prisma.well.findMany()
     * 
     * // Get first 10 Wells
     * const wells = await prisma.well.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellWithIdOnly = await prisma.well.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellFindManyArgs>(args?: SelectSubset<T, WellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Well.
     * @param {WellCreateArgs} args - Arguments to create a Well.
     * @example
     * // Create one Well
     * const Well = await prisma.well.create({
     *   data: {
     *     // ... data to create a Well
     *   }
     * })
     * 
     */
    create<T extends WellCreateArgs>(args: SelectSubset<T, WellCreateArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wells.
     * @param {WellCreateManyArgs} args - Arguments to create many Wells.
     * @example
     * // Create many Wells
     * const well = await prisma.well.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellCreateManyArgs>(args?: SelectSubset<T, WellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Well.
     * @param {WellDeleteArgs} args - Arguments to delete one Well.
     * @example
     * // Delete one Well
     * const Well = await prisma.well.delete({
     *   where: {
     *     // ... filter to delete one Well
     *   }
     * })
     * 
     */
    delete<T extends WellDeleteArgs>(args: SelectSubset<T, WellDeleteArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Well.
     * @param {WellUpdateArgs} args - Arguments to update one Well.
     * @example
     * // Update one Well
     * const well = await prisma.well.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellUpdateArgs>(args: SelectSubset<T, WellUpdateArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wells.
     * @param {WellDeleteManyArgs} args - Arguments to filter Wells to delete.
     * @example
     * // Delete a few Wells
     * const { count } = await prisma.well.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellDeleteManyArgs>(args?: SelectSubset<T, WellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wells
     * const well = await prisma.well.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellUpdateManyArgs>(args: SelectSubset<T, WellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Well.
     * @param {WellUpsertArgs} args - Arguments to update or create a Well.
     * @example
     * // Update or create a Well
     * const well = await prisma.well.upsert({
     *   create: {
     *     // ... data to create a Well
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Well we want to update
     *   }
     * })
     */
    upsert<T extends WellUpsertArgs>(args: SelectSubset<T, WellUpsertArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wells that matches the filter.
     * @param {WellFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const well = await prisma.well.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WellFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Well.
     * @param {WellAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const well = await prisma.well.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WellAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Wells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellCountArgs} args - Arguments to filter Wells to count.
     * @example
     * // Count the number of Wells
     * const count = await prisma.well.count({
     *   where: {
     *     // ... the filter for the Wells we want to count
     *   }
     * })
    **/
    count<T extends WellCountArgs>(
      args?: Subset<T, WellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Well.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellAggregateArgs>(args: Subset<T, WellAggregateArgs>): Prisma.PrismaPromise<GetWellAggregateType<T>>

    /**
     * Group by Well.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellGroupByArgs['orderBy'] }
        : { orderBy?: WellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Well model
   */
  readonly fields: WellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Well.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fieldWells<T extends Well$fieldWellsArgs<ExtArgs> = {}>(args?: Subset<T, Well$fieldWellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldWellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Well$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Well$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    irrigationLogs<T extends Well$irrigationLogsArgs<ExtArgs> = {}>(args?: Subset<T, Well$irrigationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellBillingPeriods<T extends Well$wellBillingPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, Well$wellBillingPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerAssignments<T extends Well$workerAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Well$workerAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerWellAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Well model
   */
  interface WellFieldRefs {
    readonly id: FieldRef<"Well", 'String'>
    readonly name: FieldRef<"Well", 'String'>
    readonly depth: FieldRef<"Well", 'Float'>
    readonly capacity: FieldRef<"Well", 'Float'>
    readonly status: FieldRef<"Well", 'String'>
    readonly createdAt: FieldRef<"Well", 'DateTime'>
    readonly updatedAt: FieldRef<"Well", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Well findUnique
   */
  export type WellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * Filter, which Well to fetch.
     */
    where: WellWhereUniqueInput
  }

  /**
   * Well findUniqueOrThrow
   */
  export type WellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * Filter, which Well to fetch.
     */
    where: WellWhereUniqueInput
  }

  /**
   * Well findFirst
   */
  export type WellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * Filter, which Well to fetch.
     */
    where?: WellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wells to fetch.
     */
    orderBy?: WellOrderByWithRelationInput | WellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wells.
     */
    cursor?: WellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wells.
     */
    distinct?: WellScalarFieldEnum | WellScalarFieldEnum[]
  }

  /**
   * Well findFirstOrThrow
   */
  export type WellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * Filter, which Well to fetch.
     */
    where?: WellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wells to fetch.
     */
    orderBy?: WellOrderByWithRelationInput | WellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wells.
     */
    cursor?: WellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wells.
     */
    distinct?: WellScalarFieldEnum | WellScalarFieldEnum[]
  }

  /**
   * Well findMany
   */
  export type WellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * Filter, which Wells to fetch.
     */
    where?: WellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wells to fetch.
     */
    orderBy?: WellOrderByWithRelationInput | WellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wells.
     */
    cursor?: WellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wells.
     */
    skip?: number
    distinct?: WellScalarFieldEnum | WellScalarFieldEnum[]
  }

  /**
   * Well create
   */
  export type WellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * The data needed to create a Well.
     */
    data: XOR<WellCreateInput, WellUncheckedCreateInput>
  }

  /**
   * Well createMany
   */
  export type WellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wells.
     */
    data: WellCreateManyInput | WellCreateManyInput[]
  }

  /**
   * Well update
   */
  export type WellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * The data needed to update a Well.
     */
    data: XOR<WellUpdateInput, WellUncheckedUpdateInput>
    /**
     * Choose, which Well to update.
     */
    where: WellWhereUniqueInput
  }

  /**
   * Well updateMany
   */
  export type WellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wells.
     */
    data: XOR<WellUpdateManyMutationInput, WellUncheckedUpdateManyInput>
    /**
     * Filter which Wells to update
     */
    where?: WellWhereInput
    /**
     * Limit how many Wells to update.
     */
    limit?: number
  }

  /**
   * Well upsert
   */
  export type WellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * The filter to search for the Well to update in case it exists.
     */
    where: WellWhereUniqueInput
    /**
     * In case the Well found by the `where` argument doesn't exist, create a new Well with this data.
     */
    create: XOR<WellCreateInput, WellUncheckedCreateInput>
    /**
     * In case the Well was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellUpdateInput, WellUncheckedUpdateInput>
  }

  /**
   * Well delete
   */
  export type WellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    /**
     * Filter which Well to delete.
     */
    where: WellWhereUniqueInput
  }

  /**
   * Well deleteMany
   */
  export type WellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wells to delete
     */
    where?: WellWhereInput
    /**
     * Limit how many Wells to delete.
     */
    limit?: number
  }

  /**
   * Well findRaw
   */
  export type WellFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Well aggregateRaw
   */
  export type WellAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Well.fieldWells
   */
  export type Well$fieldWellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldWell
     */
    select?: FieldWellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldWell
     */
    omit?: FieldWellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldWellInclude<ExtArgs> | null
    where?: FieldWellWhereInput
    orderBy?: FieldWellOrderByWithRelationInput | FieldWellOrderByWithRelationInput[]
    cursor?: FieldWellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldWellScalarFieldEnum | FieldWellScalarFieldEnum[]
  }

  /**
   * Well.notifications
   */
  export type Well$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Well.irrigationLogs
   */
  export type Well$irrigationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    where?: IrrigationLogWhereInput
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    cursor?: IrrigationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationLogScalarFieldEnum | IrrigationLogScalarFieldEnum[]
  }

  /**
   * Well.wellBillingPeriods
   */
  export type Well$wellBillingPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    where?: WellBillingPeriodWhereInput
    orderBy?: WellBillingPeriodOrderByWithRelationInput | WellBillingPeriodOrderByWithRelationInput[]
    cursor?: WellBillingPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillingPeriodScalarFieldEnum | WellBillingPeriodScalarFieldEnum[]
  }

  /**
   * Well.workerAssignments
   */
  export type Well$workerAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerWellAssignment
     */
    select?: WorkerWellAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerWellAssignment
     */
    omit?: WorkerWellAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerWellAssignmentInclude<ExtArgs> | null
    where?: WorkerWellAssignmentWhereInput
    orderBy?: WorkerWellAssignmentOrderByWithRelationInput | WorkerWellAssignmentOrderByWithRelationInput[]
    cursor?: WorkerWellAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerWellAssignmentScalarFieldEnum | WorkerWellAssignmentScalarFieldEnum[]
  }

  /**
   * Well without action
   */
  export type WellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
  }


  /**
   * Model Crop
   */

  export type AggregateCrop = {
    _count: CropCountAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  export type CropMinAggregateOutputType = {
    id: string | null
    name: string | null
    plantedDate: Date | null
    harvestDate: Date | null
    status: $Enums.CropStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
    fieldId: string | null
  }

  export type CropMaxAggregateOutputType = {
    id: string | null
    name: string | null
    plantedDate: Date | null
    harvestDate: Date | null
    status: $Enums.CropStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
    fieldId: string | null
  }

  export type CropCountAggregateOutputType = {
    id: number
    name: number
    plantedDate: number
    harvestDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    seasonId: number
    fieldId: number
    _all: number
  }


  export type CropMinAggregateInputType = {
    id?: true
    name?: true
    plantedDate?: true
    harvestDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    fieldId?: true
  }

  export type CropMaxAggregateInputType = {
    id?: true
    name?: true
    plantedDate?: true
    harvestDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    fieldId?: true
  }

  export type CropCountAggregateInputType = {
    id?: true
    name?: true
    plantedDate?: true
    harvestDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    fieldId?: true
    _all?: true
  }

  export type CropAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crop to aggregate.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crops
    **/
    _count?: true | CropCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CropMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CropMaxAggregateInputType
  }

  export type GetCropAggregateType<T extends CropAggregateArgs> = {
        [P in keyof T & keyof AggregateCrop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrop[P]>
      : GetScalarType<T[P], AggregateCrop[P]>
  }




  export type CropGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CropWhereInput
    orderBy?: CropOrderByWithAggregationInput | CropOrderByWithAggregationInput[]
    by: CropScalarFieldEnum[] | CropScalarFieldEnum
    having?: CropScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CropCountAggregateInputType | true
    _min?: CropMinAggregateInputType
    _max?: CropMaxAggregateInputType
  }

  export type CropGroupByOutputType = {
    id: string
    name: string
    plantedDate: Date
    harvestDate: Date | null
    status: $Enums.CropStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    seasonId: string | null
    fieldId: string
    _count: CropCountAggregateOutputType | null
    _min: CropMinAggregateOutputType | null
    _max: CropMaxAggregateOutputType | null
  }

  type GetCropGroupByPayload<T extends CropGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CropGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CropGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CropGroupByOutputType[P]>
            : GetScalarType<T[P], CropGroupByOutputType[P]>
        }
      >
    >


  export type CropSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plantedDate?: boolean
    harvestDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
    fieldId?: boolean
    season?: boolean | Crop$seasonArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    notifications?: boolean | Crop$notificationsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crop"]>



  export type CropSelectScalar = {
    id?: boolean
    name?: boolean
    plantedDate?: boolean
    harvestDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
    fieldId?: boolean
  }

  export type CropOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "plantedDate" | "harvestDate" | "status" | "notes" | "createdAt" | "updatedAt" | "seasonId" | "fieldId", ExtArgs["result"]["crop"]>
  export type CropInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | Crop$seasonArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    notifications?: boolean | Crop$notificationsArgs<ExtArgs>
    _count?: boolean | CropCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CropPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crop"
    objects: {
      season: Prisma.$SeasonPayload<ExtArgs> | null
      field: Prisma.$FieldPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      plantedDate: Date
      harvestDate: Date | null
      status: $Enums.CropStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
      seasonId: string | null
      fieldId: string
    }, ExtArgs["result"]["crop"]>
    composites: {}
  }

  type CropGetPayload<S extends boolean | null | undefined | CropDefaultArgs> = $Result.GetResult<Prisma.$CropPayload, S>

  type CropCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CropFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CropCountAggregateInputType | true
    }

  export interface CropDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crop'], meta: { name: 'Crop' } }
    /**
     * Find zero or one Crop that matches the filter.
     * @param {CropFindUniqueArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CropFindUniqueArgs>(args: SelectSubset<T, CropFindUniqueArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CropFindUniqueOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CropFindUniqueOrThrowArgs>(args: SelectSubset<T, CropFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CropFindFirstArgs>(args?: SelectSubset<T, CropFindFirstArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindFirstOrThrowArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CropFindFirstOrThrowArgs>(args?: SelectSubset<T, CropFindFirstOrThrowArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crops
     * const crops = await prisma.crop.findMany()
     * 
     * // Get first 10 Crops
     * const crops = await prisma.crop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropWithIdOnly = await prisma.crop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CropFindManyArgs>(args?: SelectSubset<T, CropFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crop.
     * @param {CropCreateArgs} args - Arguments to create a Crop.
     * @example
     * // Create one Crop
     * const Crop = await prisma.crop.create({
     *   data: {
     *     // ... data to create a Crop
     *   }
     * })
     * 
     */
    create<T extends CropCreateArgs>(args: SelectSubset<T, CropCreateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crops.
     * @param {CropCreateManyArgs} args - Arguments to create many Crops.
     * @example
     * // Create many Crops
     * const crop = await prisma.crop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CropCreateManyArgs>(args?: SelectSubset<T, CropCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Crop.
     * @param {CropDeleteArgs} args - Arguments to delete one Crop.
     * @example
     * // Delete one Crop
     * const Crop = await prisma.crop.delete({
     *   where: {
     *     // ... filter to delete one Crop
     *   }
     * })
     * 
     */
    delete<T extends CropDeleteArgs>(args: SelectSubset<T, CropDeleteArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crop.
     * @param {CropUpdateArgs} args - Arguments to update one Crop.
     * @example
     * // Update one Crop
     * const crop = await prisma.crop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CropUpdateArgs>(args: SelectSubset<T, CropUpdateArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crops.
     * @param {CropDeleteManyArgs} args - Arguments to filter Crops to delete.
     * @example
     * // Delete a few Crops
     * const { count } = await prisma.crop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CropDeleteManyArgs>(args?: SelectSubset<T, CropDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crops
     * const crop = await prisma.crop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CropUpdateManyArgs>(args: SelectSubset<T, CropUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crop.
     * @param {CropUpsertArgs} args - Arguments to update or create a Crop.
     * @example
     * // Update or create a Crop
     * const crop = await prisma.crop.upsert({
     *   create: {
     *     // ... data to create a Crop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crop we want to update
     *   }
     * })
     */
    upsert<T extends CropUpsertArgs>(args: SelectSubset<T, CropUpsertArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crops that matches the filter.
     * @param {CropFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const crop = await prisma.crop.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CropFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Crop.
     * @param {CropAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const crop = await prisma.crop.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CropAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Crops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropCountArgs} args - Arguments to filter Crops to count.
     * @example
     * // Count the number of Crops
     * const count = await prisma.crop.count({
     *   where: {
     *     // ... the filter for the Crops we want to count
     *   }
     * })
    **/
    count<T extends CropCountArgs>(
      args?: Subset<T, CropCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CropCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CropAggregateArgs>(args: Subset<T, CropAggregateArgs>): Prisma.PrismaPromise<GetCropAggregateType<T>>

    /**
     * Group by Crop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CropGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CropGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CropGroupByArgs['orderBy'] }
        : { orderBy?: CropGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CropGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCropGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crop model
   */
  readonly fields: CropFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CropClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    season<T extends Crop$seasonArgs<ExtArgs> = {}>(args?: Subset<T, Crop$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Crop$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Crop$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crop model
   */
  interface CropFieldRefs {
    readonly id: FieldRef<"Crop", 'String'>
    readonly name: FieldRef<"Crop", 'String'>
    readonly plantedDate: FieldRef<"Crop", 'DateTime'>
    readonly harvestDate: FieldRef<"Crop", 'DateTime'>
    readonly status: FieldRef<"Crop", 'CropStatus'>
    readonly notes: FieldRef<"Crop", 'String'>
    readonly createdAt: FieldRef<"Crop", 'DateTime'>
    readonly updatedAt: FieldRef<"Crop", 'DateTime'>
    readonly seasonId: FieldRef<"Crop", 'String'>
    readonly fieldId: FieldRef<"Crop", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Crop findUnique
   */
  export type CropFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findUniqueOrThrow
   */
  export type CropFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop findFirst
   */
  export type CropFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findFirstOrThrow
   */
  export type CropFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crop to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crops.
     */
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop findMany
   */
  export type CropFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter, which Crops to fetch.
     */
    where?: CropWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crops to fetch.
     */
    orderBy?: CropOrderByWithRelationInput | CropOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crops.
     */
    cursor?: CropWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crops.
     */
    skip?: number
    distinct?: CropScalarFieldEnum | CropScalarFieldEnum[]
  }

  /**
   * Crop create
   */
  export type CropCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to create a Crop.
     */
    data: XOR<CropCreateInput, CropUncheckedCreateInput>
  }

  /**
   * Crop createMany
   */
  export type CropCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crops.
     */
    data: CropCreateManyInput | CropCreateManyInput[]
  }

  /**
   * Crop update
   */
  export type CropUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The data needed to update a Crop.
     */
    data: XOR<CropUpdateInput, CropUncheckedUpdateInput>
    /**
     * Choose, which Crop to update.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop updateMany
   */
  export type CropUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crops.
     */
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyInput>
    /**
     * Filter which Crops to update
     */
    where?: CropWhereInput
    /**
     * Limit how many Crops to update.
     */
    limit?: number
  }

  /**
   * Crop upsert
   */
  export type CropUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * The filter to search for the Crop to update in case it exists.
     */
    where: CropWhereUniqueInput
    /**
     * In case the Crop found by the `where` argument doesn't exist, create a new Crop with this data.
     */
    create: XOR<CropCreateInput, CropUncheckedCreateInput>
    /**
     * In case the Crop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CropUpdateInput, CropUncheckedUpdateInput>
  }

  /**
   * Crop delete
   */
  export type CropDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    /**
     * Filter which Crop to delete.
     */
    where: CropWhereUniqueInput
  }

  /**
   * Crop deleteMany
   */
  export type CropDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crops to delete
     */
    where?: CropWhereInput
    /**
     * Limit how many Crops to delete.
     */
    limit?: number
  }

  /**
   * Crop findRaw
   */
  export type CropFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Crop aggregateRaw
   */
  export type CropAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Crop.season
   */
  export type Crop$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * Crop.notifications
   */
  export type Crop$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Crop without action
   */
  export type CropDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
  }


  /**
   * Model ProcessingLog
   */

  export type AggregateProcessingLog = {
    _count: ProcessingLogCountAggregateOutputType | null
    _avg: ProcessingLogAvgAggregateOutputType | null
    _sum: ProcessingLogSumAggregateOutputType | null
    _min: ProcessingLogMinAggregateOutputType | null
    _max: ProcessingLogMaxAggregateOutputType | null
  }

  export type ProcessingLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type ProcessingLogSumAggregateOutputType = {
    duration: number | null
  }

  export type ProcessingLogMinAggregateOutputType = {
    id: string | null
    date: Date | null
    processType: $Enums.ProcessType | null
    equipment: string | null
    duration: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fieldId: string | null
  }

  export type ProcessingLogMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    processType: $Enums.ProcessType | null
    equipment: string | null
    duration: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fieldId: string | null
  }

  export type ProcessingLogCountAggregateOutputType = {
    id: number
    date: number
    processType: number
    equipment: number
    duration: number
    notes: number
    createdAt: number
    updatedAt: number
    fieldId: number
    _all: number
  }


  export type ProcessingLogAvgAggregateInputType = {
    duration?: true
  }

  export type ProcessingLogSumAggregateInputType = {
    duration?: true
  }

  export type ProcessingLogMinAggregateInputType = {
    id?: true
    date?: true
    processType?: true
    equipment?: true
    duration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
  }

  export type ProcessingLogMaxAggregateInputType = {
    id?: true
    date?: true
    processType?: true
    equipment?: true
    duration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
  }

  export type ProcessingLogCountAggregateInputType = {
    id?: true
    date?: true
    processType?: true
    equipment?: true
    duration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
    _all?: true
  }

  export type ProcessingLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingLog to aggregate.
     */
    where?: ProcessingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingLogs to fetch.
     */
    orderBy?: ProcessingLogOrderByWithRelationInput | ProcessingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessingLogs
    **/
    _count?: true | ProcessingLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessingLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessingLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessingLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessingLogMaxAggregateInputType
  }

  export type GetProcessingLogAggregateType<T extends ProcessingLogAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessingLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessingLog[P]>
      : GetScalarType<T[P], AggregateProcessingLog[P]>
  }




  export type ProcessingLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessingLogWhereInput
    orderBy?: ProcessingLogOrderByWithAggregationInput | ProcessingLogOrderByWithAggregationInput[]
    by: ProcessingLogScalarFieldEnum[] | ProcessingLogScalarFieldEnum
    having?: ProcessingLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessingLogCountAggregateInputType | true
    _avg?: ProcessingLogAvgAggregateInputType
    _sum?: ProcessingLogSumAggregateInputType
    _min?: ProcessingLogMinAggregateInputType
    _max?: ProcessingLogMaxAggregateInputType
  }

  export type ProcessingLogGroupByOutputType = {
    id: string
    date: Date
    processType: $Enums.ProcessType
    equipment: string | null
    duration: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    fieldId: string
    _count: ProcessingLogCountAggregateOutputType | null
    _avg: ProcessingLogAvgAggregateOutputType | null
    _sum: ProcessingLogSumAggregateOutputType | null
    _min: ProcessingLogMinAggregateOutputType | null
    _max: ProcessingLogMaxAggregateOutputType | null
  }

  type GetProcessingLogGroupByPayload<T extends ProcessingLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessingLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessingLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessingLogGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessingLogGroupByOutputType[P]>
        }
      >
    >


  export type ProcessingLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    processType?: boolean
    equipment?: boolean
    duration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldId?: boolean
    field?: boolean | FieldDefaultArgs<ExtArgs>
    notifications?: boolean | ProcessingLog$notificationsArgs<ExtArgs>
    _count?: boolean | ProcessingLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processingLog"]>



  export type ProcessingLogSelectScalar = {
    id?: boolean
    date?: boolean
    processType?: boolean
    equipment?: boolean
    duration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldId?: boolean
  }

  export type ProcessingLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "processType" | "equipment" | "duration" | "notes" | "createdAt" | "updatedAt" | "fieldId", ExtArgs["result"]["processingLog"]>
  export type ProcessingLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | FieldDefaultArgs<ExtArgs>
    notifications?: boolean | ProcessingLog$notificationsArgs<ExtArgs>
    _count?: boolean | ProcessingLogCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcessingLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessingLog"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      processType: $Enums.ProcessType
      equipment: string | null
      duration: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
      fieldId: string
    }, ExtArgs["result"]["processingLog"]>
    composites: {}
  }

  type ProcessingLogGetPayload<S extends boolean | null | undefined | ProcessingLogDefaultArgs> = $Result.GetResult<Prisma.$ProcessingLogPayload, S>

  type ProcessingLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessingLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessingLogCountAggregateInputType | true
    }

  export interface ProcessingLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessingLog'], meta: { name: 'ProcessingLog' } }
    /**
     * Find zero or one ProcessingLog that matches the filter.
     * @param {ProcessingLogFindUniqueArgs} args - Arguments to find a ProcessingLog
     * @example
     * // Get one ProcessingLog
     * const processingLog = await prisma.processingLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessingLogFindUniqueArgs>(args: SelectSubset<T, ProcessingLogFindUniqueArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessingLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessingLogFindUniqueOrThrowArgs} args - Arguments to find a ProcessingLog
     * @example
     * // Get one ProcessingLog
     * const processingLog = await prisma.processingLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessingLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessingLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessingLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogFindFirstArgs} args - Arguments to find a ProcessingLog
     * @example
     * // Get one ProcessingLog
     * const processingLog = await prisma.processingLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessingLogFindFirstArgs>(args?: SelectSubset<T, ProcessingLogFindFirstArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessingLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogFindFirstOrThrowArgs} args - Arguments to find a ProcessingLog
     * @example
     * // Get one ProcessingLog
     * const processingLog = await prisma.processingLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessingLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessingLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessingLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessingLogs
     * const processingLogs = await prisma.processingLog.findMany()
     * 
     * // Get first 10 ProcessingLogs
     * const processingLogs = await prisma.processingLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processingLogWithIdOnly = await prisma.processingLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessingLogFindManyArgs>(args?: SelectSubset<T, ProcessingLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessingLog.
     * @param {ProcessingLogCreateArgs} args - Arguments to create a ProcessingLog.
     * @example
     * // Create one ProcessingLog
     * const ProcessingLog = await prisma.processingLog.create({
     *   data: {
     *     // ... data to create a ProcessingLog
     *   }
     * })
     * 
     */
    create<T extends ProcessingLogCreateArgs>(args: SelectSubset<T, ProcessingLogCreateArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessingLogs.
     * @param {ProcessingLogCreateManyArgs} args - Arguments to create many ProcessingLogs.
     * @example
     * // Create many ProcessingLogs
     * const processingLog = await prisma.processingLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessingLogCreateManyArgs>(args?: SelectSubset<T, ProcessingLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessingLog.
     * @param {ProcessingLogDeleteArgs} args - Arguments to delete one ProcessingLog.
     * @example
     * // Delete one ProcessingLog
     * const ProcessingLog = await prisma.processingLog.delete({
     *   where: {
     *     // ... filter to delete one ProcessingLog
     *   }
     * })
     * 
     */
    delete<T extends ProcessingLogDeleteArgs>(args: SelectSubset<T, ProcessingLogDeleteArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessingLog.
     * @param {ProcessingLogUpdateArgs} args - Arguments to update one ProcessingLog.
     * @example
     * // Update one ProcessingLog
     * const processingLog = await prisma.processingLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessingLogUpdateArgs>(args: SelectSubset<T, ProcessingLogUpdateArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessingLogs.
     * @param {ProcessingLogDeleteManyArgs} args - Arguments to filter ProcessingLogs to delete.
     * @example
     * // Delete a few ProcessingLogs
     * const { count } = await prisma.processingLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessingLogDeleteManyArgs>(args?: SelectSubset<T, ProcessingLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessingLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessingLogs
     * const processingLog = await prisma.processingLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessingLogUpdateManyArgs>(args: SelectSubset<T, ProcessingLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessingLog.
     * @param {ProcessingLogUpsertArgs} args - Arguments to update or create a ProcessingLog.
     * @example
     * // Update or create a ProcessingLog
     * const processingLog = await prisma.processingLog.upsert({
     *   create: {
     *     // ... data to create a ProcessingLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessingLog we want to update
     *   }
     * })
     */
    upsert<T extends ProcessingLogUpsertArgs>(args: SelectSubset<T, ProcessingLogUpsertArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessingLogs that matches the filter.
     * @param {ProcessingLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const processingLog = await prisma.processingLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProcessingLogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProcessingLog.
     * @param {ProcessingLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const processingLog = await prisma.processingLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProcessingLogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProcessingLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogCountArgs} args - Arguments to filter ProcessingLogs to count.
     * @example
     * // Count the number of ProcessingLogs
     * const count = await prisma.processingLog.count({
     *   where: {
     *     // ... the filter for the ProcessingLogs we want to count
     *   }
     * })
    **/
    count<T extends ProcessingLogCountArgs>(
      args?: Subset<T, ProcessingLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessingLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessingLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessingLogAggregateArgs>(args: Subset<T, ProcessingLogAggregateArgs>): Prisma.PrismaPromise<GetProcessingLogAggregateType<T>>

    /**
     * Group by ProcessingLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessingLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessingLogGroupByArgs['orderBy'] }
        : { orderBy?: ProcessingLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessingLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessingLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessingLog model
   */
  readonly fields: ProcessingLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessingLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessingLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends ProcessingLog$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessingLog$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessingLog model
   */
  interface ProcessingLogFieldRefs {
    readonly id: FieldRef<"ProcessingLog", 'String'>
    readonly date: FieldRef<"ProcessingLog", 'DateTime'>
    readonly processType: FieldRef<"ProcessingLog", 'ProcessType'>
    readonly equipment: FieldRef<"ProcessingLog", 'String'>
    readonly duration: FieldRef<"ProcessingLog", 'Float'>
    readonly notes: FieldRef<"ProcessingLog", 'String'>
    readonly createdAt: FieldRef<"ProcessingLog", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessingLog", 'DateTime'>
    readonly fieldId: FieldRef<"ProcessingLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessingLog findUnique
   */
  export type ProcessingLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingLog to fetch.
     */
    where: ProcessingLogWhereUniqueInput
  }

  /**
   * ProcessingLog findUniqueOrThrow
   */
  export type ProcessingLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingLog to fetch.
     */
    where: ProcessingLogWhereUniqueInput
  }

  /**
   * ProcessingLog findFirst
   */
  export type ProcessingLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingLog to fetch.
     */
    where?: ProcessingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingLogs to fetch.
     */
    orderBy?: ProcessingLogOrderByWithRelationInput | ProcessingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingLogs.
     */
    cursor?: ProcessingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingLogs.
     */
    distinct?: ProcessingLogScalarFieldEnum | ProcessingLogScalarFieldEnum[]
  }

  /**
   * ProcessingLog findFirstOrThrow
   */
  export type ProcessingLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingLog to fetch.
     */
    where?: ProcessingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingLogs to fetch.
     */
    orderBy?: ProcessingLogOrderByWithRelationInput | ProcessingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessingLogs.
     */
    cursor?: ProcessingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessingLogs.
     */
    distinct?: ProcessingLogScalarFieldEnum | ProcessingLogScalarFieldEnum[]
  }

  /**
   * ProcessingLog findMany
   */
  export type ProcessingLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * Filter, which ProcessingLogs to fetch.
     */
    where?: ProcessingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessingLogs to fetch.
     */
    orderBy?: ProcessingLogOrderByWithRelationInput | ProcessingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessingLogs.
     */
    cursor?: ProcessingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessingLogs.
     */
    skip?: number
    distinct?: ProcessingLogScalarFieldEnum | ProcessingLogScalarFieldEnum[]
  }

  /**
   * ProcessingLog create
   */
  export type ProcessingLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessingLog.
     */
    data: XOR<ProcessingLogCreateInput, ProcessingLogUncheckedCreateInput>
  }

  /**
   * ProcessingLog createMany
   */
  export type ProcessingLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessingLogs.
     */
    data: ProcessingLogCreateManyInput | ProcessingLogCreateManyInput[]
  }

  /**
   * ProcessingLog update
   */
  export type ProcessingLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessingLog.
     */
    data: XOR<ProcessingLogUpdateInput, ProcessingLogUncheckedUpdateInput>
    /**
     * Choose, which ProcessingLog to update.
     */
    where: ProcessingLogWhereUniqueInput
  }

  /**
   * ProcessingLog updateMany
   */
  export type ProcessingLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessingLogs.
     */
    data: XOR<ProcessingLogUpdateManyMutationInput, ProcessingLogUncheckedUpdateManyInput>
    /**
     * Filter which ProcessingLogs to update
     */
    where?: ProcessingLogWhereInput
    /**
     * Limit how many ProcessingLogs to update.
     */
    limit?: number
  }

  /**
   * ProcessingLog upsert
   */
  export type ProcessingLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessingLog to update in case it exists.
     */
    where: ProcessingLogWhereUniqueInput
    /**
     * In case the ProcessingLog found by the `where` argument doesn't exist, create a new ProcessingLog with this data.
     */
    create: XOR<ProcessingLogCreateInput, ProcessingLogUncheckedCreateInput>
    /**
     * In case the ProcessingLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessingLogUpdateInput, ProcessingLogUncheckedUpdateInput>
  }

  /**
   * ProcessingLog delete
   */
  export type ProcessingLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    /**
     * Filter which ProcessingLog to delete.
     */
    where: ProcessingLogWhereUniqueInput
  }

  /**
   * ProcessingLog deleteMany
   */
  export type ProcessingLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessingLogs to delete
     */
    where?: ProcessingLogWhereInput
    /**
     * Limit how many ProcessingLogs to delete.
     */
    limit?: number
  }

  /**
   * ProcessingLog findRaw
   */
  export type ProcessingLogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProcessingLog aggregateRaw
   */
  export type ProcessingLogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProcessingLog.notifications
   */
  export type ProcessingLog$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * ProcessingLog without action
   */
  export type ProcessingLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    totalQuantity: number | null
    totalStock: number | null
    costPrice: number | null
  }

  export type InventorySumAggregateOutputType = {
    totalQuantity: number | null
    totalStock: number | null
    costPrice: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.InventoryCategory | null
    totalQuantity: number | null
    unit: $Enums.Unit | null
    totalStock: number | null
    purchaseDate: Date | null
    expiryDate: Date | null
    status: $Enums.InventoryStatus | null
    costPrice: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.InventoryCategory | null
    totalQuantity: number | null
    unit: $Enums.Unit | null
    totalStock: number | null
    purchaseDate: Date | null
    expiryDate: Date | null
    status: $Enums.InventoryStatus | null
    costPrice: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    name: number
    category: number
    totalQuantity: number
    unit: number
    totalStock: number
    purchaseDate: number
    expiryDate: number
    status: number
    costPrice: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    totalQuantity?: true
    totalStock?: true
    costPrice?: true
  }

  export type InventorySumAggregateInputType = {
    totalQuantity?: true
    totalStock?: true
    costPrice?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    totalQuantity?: true
    unit?: true
    totalStock?: true
    purchaseDate?: true
    expiryDate?: true
    status?: true
    costPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    totalQuantity?: true
    unit?: true
    totalStock?: true
    purchaseDate?: true
    expiryDate?: true
    status?: true
    costPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    totalQuantity?: true
    unit?: true
    totalStock?: true
    purchaseDate?: true
    expiryDate?: true
    status?: true
    costPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit: $Enums.Unit
    totalStock: number | null
    purchaseDate: Date | null
    expiryDate: Date | null
    status: $Enums.InventoryStatus
    costPrice: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    totalQuantity?: boolean
    unit?: boolean
    totalStock?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    status?: boolean
    costPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerships?: boolean | Inventory$ownershipsArgs<ExtArgs>
    usages?: boolean | Inventory$usagesArgs<ExtArgs>
    inventoryTransactions?: boolean | Inventory$inventoryTransactionsArgs<ExtArgs>
    notifications?: boolean | Inventory$notificationsArgs<ExtArgs>
    irrigationInventoryUsages?: boolean | Inventory$irrigationInventoryUsagesArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>



  export type InventorySelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    totalQuantity?: boolean
    unit?: boolean
    totalStock?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    status?: boolean
    costPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "totalQuantity" | "unit" | "totalStock" | "purchaseDate" | "expiryDate" | "status" | "costPrice" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerships?: boolean | Inventory$ownershipsArgs<ExtArgs>
    usages?: boolean | Inventory$usagesArgs<ExtArgs>
    inventoryTransactions?: boolean | Inventory$inventoryTransactionsArgs<ExtArgs>
    notifications?: boolean | Inventory$notificationsArgs<ExtArgs>
    irrigationInventoryUsages?: boolean | Inventory$irrigationInventoryUsagesArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      ownerships: Prisma.$InventoryOwnershipPayload<ExtArgs>[]
      usages: Prisma.$InventoryUsagePayload<ExtArgs>[]
      inventoryTransactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      irrigationInventoryUsages: Prisma.$IrrigationInventoryUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.InventoryCategory
      totalQuantity: number
      unit: $Enums.Unit
      totalStock: number | null
      purchaseDate: Date | null
      expiryDate: Date | null
      status: $Enums.InventoryStatus
      costPrice: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * @param {InventoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const inventory = await prisma.inventory.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InventoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Inventory.
     * @param {InventoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const inventory = await prisma.inventory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InventoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownerships<T extends Inventory$ownershipsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$ownershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usages<T extends Inventory$usagesArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryTransactions<T extends Inventory$inventoryTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$inventoryTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Inventory$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    irrigationInventoryUsages<T extends Inventory$irrigationInventoryUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$irrigationInventoryUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly category: FieldRef<"Inventory", 'InventoryCategory'>
    readonly totalQuantity: FieldRef<"Inventory", 'Float'>
    readonly unit: FieldRef<"Inventory", 'Unit'>
    readonly totalStock: FieldRef<"Inventory", 'Float'>
    readonly purchaseDate: FieldRef<"Inventory", 'DateTime'>
    readonly expiryDate: FieldRef<"Inventory", 'DateTime'>
    readonly status: FieldRef<"Inventory", 'InventoryStatus'>
    readonly costPrice: FieldRef<"Inventory", 'Float'>
    readonly notes: FieldRef<"Inventory", 'String'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory findRaw
   */
  export type InventoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Inventory aggregateRaw
   */
  export type InventoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Inventory.ownerships
   */
  export type Inventory$ownershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    where?: InventoryOwnershipWhereInput
    orderBy?: InventoryOwnershipOrderByWithRelationInput | InventoryOwnershipOrderByWithRelationInput[]
    cursor?: InventoryOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryOwnershipScalarFieldEnum | InventoryOwnershipScalarFieldEnum[]
  }

  /**
   * Inventory.usages
   */
  export type Inventory$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    cursor?: InventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * Inventory.inventoryTransactions
   */
  export type Inventory$inventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Inventory.notifications
   */
  export type Inventory$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Inventory.irrigationInventoryUsages
   */
  export type Inventory$irrigationInventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    where?: IrrigationInventoryUsageWhereInput
    orderBy?: IrrigationInventoryUsageOrderByWithRelationInput | IrrigationInventoryUsageOrderByWithRelationInput[]
    cursor?: IrrigationInventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationInventoryUsageScalarFieldEnum | IrrigationInventoryUsageScalarFieldEnum[]
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryOwnership
   */

  export type AggregateInventoryOwnership = {
    _count: InventoryOwnershipCountAggregateOutputType | null
    _avg: InventoryOwnershipAvgAggregateOutputType | null
    _sum: InventoryOwnershipSumAggregateOutputType | null
    _min: InventoryOwnershipMinAggregateOutputType | null
    _max: InventoryOwnershipMaxAggregateOutputType | null
  }

  export type InventoryOwnershipAvgAggregateOutputType = {
    shareQuantity: number | null
  }

  export type InventoryOwnershipSumAggregateOutputType = {
    shareQuantity: number | null
  }

  export type InventoryOwnershipMinAggregateOutputType = {
    id: string | null
    inventoryId: string | null
    userId: string | null
    shareQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryOwnershipMaxAggregateOutputType = {
    id: string | null
    inventoryId: string | null
    userId: string | null
    shareQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryOwnershipCountAggregateOutputType = {
    id: number
    inventoryId: number
    userId: number
    shareQuantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryOwnershipAvgAggregateInputType = {
    shareQuantity?: true
  }

  export type InventoryOwnershipSumAggregateInputType = {
    shareQuantity?: true
  }

  export type InventoryOwnershipMinAggregateInputType = {
    id?: true
    inventoryId?: true
    userId?: true
    shareQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryOwnershipMaxAggregateInputType = {
    id?: true
    inventoryId?: true
    userId?: true
    shareQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryOwnershipCountAggregateInputType = {
    id?: true
    inventoryId?: true
    userId?: true
    shareQuantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryOwnershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryOwnership to aggregate.
     */
    where?: InventoryOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryOwnerships to fetch.
     */
    orderBy?: InventoryOwnershipOrderByWithRelationInput | InventoryOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryOwnerships
    **/
    _count?: true | InventoryOwnershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryOwnershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryOwnershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryOwnershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryOwnershipMaxAggregateInputType
  }

  export type GetInventoryOwnershipAggregateType<T extends InventoryOwnershipAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryOwnership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryOwnership[P]>
      : GetScalarType<T[P], AggregateInventoryOwnership[P]>
  }




  export type InventoryOwnershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryOwnershipWhereInput
    orderBy?: InventoryOwnershipOrderByWithAggregationInput | InventoryOwnershipOrderByWithAggregationInput[]
    by: InventoryOwnershipScalarFieldEnum[] | InventoryOwnershipScalarFieldEnum
    having?: InventoryOwnershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryOwnershipCountAggregateInputType | true
    _avg?: InventoryOwnershipAvgAggregateInputType
    _sum?: InventoryOwnershipSumAggregateInputType
    _min?: InventoryOwnershipMinAggregateInputType
    _max?: InventoryOwnershipMaxAggregateInputType
  }

  export type InventoryOwnershipGroupByOutputType = {
    id: string
    inventoryId: string
    userId: string
    shareQuantity: number
    createdAt: Date
    updatedAt: Date
    _count: InventoryOwnershipCountAggregateOutputType | null
    _avg: InventoryOwnershipAvgAggregateOutputType | null
    _sum: InventoryOwnershipSumAggregateOutputType | null
    _min: InventoryOwnershipMinAggregateOutputType | null
    _max: InventoryOwnershipMaxAggregateOutputType | null
  }

  type GetInventoryOwnershipGroupByPayload<T extends InventoryOwnershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryOwnershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryOwnershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryOwnershipGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryOwnershipGroupByOutputType[P]>
        }
      >
    >


  export type InventoryOwnershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    userId?: boolean
    shareQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryOwnership"]>



  export type InventoryOwnershipSelectScalar = {
    id?: boolean
    inventoryId?: boolean
    userId?: boolean
    shareQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOwnershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventoryId" | "userId" | "shareQuantity" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryOwnership"]>
  export type InventoryOwnershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventoryOwnershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryOwnership"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventoryId: string
      userId: string
      shareQuantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryOwnership"]>
    composites: {}
  }

  type InventoryOwnershipGetPayload<S extends boolean | null | undefined | InventoryOwnershipDefaultArgs> = $Result.GetResult<Prisma.$InventoryOwnershipPayload, S>

  type InventoryOwnershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryOwnershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryOwnershipCountAggregateInputType | true
    }

  export interface InventoryOwnershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryOwnership'], meta: { name: 'InventoryOwnership' } }
    /**
     * Find zero or one InventoryOwnership that matches the filter.
     * @param {InventoryOwnershipFindUniqueArgs} args - Arguments to find a InventoryOwnership
     * @example
     * // Get one InventoryOwnership
     * const inventoryOwnership = await prisma.inventoryOwnership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryOwnershipFindUniqueArgs>(args: SelectSubset<T, InventoryOwnershipFindUniqueArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryOwnership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryOwnershipFindUniqueOrThrowArgs} args - Arguments to find a InventoryOwnership
     * @example
     * // Get one InventoryOwnership
     * const inventoryOwnership = await prisma.inventoryOwnership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryOwnershipFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryOwnershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryOwnership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipFindFirstArgs} args - Arguments to find a InventoryOwnership
     * @example
     * // Get one InventoryOwnership
     * const inventoryOwnership = await prisma.inventoryOwnership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryOwnershipFindFirstArgs>(args?: SelectSubset<T, InventoryOwnershipFindFirstArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryOwnership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipFindFirstOrThrowArgs} args - Arguments to find a InventoryOwnership
     * @example
     * // Get one InventoryOwnership
     * const inventoryOwnership = await prisma.inventoryOwnership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryOwnershipFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryOwnershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryOwnerships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryOwnerships
     * const inventoryOwnerships = await prisma.inventoryOwnership.findMany()
     * 
     * // Get first 10 InventoryOwnerships
     * const inventoryOwnerships = await prisma.inventoryOwnership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryOwnershipWithIdOnly = await prisma.inventoryOwnership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryOwnershipFindManyArgs>(args?: SelectSubset<T, InventoryOwnershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryOwnership.
     * @param {InventoryOwnershipCreateArgs} args - Arguments to create a InventoryOwnership.
     * @example
     * // Create one InventoryOwnership
     * const InventoryOwnership = await prisma.inventoryOwnership.create({
     *   data: {
     *     // ... data to create a InventoryOwnership
     *   }
     * })
     * 
     */
    create<T extends InventoryOwnershipCreateArgs>(args: SelectSubset<T, InventoryOwnershipCreateArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryOwnerships.
     * @param {InventoryOwnershipCreateManyArgs} args - Arguments to create many InventoryOwnerships.
     * @example
     * // Create many InventoryOwnerships
     * const inventoryOwnership = await prisma.inventoryOwnership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryOwnershipCreateManyArgs>(args?: SelectSubset<T, InventoryOwnershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryOwnership.
     * @param {InventoryOwnershipDeleteArgs} args - Arguments to delete one InventoryOwnership.
     * @example
     * // Delete one InventoryOwnership
     * const InventoryOwnership = await prisma.inventoryOwnership.delete({
     *   where: {
     *     // ... filter to delete one InventoryOwnership
     *   }
     * })
     * 
     */
    delete<T extends InventoryOwnershipDeleteArgs>(args: SelectSubset<T, InventoryOwnershipDeleteArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryOwnership.
     * @param {InventoryOwnershipUpdateArgs} args - Arguments to update one InventoryOwnership.
     * @example
     * // Update one InventoryOwnership
     * const inventoryOwnership = await prisma.inventoryOwnership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryOwnershipUpdateArgs>(args: SelectSubset<T, InventoryOwnershipUpdateArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryOwnerships.
     * @param {InventoryOwnershipDeleteManyArgs} args - Arguments to filter InventoryOwnerships to delete.
     * @example
     * // Delete a few InventoryOwnerships
     * const { count } = await prisma.inventoryOwnership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryOwnershipDeleteManyArgs>(args?: SelectSubset<T, InventoryOwnershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryOwnerships
     * const inventoryOwnership = await prisma.inventoryOwnership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryOwnershipUpdateManyArgs>(args: SelectSubset<T, InventoryOwnershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryOwnership.
     * @param {InventoryOwnershipUpsertArgs} args - Arguments to update or create a InventoryOwnership.
     * @example
     * // Update or create a InventoryOwnership
     * const inventoryOwnership = await prisma.inventoryOwnership.upsert({
     *   create: {
     *     // ... data to create a InventoryOwnership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryOwnership we want to update
     *   }
     * })
     */
    upsert<T extends InventoryOwnershipUpsertArgs>(args: SelectSubset<T, InventoryOwnershipUpsertArgs<ExtArgs>>): Prisma__InventoryOwnershipClient<$Result.GetResult<Prisma.$InventoryOwnershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryOwnerships that matches the filter.
     * @param {InventoryOwnershipFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const inventoryOwnership = await prisma.inventoryOwnership.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InventoryOwnershipFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a InventoryOwnership.
     * @param {InventoryOwnershipAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const inventoryOwnership = await prisma.inventoryOwnership.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InventoryOwnershipAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of InventoryOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipCountArgs} args - Arguments to filter InventoryOwnerships to count.
     * @example
     * // Count the number of InventoryOwnerships
     * const count = await prisma.inventoryOwnership.count({
     *   where: {
     *     // ... the filter for the InventoryOwnerships we want to count
     *   }
     * })
    **/
    count<T extends InventoryOwnershipCountArgs>(
      args?: Subset<T, InventoryOwnershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryOwnershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryOwnershipAggregateArgs>(args: Subset<T, InventoryOwnershipAggregateArgs>): Prisma.PrismaPromise<GetInventoryOwnershipAggregateType<T>>

    /**
     * Group by InventoryOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryOwnershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryOwnershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryOwnershipGroupByArgs['orderBy'] }
        : { orderBy?: InventoryOwnershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryOwnershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryOwnershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryOwnership model
   */
  readonly fields: InventoryOwnershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryOwnership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryOwnershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryOwnership model
   */
  interface InventoryOwnershipFieldRefs {
    readonly id: FieldRef<"InventoryOwnership", 'String'>
    readonly inventoryId: FieldRef<"InventoryOwnership", 'String'>
    readonly userId: FieldRef<"InventoryOwnership", 'String'>
    readonly shareQuantity: FieldRef<"InventoryOwnership", 'Float'>
    readonly createdAt: FieldRef<"InventoryOwnership", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryOwnership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryOwnership findUnique
   */
  export type InventoryOwnershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which InventoryOwnership to fetch.
     */
    where: InventoryOwnershipWhereUniqueInput
  }

  /**
   * InventoryOwnership findUniqueOrThrow
   */
  export type InventoryOwnershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which InventoryOwnership to fetch.
     */
    where: InventoryOwnershipWhereUniqueInput
  }

  /**
   * InventoryOwnership findFirst
   */
  export type InventoryOwnershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which InventoryOwnership to fetch.
     */
    where?: InventoryOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryOwnerships to fetch.
     */
    orderBy?: InventoryOwnershipOrderByWithRelationInput | InventoryOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryOwnerships.
     */
    cursor?: InventoryOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryOwnerships.
     */
    distinct?: InventoryOwnershipScalarFieldEnum | InventoryOwnershipScalarFieldEnum[]
  }

  /**
   * InventoryOwnership findFirstOrThrow
   */
  export type InventoryOwnershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which InventoryOwnership to fetch.
     */
    where?: InventoryOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryOwnerships to fetch.
     */
    orderBy?: InventoryOwnershipOrderByWithRelationInput | InventoryOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryOwnerships.
     */
    cursor?: InventoryOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryOwnerships.
     */
    distinct?: InventoryOwnershipScalarFieldEnum | InventoryOwnershipScalarFieldEnum[]
  }

  /**
   * InventoryOwnership findMany
   */
  export type InventoryOwnershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which InventoryOwnerships to fetch.
     */
    where?: InventoryOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryOwnerships to fetch.
     */
    orderBy?: InventoryOwnershipOrderByWithRelationInput | InventoryOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryOwnerships.
     */
    cursor?: InventoryOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryOwnerships.
     */
    skip?: number
    distinct?: InventoryOwnershipScalarFieldEnum | InventoryOwnershipScalarFieldEnum[]
  }

  /**
   * InventoryOwnership create
   */
  export type InventoryOwnershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryOwnership.
     */
    data: XOR<InventoryOwnershipCreateInput, InventoryOwnershipUncheckedCreateInput>
  }

  /**
   * InventoryOwnership createMany
   */
  export type InventoryOwnershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryOwnerships.
     */
    data: InventoryOwnershipCreateManyInput | InventoryOwnershipCreateManyInput[]
  }

  /**
   * InventoryOwnership update
   */
  export type InventoryOwnershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryOwnership.
     */
    data: XOR<InventoryOwnershipUpdateInput, InventoryOwnershipUncheckedUpdateInput>
    /**
     * Choose, which InventoryOwnership to update.
     */
    where: InventoryOwnershipWhereUniqueInput
  }

  /**
   * InventoryOwnership updateMany
   */
  export type InventoryOwnershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryOwnerships.
     */
    data: XOR<InventoryOwnershipUpdateManyMutationInput, InventoryOwnershipUncheckedUpdateManyInput>
    /**
     * Filter which InventoryOwnerships to update
     */
    where?: InventoryOwnershipWhereInput
    /**
     * Limit how many InventoryOwnerships to update.
     */
    limit?: number
  }

  /**
   * InventoryOwnership upsert
   */
  export type InventoryOwnershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryOwnership to update in case it exists.
     */
    where: InventoryOwnershipWhereUniqueInput
    /**
     * In case the InventoryOwnership found by the `where` argument doesn't exist, create a new InventoryOwnership with this data.
     */
    create: XOR<InventoryOwnershipCreateInput, InventoryOwnershipUncheckedCreateInput>
    /**
     * In case the InventoryOwnership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryOwnershipUpdateInput, InventoryOwnershipUncheckedUpdateInput>
  }

  /**
   * InventoryOwnership delete
   */
  export type InventoryOwnershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
    /**
     * Filter which InventoryOwnership to delete.
     */
    where: InventoryOwnershipWhereUniqueInput
  }

  /**
   * InventoryOwnership deleteMany
   */
  export type InventoryOwnershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryOwnerships to delete
     */
    where?: InventoryOwnershipWhereInput
    /**
     * Limit how many InventoryOwnerships to delete.
     */
    limit?: number
  }

  /**
   * InventoryOwnership findRaw
   */
  export type InventoryOwnershipFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InventoryOwnership aggregateRaw
   */
  export type InventoryOwnershipAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InventoryOwnership without action
   */
  export type InventoryOwnershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryOwnership
     */
    select?: InventoryOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryOwnership
     */
    omit?: InventoryOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryOwnershipInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalCost: number | null
    approvalThreshold: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalCost: number | null
    approvalThreshold: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    product: string | null
    category: $Enums.ProductCategory | null
    quantity: number | null
    unit: $Enums.Unit | null
    unitPrice: number | null
    totalCost: number | null
    paymentMethod: $Enums.PaymentMethod | null
    creditorPaymentDueDate: Date | null
    dueDate: Date | null
    description: string | null
    createdAt: Date | null
    isTemplate: boolean | null
    templateName: string | null
    approvalStatus: $Enums.ApprovalStatus | null
    approvalRequired: boolean | null
    approvalThreshold: number | null
    seasonId: string | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    product: string | null
    category: $Enums.ProductCategory | null
    quantity: number | null
    unit: $Enums.Unit | null
    unitPrice: number | null
    totalCost: number | null
    paymentMethod: $Enums.PaymentMethod | null
    creditorPaymentDueDate: Date | null
    dueDate: Date | null
    description: string | null
    createdAt: Date | null
    isTemplate: boolean | null
    templateName: string | null
    approvalStatus: $Enums.ApprovalStatus | null
    approvalRequired: boolean | null
    approvalThreshold: number | null
    seasonId: string | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    product: number
    category: number
    quantity: number
    unit: number
    unitPrice: number
    totalCost: number
    paymentMethod: number
    creditorPaymentDueDate: number
    dueDate: number
    description: number
    createdAt: number
    isTemplate: number
    templateName: number
    approvalStatus: number
    approvalRequired: number
    approvalThreshold: number
    seasonId: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
    approvalThreshold?: true
  }

  export type PurchaseSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
    approvalThreshold?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    product?: true
    category?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalCost?: true
    paymentMethod?: true
    creditorPaymentDueDate?: true
    dueDate?: true
    description?: true
    createdAt?: true
    isTemplate?: true
    templateName?: true
    approvalStatus?: true
    approvalRequired?: true
    approvalThreshold?: true
    seasonId?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    product?: true
    category?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalCost?: true
    paymentMethod?: true
    creditorPaymentDueDate?: true
    dueDate?: true
    description?: true
    createdAt?: true
    isTemplate?: true
    templateName?: true
    approvalStatus?: true
    approvalRequired?: true
    approvalThreshold?: true
    seasonId?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    product?: true
    category?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalCost?: true
    paymentMethod?: true
    creditorPaymentDueDate?: true
    dueDate?: true
    description?: true
    createdAt?: true
    isTemplate?: true
    templateName?: true
    approvalStatus?: true
    approvalRequired?: true
    approvalThreshold?: true
    seasonId?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    product: string
    category: $Enums.ProductCategory
    quantity: number
    unit: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate: Date | null
    dueDate: Date | null
    description: string | null
    createdAt: Date
    isTemplate: boolean
    templateName: string | null
    approvalStatus: $Enums.ApprovalStatus
    approvalRequired: boolean
    approvalThreshold: number
    seasonId: string | null
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product?: boolean
    category?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    paymentMethod?: boolean
    creditorPaymentDueDate?: boolean
    dueDate?: boolean
    description?: boolean
    createdAt?: boolean
    isTemplate?: boolean
    templateName?: boolean
    approvalStatus?: boolean
    approvalRequired?: boolean
    approvalThreshold?: boolean
    seasonId?: boolean
    season?: boolean | Purchase$seasonArgs<ExtArgs>
    contributors?: boolean | Purchase$contributorsArgs<ExtArgs>
    debts?: boolean | Purchase$debtsArgs<ExtArgs>
    invoices?: boolean | Purchase$invoicesArgs<ExtArgs>
    inventoryTransactions?: boolean | Purchase$inventoryTransactionsArgs<ExtArgs>
    approvals?: boolean | Purchase$approvalsArgs<ExtArgs>
    notifications?: boolean | Purchase$notificationsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>



  export type PurchaseSelectScalar = {
    id?: boolean
    product?: boolean
    category?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    paymentMethod?: boolean
    creditorPaymentDueDate?: boolean
    dueDate?: boolean
    description?: boolean
    createdAt?: boolean
    isTemplate?: boolean
    templateName?: boolean
    approvalStatus?: boolean
    approvalRequired?: boolean
    approvalThreshold?: boolean
    seasonId?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product" | "category" | "quantity" | "unit" | "unitPrice" | "totalCost" | "paymentMethod" | "creditorPaymentDueDate" | "dueDate" | "description" | "createdAt" | "isTemplate" | "templateName" | "approvalStatus" | "approvalRequired" | "approvalThreshold" | "seasonId", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | Purchase$seasonArgs<ExtArgs>
    contributors?: boolean | Purchase$contributorsArgs<ExtArgs>
    debts?: boolean | Purchase$debtsArgs<ExtArgs>
    invoices?: boolean | Purchase$invoicesArgs<ExtArgs>
    inventoryTransactions?: boolean | Purchase$inventoryTransactionsArgs<ExtArgs>
    approvals?: boolean | Purchase$approvalsArgs<ExtArgs>
    notifications?: boolean | Purchase$notificationsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      season: Prisma.$SeasonPayload<ExtArgs> | null
      contributors: Prisma.$PurchaseContributorPayload<ExtArgs>[]
      debts: Prisma.$DebtPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      inventoryTransactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      approvals: Prisma.$PurchaseApprovalPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      product: string
      category: $Enums.ProductCategory
      quantity: number
      unit: $Enums.Unit
      unitPrice: number
      totalCost: number
      paymentMethod: $Enums.PaymentMethod
      creditorPaymentDueDate: Date | null
      dueDate: Date | null
      description: string | null
      createdAt: Date
      isTemplate: boolean
      templateName: string | null
      approvalStatus: $Enums.ApprovalStatus
      approvalRequired: boolean
      approvalThreshold: number
      seasonId: string | null
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * @param {PurchaseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const purchase = await prisma.purchase.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PurchaseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Purchase.
     * @param {PurchaseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const purchase = await prisma.purchase.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PurchaseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    season<T extends Purchase$seasonArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contributors<T extends Purchase$contributorsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$contributorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debts<T extends Purchase$debtsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$debtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Purchase$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryTransactions<T extends Purchase$inventoryTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$inventoryTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvals<T extends Purchase$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Purchase$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly product: FieldRef<"Purchase", 'String'>
    readonly category: FieldRef<"Purchase", 'ProductCategory'>
    readonly quantity: FieldRef<"Purchase", 'Float'>
    readonly unit: FieldRef<"Purchase", 'Unit'>
    readonly unitPrice: FieldRef<"Purchase", 'Float'>
    readonly totalCost: FieldRef<"Purchase", 'Float'>
    readonly paymentMethod: FieldRef<"Purchase", 'PaymentMethod'>
    readonly creditorPaymentDueDate: FieldRef<"Purchase", 'DateTime'>
    readonly dueDate: FieldRef<"Purchase", 'DateTime'>
    readonly description: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly isTemplate: FieldRef<"Purchase", 'Boolean'>
    readonly templateName: FieldRef<"Purchase", 'String'>
    readonly approvalStatus: FieldRef<"Purchase", 'ApprovalStatus'>
    readonly approvalRequired: FieldRef<"Purchase", 'Boolean'>
    readonly approvalThreshold: FieldRef<"Purchase", 'Float'>
    readonly seasonId: FieldRef<"Purchase", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase findRaw
   */
  export type PurchaseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Purchase aggregateRaw
   */
  export type PurchaseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Purchase.season
   */
  export type Purchase$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * Purchase.contributors
   */
  export type Purchase$contributorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    where?: PurchaseContributorWhereInput
    orderBy?: PurchaseContributorOrderByWithRelationInput | PurchaseContributorOrderByWithRelationInput[]
    cursor?: PurchaseContributorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseContributorScalarFieldEnum | PurchaseContributorScalarFieldEnum[]
  }

  /**
   * Purchase.debts
   */
  export type Purchase$debtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    cursor?: DebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Purchase.invoices
   */
  export type Purchase$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Purchase.inventoryTransactions
   */
  export type Purchase$inventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Purchase.approvals
   */
  export type Purchase$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    where?: PurchaseApprovalWhereInput
    orderBy?: PurchaseApprovalOrderByWithRelationInput | PurchaseApprovalOrderByWithRelationInput[]
    cursor?: PurchaseApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseApprovalScalarFieldEnum | PurchaseApprovalScalarFieldEnum[]
  }

  /**
   * Purchase.notifications
   */
  export type Purchase$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseApproval
   */

  export type AggregatePurchaseApproval = {
    _count: PurchaseApprovalCountAggregateOutputType | null
    _min: PurchaseApprovalMinAggregateOutputType | null
    _max: PurchaseApprovalMaxAggregateOutputType | null
  }

  export type PurchaseApprovalMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseApprovalMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseApprovalCountAggregateOutputType = {
    id: number
    purchaseId: number
    approverId: number
    status: number
    comment: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseApprovalMinAggregateInputType = {
    id?: true
    purchaseId?: true
    approverId?: true
    status?: true
    comment?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseApprovalMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    approverId?: true
    status?: true
    comment?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseApprovalCountAggregateInputType = {
    id?: true
    purchaseId?: true
    approverId?: true
    status?: true
    comment?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseApproval to aggregate.
     */
    where?: PurchaseApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseApprovals to fetch.
     */
    orderBy?: PurchaseApprovalOrderByWithRelationInput | PurchaseApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseApprovals
    **/
    _count?: true | PurchaseApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseApprovalMaxAggregateInputType
  }

  export type GetPurchaseApprovalAggregateType<T extends PurchaseApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseApproval[P]>
      : GetScalarType<T[P], AggregatePurchaseApproval[P]>
  }




  export type PurchaseApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseApprovalWhereInput
    orderBy?: PurchaseApprovalOrderByWithAggregationInput | PurchaseApprovalOrderByWithAggregationInput[]
    by: PurchaseApprovalScalarFieldEnum[] | PurchaseApprovalScalarFieldEnum
    having?: PurchaseApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseApprovalCountAggregateInputType | true
    _min?: PurchaseApprovalMinAggregateInputType
    _max?: PurchaseApprovalMaxAggregateInputType
  }

  export type PurchaseApprovalGroupByOutputType = {
    id: string
    purchaseId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseApprovalCountAggregateOutputType | null
    _min: PurchaseApprovalMinAggregateOutputType | null
    _max: PurchaseApprovalMaxAggregateOutputType | null
  }

  type GetPurchaseApprovalGroupByPayload<T extends PurchaseApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseApprovalGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | PurchaseApproval$notificationsArgs<ExtArgs>
    _count?: boolean | PurchaseApprovalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseApproval"]>



  export type PurchaseApprovalSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseId" | "approverId" | "status" | "comment" | "approvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseApproval"]>
  export type PurchaseApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | PurchaseApproval$notificationsArgs<ExtArgs>
    _count?: boolean | PurchaseApprovalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchaseApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseApproval"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      approverId: string
      status: $Enums.ApprovalStatus
      comment: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseApproval"]>
    composites: {}
  }

  type PurchaseApprovalGetPayload<S extends boolean | null | undefined | PurchaseApprovalDefaultArgs> = $Result.GetResult<Prisma.$PurchaseApprovalPayload, S>

  type PurchaseApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseApprovalCountAggregateInputType | true
    }

  export interface PurchaseApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseApproval'], meta: { name: 'PurchaseApproval' } }
    /**
     * Find zero or one PurchaseApproval that matches the filter.
     * @param {PurchaseApprovalFindUniqueArgs} args - Arguments to find a PurchaseApproval
     * @example
     * // Get one PurchaseApproval
     * const purchaseApproval = await prisma.purchaseApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseApprovalFindUniqueArgs>(args: SelectSubset<T, PurchaseApprovalFindUniqueArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseApproval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseApprovalFindUniqueOrThrowArgs} args - Arguments to find a PurchaseApproval
     * @example
     * // Get one PurchaseApproval
     * const purchaseApproval = await prisma.purchaseApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalFindFirstArgs} args - Arguments to find a PurchaseApproval
     * @example
     * // Get one PurchaseApproval
     * const purchaseApproval = await prisma.purchaseApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseApprovalFindFirstArgs>(args?: SelectSubset<T, PurchaseApprovalFindFirstArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalFindFirstOrThrowArgs} args - Arguments to find a PurchaseApproval
     * @example
     * // Get one PurchaseApproval
     * const purchaseApproval = await prisma.purchaseApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseApprovals
     * const purchaseApprovals = await prisma.purchaseApproval.findMany()
     * 
     * // Get first 10 PurchaseApprovals
     * const purchaseApprovals = await prisma.purchaseApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseApprovalWithIdOnly = await prisma.purchaseApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseApprovalFindManyArgs>(args?: SelectSubset<T, PurchaseApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseApproval.
     * @param {PurchaseApprovalCreateArgs} args - Arguments to create a PurchaseApproval.
     * @example
     * // Create one PurchaseApproval
     * const PurchaseApproval = await prisma.purchaseApproval.create({
     *   data: {
     *     // ... data to create a PurchaseApproval
     *   }
     * })
     * 
     */
    create<T extends PurchaseApprovalCreateArgs>(args: SelectSubset<T, PurchaseApprovalCreateArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseApprovals.
     * @param {PurchaseApprovalCreateManyArgs} args - Arguments to create many PurchaseApprovals.
     * @example
     * // Create many PurchaseApprovals
     * const purchaseApproval = await prisma.purchaseApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseApprovalCreateManyArgs>(args?: SelectSubset<T, PurchaseApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseApproval.
     * @param {PurchaseApprovalDeleteArgs} args - Arguments to delete one PurchaseApproval.
     * @example
     * // Delete one PurchaseApproval
     * const PurchaseApproval = await prisma.purchaseApproval.delete({
     *   where: {
     *     // ... filter to delete one PurchaseApproval
     *   }
     * })
     * 
     */
    delete<T extends PurchaseApprovalDeleteArgs>(args: SelectSubset<T, PurchaseApprovalDeleteArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseApproval.
     * @param {PurchaseApprovalUpdateArgs} args - Arguments to update one PurchaseApproval.
     * @example
     * // Update one PurchaseApproval
     * const purchaseApproval = await prisma.purchaseApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseApprovalUpdateArgs>(args: SelectSubset<T, PurchaseApprovalUpdateArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseApprovals.
     * @param {PurchaseApprovalDeleteManyArgs} args - Arguments to filter PurchaseApprovals to delete.
     * @example
     * // Delete a few PurchaseApprovals
     * const { count } = await prisma.purchaseApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseApprovalDeleteManyArgs>(args?: SelectSubset<T, PurchaseApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseApprovals
     * const purchaseApproval = await prisma.purchaseApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseApprovalUpdateManyArgs>(args: SelectSubset<T, PurchaseApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseApproval.
     * @param {PurchaseApprovalUpsertArgs} args - Arguments to update or create a PurchaseApproval.
     * @example
     * // Update or create a PurchaseApproval
     * const purchaseApproval = await prisma.purchaseApproval.upsert({
     *   create: {
     *     // ... data to create a PurchaseApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseApproval we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseApprovalUpsertArgs>(args: SelectSubset<T, PurchaseApprovalUpsertArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseApprovals that matches the filter.
     * @param {PurchaseApprovalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const purchaseApproval = await prisma.purchaseApproval.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PurchaseApprovalFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PurchaseApproval.
     * @param {PurchaseApprovalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const purchaseApproval = await prisma.purchaseApproval.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PurchaseApprovalAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PurchaseApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalCountArgs} args - Arguments to filter PurchaseApprovals to count.
     * @example
     * // Count the number of PurchaseApprovals
     * const count = await prisma.purchaseApproval.count({
     *   where: {
     *     // ... the filter for the PurchaseApprovals we want to count
     *   }
     * })
    **/
    count<T extends PurchaseApprovalCountArgs>(
      args?: Subset<T, PurchaseApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseApprovalAggregateArgs>(args: Subset<T, PurchaseApprovalAggregateArgs>): Prisma.PrismaPromise<GetPurchaseApprovalAggregateType<T>>

    /**
     * Group by PurchaseApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseApprovalGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseApproval model
   */
  readonly fields: PurchaseApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends PurchaseApproval$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseApproval$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseApproval model
   */
  interface PurchaseApprovalFieldRefs {
    readonly id: FieldRef<"PurchaseApproval", 'String'>
    readonly purchaseId: FieldRef<"PurchaseApproval", 'String'>
    readonly approverId: FieldRef<"PurchaseApproval", 'String'>
    readonly status: FieldRef<"PurchaseApproval", 'ApprovalStatus'>
    readonly comment: FieldRef<"PurchaseApproval", 'String'>
    readonly approvedAt: FieldRef<"PurchaseApproval", 'DateTime'>
    readonly createdAt: FieldRef<"PurchaseApproval", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseApproval findUnique
   */
  export type PurchaseApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseApproval to fetch.
     */
    where: PurchaseApprovalWhereUniqueInput
  }

  /**
   * PurchaseApproval findUniqueOrThrow
   */
  export type PurchaseApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseApproval to fetch.
     */
    where: PurchaseApprovalWhereUniqueInput
  }

  /**
   * PurchaseApproval findFirst
   */
  export type PurchaseApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseApproval to fetch.
     */
    where?: PurchaseApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseApprovals to fetch.
     */
    orderBy?: PurchaseApprovalOrderByWithRelationInput | PurchaseApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseApprovals.
     */
    cursor?: PurchaseApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseApprovals.
     */
    distinct?: PurchaseApprovalScalarFieldEnum | PurchaseApprovalScalarFieldEnum[]
  }

  /**
   * PurchaseApproval findFirstOrThrow
   */
  export type PurchaseApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseApproval to fetch.
     */
    where?: PurchaseApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseApprovals to fetch.
     */
    orderBy?: PurchaseApprovalOrderByWithRelationInput | PurchaseApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseApprovals.
     */
    cursor?: PurchaseApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseApprovals.
     */
    distinct?: PurchaseApprovalScalarFieldEnum | PurchaseApprovalScalarFieldEnum[]
  }

  /**
   * PurchaseApproval findMany
   */
  export type PurchaseApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseApprovals to fetch.
     */
    where?: PurchaseApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseApprovals to fetch.
     */
    orderBy?: PurchaseApprovalOrderByWithRelationInput | PurchaseApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseApprovals.
     */
    cursor?: PurchaseApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseApprovals.
     */
    skip?: number
    distinct?: PurchaseApprovalScalarFieldEnum | PurchaseApprovalScalarFieldEnum[]
  }

  /**
   * PurchaseApproval create
   */
  export type PurchaseApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseApproval.
     */
    data: XOR<PurchaseApprovalCreateInput, PurchaseApprovalUncheckedCreateInput>
  }

  /**
   * PurchaseApproval createMany
   */
  export type PurchaseApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseApprovals.
     */
    data: PurchaseApprovalCreateManyInput | PurchaseApprovalCreateManyInput[]
  }

  /**
   * PurchaseApproval update
   */
  export type PurchaseApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseApproval.
     */
    data: XOR<PurchaseApprovalUpdateInput, PurchaseApprovalUncheckedUpdateInput>
    /**
     * Choose, which PurchaseApproval to update.
     */
    where: PurchaseApprovalWhereUniqueInput
  }

  /**
   * PurchaseApproval updateMany
   */
  export type PurchaseApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseApprovals.
     */
    data: XOR<PurchaseApprovalUpdateManyMutationInput, PurchaseApprovalUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseApprovals to update
     */
    where?: PurchaseApprovalWhereInput
    /**
     * Limit how many PurchaseApprovals to update.
     */
    limit?: number
  }

  /**
   * PurchaseApproval upsert
   */
  export type PurchaseApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseApproval to update in case it exists.
     */
    where: PurchaseApprovalWhereUniqueInput
    /**
     * In case the PurchaseApproval found by the `where` argument doesn't exist, create a new PurchaseApproval with this data.
     */
    create: XOR<PurchaseApprovalCreateInput, PurchaseApprovalUncheckedCreateInput>
    /**
     * In case the PurchaseApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseApprovalUpdateInput, PurchaseApprovalUncheckedUpdateInput>
  }

  /**
   * PurchaseApproval delete
   */
  export type PurchaseApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    /**
     * Filter which PurchaseApproval to delete.
     */
    where: PurchaseApprovalWhereUniqueInput
  }

  /**
   * PurchaseApproval deleteMany
   */
  export type PurchaseApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseApprovals to delete
     */
    where?: PurchaseApprovalWhereInput
    /**
     * Limit how many PurchaseApprovals to delete.
     */
    limit?: number
  }

  /**
   * PurchaseApproval findRaw
   */
  export type PurchaseApprovalFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PurchaseApproval aggregateRaw
   */
  export type PurchaseApprovalAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PurchaseApproval.notifications
   */
  export type PurchaseApproval$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * PurchaseApproval without action
   */
  export type PurchaseApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseContributor
   */

  export type AggregatePurchaseContributor = {
    _count: PurchaseContributorCountAggregateOutputType | null
    _avg: PurchaseContributorAvgAggregateOutputType | null
    _sum: PurchaseContributorSumAggregateOutputType | null
    _min: PurchaseContributorMinAggregateOutputType | null
    _max: PurchaseContributorMaxAggregateOutputType | null
  }

  export type PurchaseContributorAvgAggregateOutputType = {
    sharePercentage: number | null
    contribution: number | null
    expectedContribution: number | null
    actualContribution: number | null
    remainingAmount: number | null
  }

  export type PurchaseContributorSumAggregateOutputType = {
    sharePercentage: number | null
    contribution: number | null
    expectedContribution: number | null
    actualContribution: number | null
    remainingAmount: number | null
  }

  export type PurchaseContributorMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    userId: string | null
    sharePercentage: number | null
    contribution: number | null
    expectedContribution: number | null
    actualContribution: number | null
    remainingAmount: number | null
    hasPaid: boolean | null
    paymentDate: Date | null
    isCreditor: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseContributorMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    userId: string | null
    sharePercentage: number | null
    contribution: number | null
    expectedContribution: number | null
    actualContribution: number | null
    remainingAmount: number | null
    hasPaid: boolean | null
    paymentDate: Date | null
    isCreditor: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseContributorCountAggregateOutputType = {
    id: number
    purchaseId: number
    userId: number
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution: number
    remainingAmount: number
    hasPaid: number
    paymentDate: number
    isCreditor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseContributorAvgAggregateInputType = {
    sharePercentage?: true
    contribution?: true
    expectedContribution?: true
    actualContribution?: true
    remainingAmount?: true
  }

  export type PurchaseContributorSumAggregateInputType = {
    sharePercentage?: true
    contribution?: true
    expectedContribution?: true
    actualContribution?: true
    remainingAmount?: true
  }

  export type PurchaseContributorMinAggregateInputType = {
    id?: true
    purchaseId?: true
    userId?: true
    sharePercentage?: true
    contribution?: true
    expectedContribution?: true
    actualContribution?: true
    remainingAmount?: true
    hasPaid?: true
    paymentDate?: true
    isCreditor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseContributorMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    userId?: true
    sharePercentage?: true
    contribution?: true
    expectedContribution?: true
    actualContribution?: true
    remainingAmount?: true
    hasPaid?: true
    paymentDate?: true
    isCreditor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseContributorCountAggregateInputType = {
    id?: true
    purchaseId?: true
    userId?: true
    sharePercentage?: true
    contribution?: true
    expectedContribution?: true
    actualContribution?: true
    remainingAmount?: true
    hasPaid?: true
    paymentDate?: true
    isCreditor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseContributorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseContributor to aggregate.
     */
    where?: PurchaseContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseContributors to fetch.
     */
    orderBy?: PurchaseContributorOrderByWithRelationInput | PurchaseContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseContributors
    **/
    _count?: true | PurchaseContributorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseContributorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseContributorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseContributorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseContributorMaxAggregateInputType
  }

  export type GetPurchaseContributorAggregateType<T extends PurchaseContributorAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseContributor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseContributor[P]>
      : GetScalarType<T[P], AggregatePurchaseContributor[P]>
  }




  export type PurchaseContributorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseContributorWhereInput
    orderBy?: PurchaseContributorOrderByWithAggregationInput | PurchaseContributorOrderByWithAggregationInput[]
    by: PurchaseContributorScalarFieldEnum[] | PurchaseContributorScalarFieldEnum
    having?: PurchaseContributorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseContributorCountAggregateInputType | true
    _avg?: PurchaseContributorAvgAggregateInputType
    _sum?: PurchaseContributorSumAggregateInputType
    _min?: PurchaseContributorMinAggregateInputType
    _max?: PurchaseContributorMaxAggregateInputType
  }

  export type PurchaseContributorGroupByOutputType = {
    id: string
    purchaseId: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution: number
    remainingAmount: number | null
    hasPaid: boolean
    paymentDate: Date | null
    isCreditor: boolean
    createdAt: Date
    updatedAt: Date
    _count: PurchaseContributorCountAggregateOutputType | null
    _avg: PurchaseContributorAvgAggregateOutputType | null
    _sum: PurchaseContributorSumAggregateOutputType | null
    _min: PurchaseContributorMinAggregateOutputType | null
    _max: PurchaseContributorMaxAggregateOutputType | null
  }

  type GetPurchaseContributorGroupByPayload<T extends PurchaseContributorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseContributorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseContributorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseContributorGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseContributorGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseContributorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    userId?: boolean
    sharePercentage?: boolean
    contribution?: boolean
    expectedContribution?: boolean
    actualContribution?: boolean
    remainingAmount?: boolean
    hasPaid?: boolean
    paymentDate?: boolean
    isCreditor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentHistory?: boolean | PurchaseContributor$paymentHistoryArgs<ExtArgs>
    notifications?: boolean | PurchaseContributor$notificationsArgs<ExtArgs>
    _count?: boolean | PurchaseContributorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseContributor"]>



  export type PurchaseContributorSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    userId?: boolean
    sharePercentage?: boolean
    contribution?: boolean
    expectedContribution?: boolean
    actualContribution?: boolean
    remainingAmount?: boolean
    hasPaid?: boolean
    paymentDate?: boolean
    isCreditor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseContributorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseId" | "userId" | "sharePercentage" | "contribution" | "expectedContribution" | "actualContribution" | "remainingAmount" | "hasPaid" | "paymentDate" | "isCreditor" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseContributor"]>
  export type PurchaseContributorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentHistory?: boolean | PurchaseContributor$paymentHistoryArgs<ExtArgs>
    notifications?: boolean | PurchaseContributor$notificationsArgs<ExtArgs>
    _count?: boolean | PurchaseContributorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PurchaseContributorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseContributor"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      paymentHistory: Prisma.$PaymentHistoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      userId: string
      sharePercentage: number
      contribution: number
      expectedContribution: number
      actualContribution: number
      remainingAmount: number | null
      hasPaid: boolean
      paymentDate: Date | null
      isCreditor: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseContributor"]>
    composites: {}
  }

  type PurchaseContributorGetPayload<S extends boolean | null | undefined | PurchaseContributorDefaultArgs> = $Result.GetResult<Prisma.$PurchaseContributorPayload, S>

  type PurchaseContributorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseContributorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseContributorCountAggregateInputType | true
    }

  export interface PurchaseContributorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseContributor'], meta: { name: 'PurchaseContributor' } }
    /**
     * Find zero or one PurchaseContributor that matches the filter.
     * @param {PurchaseContributorFindUniqueArgs} args - Arguments to find a PurchaseContributor
     * @example
     * // Get one PurchaseContributor
     * const purchaseContributor = await prisma.purchaseContributor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseContributorFindUniqueArgs>(args: SelectSubset<T, PurchaseContributorFindUniqueArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseContributor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseContributorFindUniqueOrThrowArgs} args - Arguments to find a PurchaseContributor
     * @example
     * // Get one PurchaseContributor
     * const purchaseContributor = await prisma.purchaseContributor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseContributorFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseContributorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseContributor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorFindFirstArgs} args - Arguments to find a PurchaseContributor
     * @example
     * // Get one PurchaseContributor
     * const purchaseContributor = await prisma.purchaseContributor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseContributorFindFirstArgs>(args?: SelectSubset<T, PurchaseContributorFindFirstArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseContributor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorFindFirstOrThrowArgs} args - Arguments to find a PurchaseContributor
     * @example
     * // Get one PurchaseContributor
     * const purchaseContributor = await prisma.purchaseContributor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseContributorFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseContributorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseContributors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseContributors
     * const purchaseContributors = await prisma.purchaseContributor.findMany()
     * 
     * // Get first 10 PurchaseContributors
     * const purchaseContributors = await prisma.purchaseContributor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseContributorWithIdOnly = await prisma.purchaseContributor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseContributorFindManyArgs>(args?: SelectSubset<T, PurchaseContributorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseContributor.
     * @param {PurchaseContributorCreateArgs} args - Arguments to create a PurchaseContributor.
     * @example
     * // Create one PurchaseContributor
     * const PurchaseContributor = await prisma.purchaseContributor.create({
     *   data: {
     *     // ... data to create a PurchaseContributor
     *   }
     * })
     * 
     */
    create<T extends PurchaseContributorCreateArgs>(args: SelectSubset<T, PurchaseContributorCreateArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseContributors.
     * @param {PurchaseContributorCreateManyArgs} args - Arguments to create many PurchaseContributors.
     * @example
     * // Create many PurchaseContributors
     * const purchaseContributor = await prisma.purchaseContributor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseContributorCreateManyArgs>(args?: SelectSubset<T, PurchaseContributorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseContributor.
     * @param {PurchaseContributorDeleteArgs} args - Arguments to delete one PurchaseContributor.
     * @example
     * // Delete one PurchaseContributor
     * const PurchaseContributor = await prisma.purchaseContributor.delete({
     *   where: {
     *     // ... filter to delete one PurchaseContributor
     *   }
     * })
     * 
     */
    delete<T extends PurchaseContributorDeleteArgs>(args: SelectSubset<T, PurchaseContributorDeleteArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseContributor.
     * @param {PurchaseContributorUpdateArgs} args - Arguments to update one PurchaseContributor.
     * @example
     * // Update one PurchaseContributor
     * const purchaseContributor = await prisma.purchaseContributor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseContributorUpdateArgs>(args: SelectSubset<T, PurchaseContributorUpdateArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseContributors.
     * @param {PurchaseContributorDeleteManyArgs} args - Arguments to filter PurchaseContributors to delete.
     * @example
     * // Delete a few PurchaseContributors
     * const { count } = await prisma.purchaseContributor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseContributorDeleteManyArgs>(args?: SelectSubset<T, PurchaseContributorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseContributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseContributors
     * const purchaseContributor = await prisma.purchaseContributor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseContributorUpdateManyArgs>(args: SelectSubset<T, PurchaseContributorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseContributor.
     * @param {PurchaseContributorUpsertArgs} args - Arguments to update or create a PurchaseContributor.
     * @example
     * // Update or create a PurchaseContributor
     * const purchaseContributor = await prisma.purchaseContributor.upsert({
     *   create: {
     *     // ... data to create a PurchaseContributor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseContributor we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseContributorUpsertArgs>(args: SelectSubset<T, PurchaseContributorUpsertArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseContributors that matches the filter.
     * @param {PurchaseContributorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const purchaseContributor = await prisma.purchaseContributor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PurchaseContributorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PurchaseContributor.
     * @param {PurchaseContributorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const purchaseContributor = await prisma.purchaseContributor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PurchaseContributorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PurchaseContributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorCountArgs} args - Arguments to filter PurchaseContributors to count.
     * @example
     * // Count the number of PurchaseContributors
     * const count = await prisma.purchaseContributor.count({
     *   where: {
     *     // ... the filter for the PurchaseContributors we want to count
     *   }
     * })
    **/
    count<T extends PurchaseContributorCountArgs>(
      args?: Subset<T, PurchaseContributorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseContributorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseContributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseContributorAggregateArgs>(args: Subset<T, PurchaseContributorAggregateArgs>): Prisma.PrismaPromise<GetPurchaseContributorAggregateType<T>>

    /**
     * Group by PurchaseContributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseContributorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseContributorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseContributorGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseContributorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseContributorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseContributorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseContributor model
   */
  readonly fields: PurchaseContributorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseContributor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseContributorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentHistory<T extends PurchaseContributor$paymentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseContributor$paymentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends PurchaseContributor$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseContributor$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseContributor model
   */
  interface PurchaseContributorFieldRefs {
    readonly id: FieldRef<"PurchaseContributor", 'String'>
    readonly purchaseId: FieldRef<"PurchaseContributor", 'String'>
    readonly userId: FieldRef<"PurchaseContributor", 'String'>
    readonly sharePercentage: FieldRef<"PurchaseContributor", 'Float'>
    readonly contribution: FieldRef<"PurchaseContributor", 'Float'>
    readonly expectedContribution: FieldRef<"PurchaseContributor", 'Float'>
    readonly actualContribution: FieldRef<"PurchaseContributor", 'Float'>
    readonly remainingAmount: FieldRef<"PurchaseContributor", 'Float'>
    readonly hasPaid: FieldRef<"PurchaseContributor", 'Boolean'>
    readonly paymentDate: FieldRef<"PurchaseContributor", 'DateTime'>
    readonly isCreditor: FieldRef<"PurchaseContributor", 'Boolean'>
    readonly createdAt: FieldRef<"PurchaseContributor", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseContributor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseContributor findUnique
   */
  export type PurchaseContributorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseContributor to fetch.
     */
    where: PurchaseContributorWhereUniqueInput
  }

  /**
   * PurchaseContributor findUniqueOrThrow
   */
  export type PurchaseContributorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseContributor to fetch.
     */
    where: PurchaseContributorWhereUniqueInput
  }

  /**
   * PurchaseContributor findFirst
   */
  export type PurchaseContributorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseContributor to fetch.
     */
    where?: PurchaseContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseContributors to fetch.
     */
    orderBy?: PurchaseContributorOrderByWithRelationInput | PurchaseContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseContributors.
     */
    cursor?: PurchaseContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseContributors.
     */
    distinct?: PurchaseContributorScalarFieldEnum | PurchaseContributorScalarFieldEnum[]
  }

  /**
   * PurchaseContributor findFirstOrThrow
   */
  export type PurchaseContributorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseContributor to fetch.
     */
    where?: PurchaseContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseContributors to fetch.
     */
    orderBy?: PurchaseContributorOrderByWithRelationInput | PurchaseContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseContributors.
     */
    cursor?: PurchaseContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseContributors.
     */
    distinct?: PurchaseContributorScalarFieldEnum | PurchaseContributorScalarFieldEnum[]
  }

  /**
   * PurchaseContributor findMany
   */
  export type PurchaseContributorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseContributors to fetch.
     */
    where?: PurchaseContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseContributors to fetch.
     */
    orderBy?: PurchaseContributorOrderByWithRelationInput | PurchaseContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseContributors.
     */
    cursor?: PurchaseContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseContributors.
     */
    skip?: number
    distinct?: PurchaseContributorScalarFieldEnum | PurchaseContributorScalarFieldEnum[]
  }

  /**
   * PurchaseContributor create
   */
  export type PurchaseContributorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseContributor.
     */
    data: XOR<PurchaseContributorCreateInput, PurchaseContributorUncheckedCreateInput>
  }

  /**
   * PurchaseContributor createMany
   */
  export type PurchaseContributorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseContributors.
     */
    data: PurchaseContributorCreateManyInput | PurchaseContributorCreateManyInput[]
  }

  /**
   * PurchaseContributor update
   */
  export type PurchaseContributorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseContributor.
     */
    data: XOR<PurchaseContributorUpdateInput, PurchaseContributorUncheckedUpdateInput>
    /**
     * Choose, which PurchaseContributor to update.
     */
    where: PurchaseContributorWhereUniqueInput
  }

  /**
   * PurchaseContributor updateMany
   */
  export type PurchaseContributorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseContributors.
     */
    data: XOR<PurchaseContributorUpdateManyMutationInput, PurchaseContributorUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseContributors to update
     */
    where?: PurchaseContributorWhereInput
    /**
     * Limit how many PurchaseContributors to update.
     */
    limit?: number
  }

  /**
   * PurchaseContributor upsert
   */
  export type PurchaseContributorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseContributor to update in case it exists.
     */
    where: PurchaseContributorWhereUniqueInput
    /**
     * In case the PurchaseContributor found by the `where` argument doesn't exist, create a new PurchaseContributor with this data.
     */
    create: XOR<PurchaseContributorCreateInput, PurchaseContributorUncheckedCreateInput>
    /**
     * In case the PurchaseContributor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseContributorUpdateInput, PurchaseContributorUncheckedUpdateInput>
  }

  /**
   * PurchaseContributor delete
   */
  export type PurchaseContributorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    /**
     * Filter which PurchaseContributor to delete.
     */
    where: PurchaseContributorWhereUniqueInput
  }

  /**
   * PurchaseContributor deleteMany
   */
  export type PurchaseContributorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseContributors to delete
     */
    where?: PurchaseContributorWhereInput
    /**
     * Limit how many PurchaseContributors to delete.
     */
    limit?: number
  }

  /**
   * PurchaseContributor findRaw
   */
  export type PurchaseContributorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PurchaseContributor aggregateRaw
   */
  export type PurchaseContributorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PurchaseContributor.paymentHistory
   */
  export type PurchaseContributor$paymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    where?: PaymentHistoryWhereInput
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    cursor?: PaymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseContributor.notifications
   */
  export type PurchaseContributor$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * PurchaseContributor without action
   */
  export type PurchaseContributorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
  }


  /**
   * Model PaymentHistory
   */

  export type AggregatePaymentHistory = {
    _count: PaymentHistoryCountAggregateOutputType | null
    _avg: PaymentHistoryAvgAggregateOutputType | null
    _sum: PaymentHistorySumAggregateOutputType | null
    _min: PaymentHistoryMinAggregateOutputType | null
    _max: PaymentHistoryMaxAggregateOutputType | null
  }

  export type PaymentHistoryAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentHistorySumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentHistoryMinAggregateOutputType = {
    id: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    notes: string | null
    createdAt: Date | null
    debtId: string | null
    contributorId: string | null
    payerId: string | null
    receiverId: string | null
  }

  export type PaymentHistoryMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    notes: string | null
    createdAt: Date | null
    debtId: string | null
    contributorId: string | null
    payerId: string | null
    receiverId: string | null
  }

  export type PaymentHistoryCountAggregateOutputType = {
    id: number
    amount: number
    paymentDate: number
    paymentMethod: number
    notes: number
    createdAt: number
    debtId: number
    contributorId: number
    payerId: number
    receiverId: number
    _all: number
  }


  export type PaymentHistoryAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentHistorySumAggregateInputType = {
    amount?: true
  }

  export type PaymentHistoryMinAggregateInputType = {
    id?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    debtId?: true
    contributorId?: true
    payerId?: true
    receiverId?: true
  }

  export type PaymentHistoryMaxAggregateInputType = {
    id?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    debtId?: true
    contributorId?: true
    payerId?: true
    receiverId?: true
  }

  export type PaymentHistoryCountAggregateInputType = {
    id?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    debtId?: true
    contributorId?: true
    payerId?: true
    receiverId?: true
    _all?: true
  }

  export type PaymentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentHistory to aggregate.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentHistories
    **/
    _count?: true | PaymentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentHistoryMaxAggregateInputType
  }

  export type GetPaymentHistoryAggregateType<T extends PaymentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentHistory[P]>
      : GetScalarType<T[P], AggregatePaymentHistory[P]>
  }




  export type PaymentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentHistoryWhereInput
    orderBy?: PaymentHistoryOrderByWithAggregationInput | PaymentHistoryOrderByWithAggregationInput[]
    by: PaymentHistoryScalarFieldEnum[] | PaymentHistoryScalarFieldEnum
    having?: PaymentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentHistoryCountAggregateInputType | true
    _avg?: PaymentHistoryAvgAggregateInputType
    _sum?: PaymentHistorySumAggregateInputType
    _min?: PaymentHistoryMinAggregateInputType
    _max?: PaymentHistoryMaxAggregateInputType
  }

  export type PaymentHistoryGroupByOutputType = {
    id: string
    amount: number
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod
    notes: string | null
    createdAt: Date
    debtId: string | null
    contributorId: string | null
    payerId: string
    receiverId: string
    _count: PaymentHistoryCountAggregateOutputType | null
    _avg: PaymentHistoryAvgAggregateOutputType | null
    _sum: PaymentHistorySumAggregateOutputType | null
    _min: PaymentHistoryMinAggregateOutputType | null
    _max: PaymentHistoryMaxAggregateOutputType | null
  }

  type GetPaymentHistoryGroupByPayload<T extends PaymentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PaymentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    debtId?: boolean
    contributorId?: boolean
    payerId?: boolean
    receiverId?: boolean
    debt?: boolean | PaymentHistory$debtArgs<ExtArgs>
    contributor?: boolean | PaymentHistory$contributorArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | PaymentHistory$notificationsArgs<ExtArgs>
    _count?: boolean | PaymentHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentHistory"]>



  export type PaymentHistorySelectScalar = {
    id?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    debtId?: boolean
    contributorId?: boolean
    payerId?: boolean
    receiverId?: boolean
  }

  export type PaymentHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "paymentDate" | "paymentMethod" | "notes" | "createdAt" | "debtId" | "contributorId" | "payerId" | "receiverId", ExtArgs["result"]["paymentHistory"]>
  export type PaymentHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debt?: boolean | PaymentHistory$debtArgs<ExtArgs>
    contributor?: boolean | PaymentHistory$contributorArgs<ExtArgs>
    payer?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | PaymentHistory$notificationsArgs<ExtArgs>
    _count?: boolean | PaymentHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PaymentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentHistory"
    objects: {
      debt: Prisma.$DebtPayload<ExtArgs> | null
      contributor: Prisma.$PurchaseContributorPayload<ExtArgs> | null
      payer: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod
      notes: string | null
      createdAt: Date
      debtId: string | null
      contributorId: string | null
      payerId: string
      receiverId: string
    }, ExtArgs["result"]["paymentHistory"]>
    composites: {}
  }

  type PaymentHistoryGetPayload<S extends boolean | null | undefined | PaymentHistoryDefaultArgs> = $Result.GetResult<Prisma.$PaymentHistoryPayload, S>

  type PaymentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentHistoryCountAggregateInputType | true
    }

  export interface PaymentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentHistory'], meta: { name: 'PaymentHistory' } }
    /**
     * Find zero or one PaymentHistory that matches the filter.
     * @param {PaymentHistoryFindUniqueArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentHistoryFindUniqueArgs>(args: SelectSubset<T, PaymentHistoryFindUniqueArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentHistoryFindUniqueOrThrowArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryFindFirstArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentHistoryFindFirstArgs>(args?: SelectSubset<T, PaymentHistoryFindFirstArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryFindFirstOrThrowArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentHistories
     * const paymentHistories = await prisma.paymentHistory.findMany()
     * 
     * // Get first 10 PaymentHistories
     * const paymentHistories = await prisma.paymentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentHistoryWithIdOnly = await prisma.paymentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentHistoryFindManyArgs>(args?: SelectSubset<T, PaymentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentHistory.
     * @param {PaymentHistoryCreateArgs} args - Arguments to create a PaymentHistory.
     * @example
     * // Create one PaymentHistory
     * const PaymentHistory = await prisma.paymentHistory.create({
     *   data: {
     *     // ... data to create a PaymentHistory
     *   }
     * })
     * 
     */
    create<T extends PaymentHistoryCreateArgs>(args: SelectSubset<T, PaymentHistoryCreateArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentHistories.
     * @param {PaymentHistoryCreateManyArgs} args - Arguments to create many PaymentHistories.
     * @example
     * // Create many PaymentHistories
     * const paymentHistory = await prisma.paymentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentHistoryCreateManyArgs>(args?: SelectSubset<T, PaymentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentHistory.
     * @param {PaymentHistoryDeleteArgs} args - Arguments to delete one PaymentHistory.
     * @example
     * // Delete one PaymentHistory
     * const PaymentHistory = await prisma.paymentHistory.delete({
     *   where: {
     *     // ... filter to delete one PaymentHistory
     *   }
     * })
     * 
     */
    delete<T extends PaymentHistoryDeleteArgs>(args: SelectSubset<T, PaymentHistoryDeleteArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentHistory.
     * @param {PaymentHistoryUpdateArgs} args - Arguments to update one PaymentHistory.
     * @example
     * // Update one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentHistoryUpdateArgs>(args: SelectSubset<T, PaymentHistoryUpdateArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentHistories.
     * @param {PaymentHistoryDeleteManyArgs} args - Arguments to filter PaymentHistories to delete.
     * @example
     * // Delete a few PaymentHistories
     * const { count } = await prisma.paymentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentHistoryDeleteManyArgs>(args?: SelectSubset<T, PaymentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentHistories
     * const paymentHistory = await prisma.paymentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentHistoryUpdateManyArgs>(args: SelectSubset<T, PaymentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentHistory.
     * @param {PaymentHistoryUpsertArgs} args - Arguments to update or create a PaymentHistory.
     * @example
     * // Update or create a PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.upsert({
     *   create: {
     *     // ... data to create a PaymentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentHistory we want to update
     *   }
     * })
     */
    upsert<T extends PaymentHistoryUpsertArgs>(args: SelectSubset<T, PaymentHistoryUpsertArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentHistories that matches the filter.
     * @param {PaymentHistoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const paymentHistory = await prisma.paymentHistory.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PaymentHistoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PaymentHistory.
     * @param {PaymentHistoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const paymentHistory = await prisma.paymentHistory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PaymentHistoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PaymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryCountArgs} args - Arguments to filter PaymentHistories to count.
     * @example
     * // Count the number of PaymentHistories
     * const count = await prisma.paymentHistory.count({
     *   where: {
     *     // ... the filter for the PaymentHistories we want to count
     *   }
     * })
    **/
    count<T extends PaymentHistoryCountArgs>(
      args?: Subset<T, PaymentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentHistoryAggregateArgs>(args: Subset<T, PaymentHistoryAggregateArgs>): Prisma.PrismaPromise<GetPaymentHistoryAggregateType<T>>

    /**
     * Group by PaymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PaymentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentHistory model
   */
  readonly fields: PaymentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debt<T extends PaymentHistory$debtArgs<ExtArgs> = {}>(args?: Subset<T, PaymentHistory$debtArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contributor<T extends PaymentHistory$contributorArgs<ExtArgs> = {}>(args?: Subset<T, PaymentHistory$contributorArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends PaymentHistory$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentHistory$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentHistory model
   */
  interface PaymentHistoryFieldRefs {
    readonly id: FieldRef<"PaymentHistory", 'String'>
    readonly amount: FieldRef<"PaymentHistory", 'Float'>
    readonly paymentDate: FieldRef<"PaymentHistory", 'DateTime'>
    readonly paymentMethod: FieldRef<"PaymentHistory", 'PaymentMethod'>
    readonly notes: FieldRef<"PaymentHistory", 'String'>
    readonly createdAt: FieldRef<"PaymentHistory", 'DateTime'>
    readonly debtId: FieldRef<"PaymentHistory", 'String'>
    readonly contributorId: FieldRef<"PaymentHistory", 'String'>
    readonly payerId: FieldRef<"PaymentHistory", 'String'>
    readonly receiverId: FieldRef<"PaymentHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentHistory findUnique
   */
  export type PaymentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory findUniqueOrThrow
   */
  export type PaymentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory findFirst
   */
  export type PaymentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentHistories.
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentHistories.
     */
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PaymentHistory findFirstOrThrow
   */
  export type PaymentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentHistories.
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentHistories.
     */
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PaymentHistory findMany
   */
  export type PaymentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PaymentHistories to fetch.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentHistories.
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PaymentHistory create
   */
  export type PaymentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentHistory.
     */
    data: XOR<PaymentHistoryCreateInput, PaymentHistoryUncheckedCreateInput>
  }

  /**
   * PaymentHistory createMany
   */
  export type PaymentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentHistories.
     */
    data: PaymentHistoryCreateManyInput | PaymentHistoryCreateManyInput[]
  }

  /**
   * PaymentHistory update
   */
  export type PaymentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentHistory.
     */
    data: XOR<PaymentHistoryUpdateInput, PaymentHistoryUncheckedUpdateInput>
    /**
     * Choose, which PaymentHistory to update.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory updateMany
   */
  export type PaymentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentHistories.
     */
    data: XOR<PaymentHistoryUpdateManyMutationInput, PaymentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PaymentHistories to update
     */
    where?: PaymentHistoryWhereInput
    /**
     * Limit how many PaymentHistories to update.
     */
    limit?: number
  }

  /**
   * PaymentHistory upsert
   */
  export type PaymentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentHistory to update in case it exists.
     */
    where: PaymentHistoryWhereUniqueInput
    /**
     * In case the PaymentHistory found by the `where` argument doesn't exist, create a new PaymentHistory with this data.
     */
    create: XOR<PaymentHistoryCreateInput, PaymentHistoryUncheckedCreateInput>
    /**
     * In case the PaymentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentHistoryUpdateInput, PaymentHistoryUncheckedUpdateInput>
  }

  /**
   * PaymentHistory delete
   */
  export type PaymentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter which PaymentHistory to delete.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory deleteMany
   */
  export type PaymentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentHistories to delete
     */
    where?: PaymentHistoryWhereInput
    /**
     * Limit how many PaymentHistories to delete.
     */
    limit?: number
  }

  /**
   * PaymentHistory findRaw
   */
  export type PaymentHistoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PaymentHistory aggregateRaw
   */
  export type PaymentHistoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PaymentHistory.debt
   */
  export type PaymentHistory$debtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
  }

  /**
   * PaymentHistory.contributor
   */
  export type PaymentHistory$contributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    where?: PurchaseContributorWhereInput
  }

  /**
   * PaymentHistory.notifications
   */
  export type PaymentHistory$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * PaymentHistory without action
   */
  export type PaymentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryTransaction
   */

  export type AggregateInventoryTransaction = {
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  export type InventoryTransactionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryTransactionSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryTransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    quantity: number | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    seasonId: string | null
    inventoryId: string | null
    purchaseId: string | null
    userId: string | null
  }

  export type InventoryTransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    quantity: number | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    seasonId: string | null
    inventoryId: string | null
    purchaseId: string | null
    userId: string | null
  }

  export type InventoryTransactionCountAggregateOutputType = {
    id: number
    type: number
    quantity: number
    date: number
    notes: number
    createdAt: number
    seasonId: number
    inventoryId: number
    purchaseId: number
    userId: number
    _all: number
  }


  export type InventoryTransactionAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryTransactionSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryTransactionMinAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    date?: true
    notes?: true
    createdAt?: true
    seasonId?: true
    inventoryId?: true
    purchaseId?: true
    userId?: true
  }

  export type InventoryTransactionMaxAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    date?: true
    notes?: true
    createdAt?: true
    seasonId?: true
    inventoryId?: true
    purchaseId?: true
    userId?: true
  }

  export type InventoryTransactionCountAggregateInputType = {
    id?: true
    type?: true
    quantity?: true
    date?: true
    notes?: true
    createdAt?: true
    seasonId?: true
    inventoryId?: true
    purchaseId?: true
    userId?: true
    _all?: true
  }

  export type InventoryTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransaction to aggregate.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryTransactions
    **/
    _count?: true | InventoryTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type GetInventoryTransactionAggregateType<T extends InventoryTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryTransaction[P]>
      : GetScalarType<T[P], AggregateInventoryTransaction[P]>
  }




  export type InventoryTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithAggregationInput | InventoryTransactionOrderByWithAggregationInput[]
    by: InventoryTransactionScalarFieldEnum[] | InventoryTransactionScalarFieldEnum
    having?: InventoryTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryTransactionCountAggregateInputType | true
    _avg?: InventoryTransactionAvgAggregateInputType
    _sum?: InventoryTransactionSumAggregateInputType
    _min?: InventoryTransactionMinAggregateInputType
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type InventoryTransactionGroupByOutputType = {
    id: string
    type: $Enums.TransactionType
    quantity: number
    date: Date
    notes: string | null
    createdAt: Date
    seasonId: string | null
    inventoryId: string
    purchaseId: string | null
    userId: string
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  type GetInventoryTransactionGroupByPayload<T extends InventoryTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    seasonId?: boolean
    inventoryId?: boolean
    purchaseId?: boolean
    userId?: boolean
    season?: boolean | InventoryTransaction$seasonArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    purchase?: boolean | InventoryTransaction$purchaseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | InventoryTransaction$notificationsArgs<ExtArgs>
    _count?: boolean | InventoryTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>



  export type InventoryTransactionSelectScalar = {
    id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    seasonId?: boolean
    inventoryId?: boolean
    purchaseId?: boolean
    userId?: boolean
  }

  export type InventoryTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "quantity" | "date" | "notes" | "createdAt" | "seasonId" | "inventoryId" | "purchaseId" | "userId", ExtArgs["result"]["inventoryTransaction"]>
  export type InventoryTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    season?: boolean | InventoryTransaction$seasonArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    purchase?: boolean | InventoryTransaction$purchaseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | InventoryTransaction$notificationsArgs<ExtArgs>
    _count?: boolean | InventoryTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryTransaction"
    objects: {
      season: Prisma.$SeasonPayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs>
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TransactionType
      quantity: number
      date: Date
      notes: string | null
      createdAt: Date
      seasonId: string | null
      inventoryId: string
      purchaseId: string | null
      userId: string
    }, ExtArgs["result"]["inventoryTransaction"]>
    composites: {}
  }

  type InventoryTransactionGetPayload<S extends boolean | null | undefined | InventoryTransactionDefaultArgs> = $Result.GetResult<Prisma.$InventoryTransactionPayload, S>

  type InventoryTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryTransactionCountAggregateInputType | true
    }

  export interface InventoryTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryTransaction'], meta: { name: 'InventoryTransaction' } }
    /**
     * Find zero or one InventoryTransaction that matches the filter.
     * @param {InventoryTransactionFindUniqueArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryTransactionFindUniqueArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryTransactionFindUniqueOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryTransactionFindFirstArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
     * 
     * // Get first 10 InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryTransactionFindManyArgs>(args?: SelectSubset<T, InventoryTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryTransaction.
     * @param {InventoryTransactionCreateArgs} args - Arguments to create a InventoryTransaction.
     * @example
     * // Create one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.create({
     *   data: {
     *     // ... data to create a InventoryTransaction
     *   }
     * })
     * 
     */
    create<T extends InventoryTransactionCreateArgs>(args: SelectSubset<T, InventoryTransactionCreateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryTransactions.
     * @param {InventoryTransactionCreateManyArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryTransactionCreateManyArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryTransaction.
     * @param {InventoryTransactionDeleteArgs} args - Arguments to delete one InventoryTransaction.
     * @example
     * // Delete one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.delete({
     *   where: {
     *     // ... filter to delete one InventoryTransaction
     *   }
     * })
     * 
     */
    delete<T extends InventoryTransactionDeleteArgs>(args: SelectSubset<T, InventoryTransactionDeleteArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryTransaction.
     * @param {InventoryTransactionUpdateArgs} args - Arguments to update one InventoryTransaction.
     * @example
     * // Update one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryTransactionUpdateArgs>(args: SelectSubset<T, InventoryTransactionUpdateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryTransactions.
     * @param {InventoryTransactionDeleteManyArgs} args - Arguments to filter InventoryTransactions to delete.
     * @example
     * // Delete a few InventoryTransactions
     * const { count } = await prisma.inventoryTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryTransactionDeleteManyArgs>(args?: SelectSubset<T, InventoryTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryTransactionUpdateManyArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryTransaction.
     * @param {InventoryTransactionUpsertArgs} args - Arguments to update or create a InventoryTransaction.
     * @example
     * // Update or create a InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.upsert({
     *   create: {
     *     // ... data to create a InventoryTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryTransaction we want to update
     *   }
     * })
     */
    upsert<T extends InventoryTransactionUpsertArgs>(args: SelectSubset<T, InventoryTransactionUpsertArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * @param {InventoryTransactionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const inventoryTransaction = await prisma.inventoryTransaction.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InventoryTransactionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a InventoryTransaction.
     * @param {InventoryTransactionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const inventoryTransaction = await prisma.inventoryTransaction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InventoryTransactionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionCountArgs} args - Arguments to filter InventoryTransactions to count.
     * @example
     * // Count the number of InventoryTransactions
     * const count = await prisma.inventoryTransaction.count({
     *   where: {
     *     // ... the filter for the InventoryTransactions we want to count
     *   }
     * })
    **/
    count<T extends InventoryTransactionCountArgs>(
      args?: Subset<T, InventoryTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryTransactionAggregateArgs>(args: Subset<T, InventoryTransactionAggregateArgs>): Prisma.PrismaPromise<GetInventoryTransactionAggregateType<T>>

    /**
     * Group by InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryTransactionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryTransaction model
   */
  readonly fields: InventoryTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    season<T extends InventoryTransaction$seasonArgs<ExtArgs> = {}>(args?: Subset<T, InventoryTransaction$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchase<T extends InventoryTransaction$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, InventoryTransaction$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends InventoryTransaction$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryTransaction$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryTransaction model
   */
  interface InventoryTransactionFieldRefs {
    readonly id: FieldRef<"InventoryTransaction", 'String'>
    readonly type: FieldRef<"InventoryTransaction", 'TransactionType'>
    readonly quantity: FieldRef<"InventoryTransaction", 'Float'>
    readonly date: FieldRef<"InventoryTransaction", 'DateTime'>
    readonly notes: FieldRef<"InventoryTransaction", 'String'>
    readonly createdAt: FieldRef<"InventoryTransaction", 'DateTime'>
    readonly seasonId: FieldRef<"InventoryTransaction", 'String'>
    readonly inventoryId: FieldRef<"InventoryTransaction", 'String'>
    readonly purchaseId: FieldRef<"InventoryTransaction", 'String'>
    readonly userId: FieldRef<"InventoryTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryTransaction findUnique
   */
  export type InventoryTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findUniqueOrThrow
   */
  export type InventoryTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findFirst
   */
  export type InventoryTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findFirstOrThrow
   */
  export type InventoryTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findMany
   */
  export type InventoryTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransactions to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction create
   */
  export type InventoryTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryTransaction.
     */
    data: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
  }

  /**
   * InventoryTransaction createMany
   */
  export type InventoryTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
  }

  /**
   * InventoryTransaction update
   */
  export type InventoryTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryTransaction.
     */
    data: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
    /**
     * Choose, which InventoryTransaction to update.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction updateMany
   */
  export type InventoryTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
  }

  /**
   * InventoryTransaction upsert
   */
  export type InventoryTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryTransaction to update in case it exists.
     */
    where: InventoryTransactionWhereUniqueInput
    /**
     * In case the InventoryTransaction found by the `where` argument doesn't exist, create a new InventoryTransaction with this data.
     */
    create: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
    /**
     * In case the InventoryTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
  }

  /**
   * InventoryTransaction delete
   */
  export type InventoryTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter which InventoryTransaction to delete.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction deleteMany
   */
  export type InventoryTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransactions to delete
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to delete.
     */
    limit?: number
  }

  /**
   * InventoryTransaction findRaw
   */
  export type InventoryTransactionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InventoryTransaction aggregateRaw
   */
  export type InventoryTransactionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InventoryTransaction.season
   */
  export type InventoryTransaction$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * InventoryTransaction.purchase
   */
  export type InventoryTransaction$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * InventoryTransaction.notifications
   */
  export type InventoryTransaction$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * InventoryTransaction without action
   */
  export type InventoryTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Debt
   */

  export type AggregateDebt = {
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  export type DebtAvgAggregateOutputType = {
    amount: number | null
  }

  export type DebtSumAggregateOutputType = {
    amount: number | null
  }

  export type DebtMinAggregateOutputType = {
    id: string | null
    amount: number | null
    dueDate: Date | null
    status: $Enums.DebtStatus | null
    description: string | null
    createdAt: Date | null
    paymentDate: Date | null
    reminderSent: boolean | null
    lastReminderDate: Date | null
    reason: string | null
    creditorId: string | null
    debtorId: string | null
    invoiceId: string | null
    purchaseId: string | null
  }

  export type DebtMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    dueDate: Date | null
    status: $Enums.DebtStatus | null
    description: string | null
    createdAt: Date | null
    paymentDate: Date | null
    reminderSent: boolean | null
    lastReminderDate: Date | null
    reason: string | null
    creditorId: string | null
    debtorId: string | null
    invoiceId: string | null
    purchaseId: string | null
  }

  export type DebtCountAggregateOutputType = {
    id: number
    amount: number
    dueDate: number
    status: number
    description: number
    createdAt: number
    paymentDate: number
    reminderSent: number
    lastReminderDate: number
    reason: number
    creditorId: number
    debtorId: number
    invoiceId: number
    purchaseId: number
    _all: number
  }


  export type DebtAvgAggregateInputType = {
    amount?: true
  }

  export type DebtSumAggregateInputType = {
    amount?: true
  }

  export type DebtMinAggregateInputType = {
    id?: true
    amount?: true
    dueDate?: true
    status?: true
    description?: true
    createdAt?: true
    paymentDate?: true
    reminderSent?: true
    lastReminderDate?: true
    reason?: true
    creditorId?: true
    debtorId?: true
    invoiceId?: true
    purchaseId?: true
  }

  export type DebtMaxAggregateInputType = {
    id?: true
    amount?: true
    dueDate?: true
    status?: true
    description?: true
    createdAt?: true
    paymentDate?: true
    reminderSent?: true
    lastReminderDate?: true
    reason?: true
    creditorId?: true
    debtorId?: true
    invoiceId?: true
    purchaseId?: true
  }

  export type DebtCountAggregateInputType = {
    id?: true
    amount?: true
    dueDate?: true
    status?: true
    description?: true
    createdAt?: true
    paymentDate?: true
    reminderSent?: true
    lastReminderDate?: true
    reason?: true
    creditorId?: true
    debtorId?: true
    invoiceId?: true
    purchaseId?: true
    _all?: true
  }

  export type DebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debt to aggregate.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Debts
    **/
    _count?: true | DebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtMaxAggregateInputType
  }

  export type GetDebtAggregateType<T extends DebtAggregateArgs> = {
        [P in keyof T & keyof AggregateDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebt[P]>
      : GetScalarType<T[P], AggregateDebt[P]>
  }




  export type DebtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithAggregationInput | DebtOrderByWithAggregationInput[]
    by: DebtScalarFieldEnum[] | DebtScalarFieldEnum
    having?: DebtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtCountAggregateInputType | true
    _avg?: DebtAvgAggregateInputType
    _sum?: DebtSumAggregateInputType
    _min?: DebtMinAggregateInputType
    _max?: DebtMaxAggregateInputType
  }

  export type DebtGroupByOutputType = {
    id: string
    amount: number
    dueDate: Date
    status: $Enums.DebtStatus
    description: string | null
    createdAt: Date
    paymentDate: Date | null
    reminderSent: boolean
    lastReminderDate: Date | null
    reason: string | null
    creditorId: string
    debtorId: string
    invoiceId: string | null
    purchaseId: string | null
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  type GetDebtGroupByPayload<T extends DebtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtGroupByOutputType[P]>
            : GetScalarType<T[P], DebtGroupByOutputType[P]>
        }
      >
    >


  export type DebtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    paymentDate?: boolean
    reminderSent?: boolean
    lastReminderDate?: boolean
    reason?: boolean
    creditorId?: boolean
    debtorId?: boolean
    invoiceId?: boolean
    purchaseId?: boolean
    creditor?: boolean | UserDefaultArgs<ExtArgs>
    debtor?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Debt$invoiceArgs<ExtArgs>
    purchase?: boolean | Debt$purchaseArgs<ExtArgs>
    paymentHistory?: boolean | Debt$paymentHistoryArgs<ExtArgs>
    wellBillDistributions?: boolean | Debt$wellBillDistributionsArgs<ExtArgs>
    notifications?: boolean | Debt$notificationsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt"]>



  export type DebtSelectScalar = {
    id?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    paymentDate?: boolean
    reminderSent?: boolean
    lastReminderDate?: boolean
    reason?: boolean
    creditorId?: boolean
    debtorId?: boolean
    invoiceId?: boolean
    purchaseId?: boolean
  }

  export type DebtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "dueDate" | "status" | "description" | "createdAt" | "paymentDate" | "reminderSent" | "lastReminderDate" | "reason" | "creditorId" | "debtorId" | "invoiceId" | "purchaseId", ExtArgs["result"]["debt"]>
  export type DebtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditor?: boolean | UserDefaultArgs<ExtArgs>
    debtor?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Debt$invoiceArgs<ExtArgs>
    purchase?: boolean | Debt$purchaseArgs<ExtArgs>
    paymentHistory?: boolean | Debt$paymentHistoryArgs<ExtArgs>
    wellBillDistributions?: boolean | Debt$wellBillDistributionsArgs<ExtArgs>
    notifications?: boolean | Debt$notificationsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DebtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Debt"
    objects: {
      creditor: Prisma.$UserPayload<ExtArgs>
      debtor: Prisma.$UserPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      paymentHistory: Prisma.$PaymentHistoryPayload<ExtArgs>[]
      wellBillDistributions: Prisma.$WellBillDistributionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      dueDate: Date
      status: $Enums.DebtStatus
      description: string | null
      createdAt: Date
      paymentDate: Date | null
      reminderSent: boolean
      lastReminderDate: Date | null
      reason: string | null
      creditorId: string
      debtorId: string
      invoiceId: string | null
      purchaseId: string | null
    }, ExtArgs["result"]["debt"]>
    composites: {}
  }

  type DebtGetPayload<S extends boolean | null | undefined | DebtDefaultArgs> = $Result.GetResult<Prisma.$DebtPayload, S>

  type DebtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtCountAggregateInputType | true
    }

  export interface DebtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Debt'], meta: { name: 'Debt' } }
    /**
     * Find zero or one Debt that matches the filter.
     * @param {DebtFindUniqueArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtFindUniqueArgs>(args: SelectSubset<T, DebtFindUniqueArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtFindUniqueOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindFirstArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtFindFirstArgs>(args?: SelectSubset<T, DebtFindFirstArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindFirstOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debts
     * const debts = await prisma.debt.findMany()
     * 
     * // Get first 10 Debts
     * const debts = await prisma.debt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtWithIdOnly = await prisma.debt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtFindManyArgs>(args?: SelectSubset<T, DebtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debt.
     * @param {DebtCreateArgs} args - Arguments to create a Debt.
     * @example
     * // Create one Debt
     * const Debt = await prisma.debt.create({
     *   data: {
     *     // ... data to create a Debt
     *   }
     * })
     * 
     */
    create<T extends DebtCreateArgs>(args: SelectSubset<T, DebtCreateArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debts.
     * @param {DebtCreateManyArgs} args - Arguments to create many Debts.
     * @example
     * // Create many Debts
     * const debt = await prisma.debt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtCreateManyArgs>(args?: SelectSubset<T, DebtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Debt.
     * @param {DebtDeleteArgs} args - Arguments to delete one Debt.
     * @example
     * // Delete one Debt
     * const Debt = await prisma.debt.delete({
     *   where: {
     *     // ... filter to delete one Debt
     *   }
     * })
     * 
     */
    delete<T extends DebtDeleteArgs>(args: SelectSubset<T, DebtDeleteArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debt.
     * @param {DebtUpdateArgs} args - Arguments to update one Debt.
     * @example
     * // Update one Debt
     * const debt = await prisma.debt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtUpdateArgs>(args: SelectSubset<T, DebtUpdateArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debts.
     * @param {DebtDeleteManyArgs} args - Arguments to filter Debts to delete.
     * @example
     * // Delete a few Debts
     * const { count } = await prisma.debt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtDeleteManyArgs>(args?: SelectSubset<T, DebtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debts
     * const debt = await prisma.debt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtUpdateManyArgs>(args: SelectSubset<T, DebtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Debt.
     * @param {DebtUpsertArgs} args - Arguments to update or create a Debt.
     * @example
     * // Update or create a Debt
     * const debt = await prisma.debt.upsert({
     *   create: {
     *     // ... data to create a Debt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debt we want to update
     *   }
     * })
     */
    upsert<T extends DebtUpsertArgs>(args: SelectSubset<T, DebtUpsertArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debts that matches the filter.
     * @param {DebtFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const debt = await prisma.debt.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DebtFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Debt.
     * @param {DebtAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const debt = await prisma.debt.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DebtAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtCountArgs} args - Arguments to filter Debts to count.
     * @example
     * // Count the number of Debts
     * const count = await prisma.debt.count({
     *   where: {
     *     // ... the filter for the Debts we want to count
     *   }
     * })
    **/
    count<T extends DebtCountArgs>(
      args?: Subset<T, DebtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtAggregateArgs>(args: Subset<T, DebtAggregateArgs>): Prisma.PrismaPromise<GetDebtAggregateType<T>>

    /**
     * Group by Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtGroupByArgs['orderBy'] }
        : { orderBy?: DebtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Debt model
   */
  readonly fields: DebtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Debt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    debtor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Debt$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Debt$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase<T extends Debt$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Debt$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paymentHistory<T extends Debt$paymentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Debt$paymentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellBillDistributions<T extends Debt$wellBillDistributionsArgs<ExtArgs> = {}>(args?: Subset<T, Debt$wellBillDistributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Debt$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Debt$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Debt model
   */
  interface DebtFieldRefs {
    readonly id: FieldRef<"Debt", 'String'>
    readonly amount: FieldRef<"Debt", 'Float'>
    readonly dueDate: FieldRef<"Debt", 'DateTime'>
    readonly status: FieldRef<"Debt", 'DebtStatus'>
    readonly description: FieldRef<"Debt", 'String'>
    readonly createdAt: FieldRef<"Debt", 'DateTime'>
    readonly paymentDate: FieldRef<"Debt", 'DateTime'>
    readonly reminderSent: FieldRef<"Debt", 'Boolean'>
    readonly lastReminderDate: FieldRef<"Debt", 'DateTime'>
    readonly reason: FieldRef<"Debt", 'String'>
    readonly creditorId: FieldRef<"Debt", 'String'>
    readonly debtorId: FieldRef<"Debt", 'String'>
    readonly invoiceId: FieldRef<"Debt", 'String'>
    readonly purchaseId: FieldRef<"Debt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Debt findUnique
   */
  export type DebtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt findUniqueOrThrow
   */
  export type DebtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt findFirst
   */
  export type DebtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt findFirstOrThrow
   */
  export type DebtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt findMany
   */
  export type DebtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debts to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt create
   */
  export type DebtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The data needed to create a Debt.
     */
    data: XOR<DebtCreateInput, DebtUncheckedCreateInput>
  }

  /**
   * Debt createMany
   */
  export type DebtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Debts.
     */
    data: DebtCreateManyInput | DebtCreateManyInput[]
  }

  /**
   * Debt update
   */
  export type DebtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The data needed to update a Debt.
     */
    data: XOR<DebtUpdateInput, DebtUncheckedUpdateInput>
    /**
     * Choose, which Debt to update.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt updateMany
   */
  export type DebtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Debts.
     */
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyInput>
    /**
     * Filter which Debts to update
     */
    where?: DebtWhereInput
    /**
     * Limit how many Debts to update.
     */
    limit?: number
  }

  /**
   * Debt upsert
   */
  export type DebtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The filter to search for the Debt to update in case it exists.
     */
    where: DebtWhereUniqueInput
    /**
     * In case the Debt found by the `where` argument doesn't exist, create a new Debt with this data.
     */
    create: XOR<DebtCreateInput, DebtUncheckedCreateInput>
    /**
     * In case the Debt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtUpdateInput, DebtUncheckedUpdateInput>
  }

  /**
   * Debt delete
   */
  export type DebtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter which Debt to delete.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt deleteMany
   */
  export type DebtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debts to delete
     */
    where?: DebtWhereInput
    /**
     * Limit how many Debts to delete.
     */
    limit?: number
  }

  /**
   * Debt findRaw
   */
  export type DebtFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Debt aggregateRaw
   */
  export type DebtAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Debt.invoice
   */
  export type Debt$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Debt.purchase
   */
  export type Debt$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * Debt.paymentHistory
   */
  export type Debt$paymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    where?: PaymentHistoryWhereInput
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    cursor?: PaymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * Debt.wellBillDistributions
   */
  export type Debt$wellBillDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    where?: WellBillDistributionWhereInput
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    cursor?: WellBillDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * Debt.notifications
   */
  export type Debt$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Debt without action
   */
  export type DebtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    number: string | null
    amount: number | null
    issueDate: Date | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    purchaserId: string | null
    purchaseId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    number: string | null
    amount: number | null
    issueDate: Date | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    purchaserId: string | null
    purchaseId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    number: number
    amount: number
    issueDate: number
    dueDate: number
    status: number
    description: number
    createdAt: number
    updatedAt: number
    purchaserId: number
    purchaseId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    number?: true
    amount?: true
    issueDate?: true
    dueDate?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    purchaserId?: true
    purchaseId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    number?: true
    amount?: true
    issueDate?: true
    dueDate?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    purchaserId?: true
    purchaseId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    number?: true
    amount?: true
    issueDate?: true
    dueDate?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    purchaserId?: true
    purchaseId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    number: string
    amount: number
    issueDate: Date
    dueDate: Date
    status: $Enums.InvoiceStatus
    description: string | null
    createdAt: Date
    updatedAt: Date
    purchaserId: string
    purchaseId: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    amount?: boolean
    issueDate?: boolean
    dueDate?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaserId?: boolean
    purchaseId?: boolean
    purchaser?: boolean | UserDefaultArgs<ExtArgs>
    debts?: boolean | Invoice$debtsArgs<ExtArgs>
    purchase?: boolean | Invoice$purchaseArgs<ExtArgs>
    notifications?: boolean | Invoice$notificationsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>



  export type InvoiceSelectScalar = {
    id?: boolean
    number?: boolean
    amount?: boolean
    issueDate?: boolean
    dueDate?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaserId?: boolean
    purchaseId?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "amount" | "issueDate" | "dueDate" | "status" | "description" | "createdAt" | "updatedAt" | "purchaserId" | "purchaseId", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaser?: boolean | UserDefaultArgs<ExtArgs>
    debts?: boolean | Invoice$debtsArgs<ExtArgs>
    purchase?: boolean | Invoice$purchaseArgs<ExtArgs>
    notifications?: boolean | Invoice$notificationsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      purchaser: Prisma.$UserPayload<ExtArgs>
      debts: Prisma.$DebtPayload<ExtArgs>[]
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      amount: number
      issueDate: Date
      dueDate: Date
      status: $Enums.InvoiceStatus
      description: string | null
      createdAt: Date
      updatedAt: Date
      purchaserId: string
      purchaseId: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * @param {InvoiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invoice = await prisma.invoice.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InvoiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Invoice.
     * @param {InvoiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invoice = await prisma.invoice.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InvoiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    debts<T extends Invoice$debtsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$debtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchase<T extends Invoice$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Invoice$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly purchaserId: FieldRef<"Invoice", 'String'>
    readonly purchaseId: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice findRaw
   */
  export type InvoiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invoice aggregateRaw
   */
  export type InvoiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invoice.debts
   */
  export type Invoice$debtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    cursor?: DebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Invoice.purchase
   */
  export type Invoice$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * Invoice.notifications
   */
  export type Invoice$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InventoryUsage
   */

  export type AggregateInventoryUsage = {
    _count: InventoryUsageCountAggregateOutputType | null
    _avg: InventoryUsageAvgAggregateOutputType | null
    _sum: InventoryUsageSumAggregateOutputType | null
    _min: InventoryUsageMinAggregateOutputType | null
    _max: InventoryUsageMaxAggregateOutputType | null
  }

  export type InventoryUsageAvgAggregateOutputType = {
    usedQuantity: number | null
  }

  export type InventoryUsageSumAggregateOutputType = {
    usedQuantity: number | null
  }

  export type InventoryUsageMinAggregateOutputType = {
    id: string | null
    inventoryId: string | null
    usedQuantity: number | null
    usageType: $Enums.UsageType | null
    usedById: string | null
    fieldId: string | null
    processId: string | null
    createdAt: Date | null
  }

  export type InventoryUsageMaxAggregateOutputType = {
    id: string | null
    inventoryId: string | null
    usedQuantity: number | null
    usageType: $Enums.UsageType | null
    usedById: string | null
    fieldId: string | null
    processId: string | null
    createdAt: Date | null
  }

  export type InventoryUsageCountAggregateOutputType = {
    id: number
    inventoryId: number
    usedQuantity: number
    usageType: number
    usedById: number
    fieldId: number
    processId: number
    createdAt: number
    _all: number
  }


  export type InventoryUsageAvgAggregateInputType = {
    usedQuantity?: true
  }

  export type InventoryUsageSumAggregateInputType = {
    usedQuantity?: true
  }

  export type InventoryUsageMinAggregateInputType = {
    id?: true
    inventoryId?: true
    usedQuantity?: true
    usageType?: true
    usedById?: true
    fieldId?: true
    processId?: true
    createdAt?: true
  }

  export type InventoryUsageMaxAggregateInputType = {
    id?: true
    inventoryId?: true
    usedQuantity?: true
    usageType?: true
    usedById?: true
    fieldId?: true
    processId?: true
    createdAt?: true
  }

  export type InventoryUsageCountAggregateInputType = {
    id?: true
    inventoryId?: true
    usedQuantity?: true
    usageType?: true
    usedById?: true
    fieldId?: true
    processId?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUsage to aggregate.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryUsages
    **/
    _count?: true | InventoryUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryUsageMaxAggregateInputType
  }

  export type GetInventoryUsageAggregateType<T extends InventoryUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryUsage[P]>
      : GetScalarType<T[P], AggregateInventoryUsage[P]>
  }




  export type InventoryUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithAggregationInput | InventoryUsageOrderByWithAggregationInput[]
    by: InventoryUsageScalarFieldEnum[] | InventoryUsageScalarFieldEnum
    having?: InventoryUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryUsageCountAggregateInputType | true
    _avg?: InventoryUsageAvgAggregateInputType
    _sum?: InventoryUsageSumAggregateInputType
    _min?: InventoryUsageMinAggregateInputType
    _max?: InventoryUsageMaxAggregateInputType
  }

  export type InventoryUsageGroupByOutputType = {
    id: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId: string | null
    processId: string | null
    createdAt: Date
    _count: InventoryUsageCountAggregateOutputType | null
    _avg: InventoryUsageAvgAggregateOutputType | null
    _sum: InventoryUsageSumAggregateOutputType | null
    _min: InventoryUsageMinAggregateOutputType | null
    _max: InventoryUsageMaxAggregateOutputType | null
  }

  type GetInventoryUsageGroupByPayload<T extends InventoryUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryUsageGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryUsageGroupByOutputType[P]>
        }
      >
    >


  export type InventoryUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    usedQuantity?: boolean
    usageType?: boolean
    usedById?: boolean
    fieldId?: boolean
    processId?: boolean
    createdAt?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    usedBy?: boolean | UserDefaultArgs<ExtArgs>
    field?: boolean | InventoryUsage$fieldArgs<ExtArgs>
    process?: boolean | InventoryUsage$processArgs<ExtArgs>
    notifications?: boolean | InventoryUsage$notificationsArgs<ExtArgs>
    _count?: boolean | InventoryUsageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUsage"]>



  export type InventoryUsageSelectScalar = {
    id?: boolean
    inventoryId?: boolean
    usedQuantity?: boolean
    usageType?: boolean
    usedById?: boolean
    fieldId?: boolean
    processId?: boolean
    createdAt?: boolean
  }

  export type InventoryUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventoryId" | "usedQuantity" | "usageType" | "usedById" | "fieldId" | "processId" | "createdAt", ExtArgs["result"]["inventoryUsage"]>
  export type InventoryUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    usedBy?: boolean | UserDefaultArgs<ExtArgs>
    field?: boolean | InventoryUsage$fieldArgs<ExtArgs>
    process?: boolean | InventoryUsage$processArgs<ExtArgs>
    notifications?: boolean | InventoryUsage$notificationsArgs<ExtArgs>
    _count?: boolean | InventoryUsageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryUsage"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
      usedBy: Prisma.$UserPayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs> | null
      process: Prisma.$ProcessPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventoryId: string
      usedQuantity: number
      usageType: $Enums.UsageType
      usedById: string
      fieldId: string | null
      processId: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryUsage"]>
    composites: {}
  }

  type InventoryUsageGetPayload<S extends boolean | null | undefined | InventoryUsageDefaultArgs> = $Result.GetResult<Prisma.$InventoryUsagePayload, S>

  type InventoryUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryUsageCountAggregateInputType | true
    }

  export interface InventoryUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryUsage'], meta: { name: 'InventoryUsage' } }
    /**
     * Find zero or one InventoryUsage that matches the filter.
     * @param {InventoryUsageFindUniqueArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryUsageFindUniqueArgs>(args: SelectSubset<T, InventoryUsageFindUniqueArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryUsageFindUniqueOrThrowArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageFindFirstArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryUsageFindFirstArgs>(args?: SelectSubset<T, InventoryUsageFindFirstArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageFindFirstOrThrowArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryUsages
     * const inventoryUsages = await prisma.inventoryUsage.findMany()
     * 
     * // Get first 10 InventoryUsages
     * const inventoryUsages = await prisma.inventoryUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryUsageWithIdOnly = await prisma.inventoryUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryUsageFindManyArgs>(args?: SelectSubset<T, InventoryUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryUsage.
     * @param {InventoryUsageCreateArgs} args - Arguments to create a InventoryUsage.
     * @example
     * // Create one InventoryUsage
     * const InventoryUsage = await prisma.inventoryUsage.create({
     *   data: {
     *     // ... data to create a InventoryUsage
     *   }
     * })
     * 
     */
    create<T extends InventoryUsageCreateArgs>(args: SelectSubset<T, InventoryUsageCreateArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryUsages.
     * @param {InventoryUsageCreateManyArgs} args - Arguments to create many InventoryUsages.
     * @example
     * // Create many InventoryUsages
     * const inventoryUsage = await prisma.inventoryUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryUsageCreateManyArgs>(args?: SelectSubset<T, InventoryUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryUsage.
     * @param {InventoryUsageDeleteArgs} args - Arguments to delete one InventoryUsage.
     * @example
     * // Delete one InventoryUsage
     * const InventoryUsage = await prisma.inventoryUsage.delete({
     *   where: {
     *     // ... filter to delete one InventoryUsage
     *   }
     * })
     * 
     */
    delete<T extends InventoryUsageDeleteArgs>(args: SelectSubset<T, InventoryUsageDeleteArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryUsage.
     * @param {InventoryUsageUpdateArgs} args - Arguments to update one InventoryUsage.
     * @example
     * // Update one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUsageUpdateArgs>(args: SelectSubset<T, InventoryUsageUpdateArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryUsages.
     * @param {InventoryUsageDeleteManyArgs} args - Arguments to filter InventoryUsages to delete.
     * @example
     * // Delete a few InventoryUsages
     * const { count } = await prisma.inventoryUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryUsageDeleteManyArgs>(args?: SelectSubset<T, InventoryUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryUsages
     * const inventoryUsage = await prisma.inventoryUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUsageUpdateManyArgs>(args: SelectSubset<T, InventoryUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryUsage.
     * @param {InventoryUsageUpsertArgs} args - Arguments to update or create a InventoryUsage.
     * @example
     * // Update or create a InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.upsert({
     *   create: {
     *     // ... data to create a InventoryUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryUsage we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUsageUpsertArgs>(args: SelectSubset<T, InventoryUsageUpsertArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryUsages that matches the filter.
     * @param {InventoryUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const inventoryUsage = await prisma.inventoryUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InventoryUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a InventoryUsage.
     * @param {InventoryUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const inventoryUsage = await prisma.inventoryUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InventoryUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of InventoryUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageCountArgs} args - Arguments to filter InventoryUsages to count.
     * @example
     * // Count the number of InventoryUsages
     * const count = await prisma.inventoryUsage.count({
     *   where: {
     *     // ... the filter for the InventoryUsages we want to count
     *   }
     * })
    **/
    count<T extends InventoryUsageCountArgs>(
      args?: Subset<T, InventoryUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryUsageAggregateArgs>(args: Subset<T, InventoryUsageAggregateArgs>): Prisma.PrismaPromise<GetInventoryUsageAggregateType<T>>

    /**
     * Group by InventoryUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryUsageGroupByArgs['orderBy'] }
        : { orderBy?: InventoryUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryUsage model
   */
  readonly fields: InventoryUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends InventoryUsage$fieldArgs<ExtArgs> = {}>(args?: Subset<T, InventoryUsage$fieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    process<T extends InventoryUsage$processArgs<ExtArgs> = {}>(args?: Subset<T, InventoryUsage$processArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends InventoryUsage$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryUsage$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryUsage model
   */
  interface InventoryUsageFieldRefs {
    readonly id: FieldRef<"InventoryUsage", 'String'>
    readonly inventoryId: FieldRef<"InventoryUsage", 'String'>
    readonly usedQuantity: FieldRef<"InventoryUsage", 'Float'>
    readonly usageType: FieldRef<"InventoryUsage", 'UsageType'>
    readonly usedById: FieldRef<"InventoryUsage", 'String'>
    readonly fieldId: FieldRef<"InventoryUsage", 'String'>
    readonly processId: FieldRef<"InventoryUsage", 'String'>
    readonly createdAt: FieldRef<"InventoryUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryUsage findUnique
   */
  export type InventoryUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage findUniqueOrThrow
   */
  export type InventoryUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage findFirst
   */
  export type InventoryUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsages.
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsages.
     */
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryUsage findFirstOrThrow
   */
  export type InventoryUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsages.
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsages.
     */
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryUsage findMany
   */
  export type InventoryUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsages to fetch.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryUsages.
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryUsage create
   */
  export type InventoryUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryUsage.
     */
    data: XOR<InventoryUsageCreateInput, InventoryUsageUncheckedCreateInput>
  }

  /**
   * InventoryUsage createMany
   */
  export type InventoryUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryUsages.
     */
    data: InventoryUsageCreateManyInput | InventoryUsageCreateManyInput[]
  }

  /**
   * InventoryUsage update
   */
  export type InventoryUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryUsage.
     */
    data: XOR<InventoryUsageUpdateInput, InventoryUsageUncheckedUpdateInput>
    /**
     * Choose, which InventoryUsage to update.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage updateMany
   */
  export type InventoryUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryUsages.
     */
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUsages to update
     */
    where?: InventoryUsageWhereInput
    /**
     * Limit how many InventoryUsages to update.
     */
    limit?: number
  }

  /**
   * InventoryUsage upsert
   */
  export type InventoryUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryUsage to update in case it exists.
     */
    where: InventoryUsageWhereUniqueInput
    /**
     * In case the InventoryUsage found by the `where` argument doesn't exist, create a new InventoryUsage with this data.
     */
    create: XOR<InventoryUsageCreateInput, InventoryUsageUncheckedCreateInput>
    /**
     * In case the InventoryUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUsageUpdateInput, InventoryUsageUncheckedUpdateInput>
  }

  /**
   * InventoryUsage delete
   */
  export type InventoryUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter which InventoryUsage to delete.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage deleteMany
   */
  export type InventoryUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUsages to delete
     */
    where?: InventoryUsageWhereInput
    /**
     * Limit how many InventoryUsages to delete.
     */
    limit?: number
  }

  /**
   * InventoryUsage findRaw
   */
  export type InventoryUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InventoryUsage aggregateRaw
   */
  export type InventoryUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InventoryUsage.field
   */
  export type InventoryUsage$fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * InventoryUsage.process
   */
  export type InventoryUsage$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
  }

  /**
   * InventoryUsage.notifications
   */
  export type InventoryUsage$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * InventoryUsage without action
   */
  export type InventoryUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
  }


  /**
   * Model Process
   */

  export type AggregateProcess = {
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  export type ProcessAvgAggregateOutputType = {
    totalArea: number | null
    processedArea: number | null
    processedPercentage: number | null
  }

  export type ProcessSumAggregateOutputType = {
    totalArea: number | null
    processedArea: number | null
    processedPercentage: number | null
  }

  export type ProcessMinAggregateOutputType = {
    id: string | null
    type: $Enums.ProcessType | null
    status: $Enums.ProcessStatus | null
    fieldId: string | null
    workerId: string | null
    date: Date | null
    description: string | null
    totalArea: number | null
    processedArea: number | null
    processedPercentage: number | null
    seasonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ProcessType | null
    status: $Enums.ProcessStatus | null
    fieldId: string | null
    workerId: string | null
    date: Date | null
    description: string | null
    totalArea: number | null
    processedArea: number | null
    processedPercentage: number | null
    seasonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessCountAggregateOutputType = {
    id: number
    type: number
    status: number
    fieldId: number
    workerId: number
    date: number
    description: number
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId: number
    inventoryDistribution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessAvgAggregateInputType = {
    totalArea?: true
    processedArea?: true
    processedPercentage?: true
  }

  export type ProcessSumAggregateInputType = {
    totalArea?: true
    processedArea?: true
    processedPercentage?: true
  }

  export type ProcessMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    fieldId?: true
    workerId?: true
    date?: true
    description?: true
    totalArea?: true
    processedArea?: true
    processedPercentage?: true
    seasonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    fieldId?: true
    workerId?: true
    date?: true
    description?: true
    totalArea?: true
    processedArea?: true
    processedPercentage?: true
    seasonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    fieldId?: true
    workerId?: true
    date?: true
    description?: true
    totalArea?: true
    processedArea?: true
    processedPercentage?: true
    seasonId?: true
    inventoryDistribution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Process to aggregate.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processes
    **/
    _count?: true | ProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMaxAggregateInputType
  }

  export type GetProcessAggregateType<T extends ProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcess[P]>
      : GetScalarType<T[P], AggregateProcess[P]>
  }




  export type ProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithAggregationInput | ProcessOrderByWithAggregationInput[]
    by: ProcessScalarFieldEnum[] | ProcessScalarFieldEnum
    having?: ProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCountAggregateInputType | true
    _avg?: ProcessAvgAggregateInputType
    _sum?: ProcessSumAggregateInputType
    _min?: ProcessMinAggregateInputType
    _max?: ProcessMaxAggregateInputType
  }

  export type ProcessGroupByOutputType = {
    id: string
    type: $Enums.ProcessType
    status: $Enums.ProcessStatus
    fieldId: string | null
    workerId: string
    date: Date
    description: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId: string | null
    inventoryDistribution: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProcessCountAggregateOutputType | null
    _avg: ProcessAvgAggregateOutputType | null
    _sum: ProcessSumAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  type GetProcessGroupByPayload<T extends ProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    fieldId?: boolean
    workerId?: boolean
    date?: boolean
    description?: boolean
    totalArea?: boolean
    processedArea?: boolean
    processedPercentage?: boolean
    seasonId?: boolean
    inventoryDistribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    field?: boolean | Process$fieldArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | Process$seasonArgs<ExtArgs>
    inventoryUsages?: boolean | Process$inventoryUsagesArgs<ExtArgs>
    equipmentUsages?: boolean | Process$equipmentUsagesArgs<ExtArgs>
    processCosts?: boolean | Process$processCostsArgs<ExtArgs>
    notifications?: boolean | Process$notificationsArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>



  export type ProcessSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    fieldId?: boolean
    workerId?: boolean
    date?: boolean
    description?: boolean
    totalArea?: boolean
    processedArea?: boolean
    processedPercentage?: boolean
    seasonId?: boolean
    inventoryDistribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "fieldId" | "workerId" | "date" | "description" | "totalArea" | "processedArea" | "processedPercentage" | "seasonId" | "inventoryDistribution" | "createdAt" | "updatedAt", ExtArgs["result"]["process"]>
  export type ProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | Process$fieldArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | Process$seasonArgs<ExtArgs>
    inventoryUsages?: boolean | Process$inventoryUsagesArgs<ExtArgs>
    equipmentUsages?: boolean | Process$equipmentUsagesArgs<ExtArgs>
    processCosts?: boolean | Process$processCostsArgs<ExtArgs>
    notifications?: boolean | Process$notificationsArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Process"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs> | null
      worker: Prisma.$UserPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs> | null
      inventoryUsages: Prisma.$InventoryUsagePayload<ExtArgs>[]
      equipmentUsages: Prisma.$EquipmentUsagePayload<ExtArgs>[]
      processCosts: Prisma.$ProcessCostPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ProcessType
      status: $Enums.ProcessStatus
      fieldId: string | null
      workerId: string
      date: Date
      description: string | null
      totalArea: number
      processedArea: number
      processedPercentage: number
      seasonId: string | null
      inventoryDistribution: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["process"]>
    composites: {}
  }

  type ProcessGetPayload<S extends boolean | null | undefined | ProcessDefaultArgs> = $Result.GetResult<Prisma.$ProcessPayload, S>

  type ProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessCountAggregateInputType | true
    }

  export interface ProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Process'], meta: { name: 'Process' } }
    /**
     * Find zero or one Process that matches the filter.
     * @param {ProcessFindUniqueArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessFindUniqueArgs>(args: SelectSubset<T, ProcessFindUniqueArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Process that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessFindUniqueOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessFindFirstArgs>(args?: SelectSubset<T, ProcessFindFirstArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processes
     * const processes = await prisma.process.findMany()
     * 
     * // Get first 10 Processes
     * const processes = await prisma.process.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processWithIdOnly = await prisma.process.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessFindManyArgs>(args?: SelectSubset<T, ProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Process.
     * @param {ProcessCreateArgs} args - Arguments to create a Process.
     * @example
     * // Create one Process
     * const Process = await prisma.process.create({
     *   data: {
     *     // ... data to create a Process
     *   }
     * })
     * 
     */
    create<T extends ProcessCreateArgs>(args: SelectSubset<T, ProcessCreateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Processes.
     * @param {ProcessCreateManyArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCreateManyArgs>(args?: SelectSubset<T, ProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Process.
     * @param {ProcessDeleteArgs} args - Arguments to delete one Process.
     * @example
     * // Delete one Process
     * const Process = await prisma.process.delete({
     *   where: {
     *     // ... filter to delete one Process
     *   }
     * })
     * 
     */
    delete<T extends ProcessDeleteArgs>(args: SelectSubset<T, ProcessDeleteArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Process.
     * @param {ProcessUpdateArgs} args - Arguments to update one Process.
     * @example
     * // Update one Process
     * const process = await prisma.process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessUpdateArgs>(args: SelectSubset<T, ProcessUpdateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Processes.
     * @param {ProcessDeleteManyArgs} args - Arguments to filter Processes to delete.
     * @example
     * // Delete a few Processes
     * const { count } = await prisma.process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessDeleteManyArgs>(args?: SelectSubset<T, ProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessUpdateManyArgs>(args: SelectSubset<T, ProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Process.
     * @param {ProcessUpsertArgs} args - Arguments to update or create a Process.
     * @example
     * // Update or create a Process
     * const process = await prisma.process.upsert({
     *   create: {
     *     // ... data to create a Process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Process we want to update
     *   }
     * })
     */
    upsert<T extends ProcessUpsertArgs>(args: SelectSubset<T, ProcessUpsertArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Processes that matches the filter.
     * @param {ProcessFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const process = await prisma.process.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProcessFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Process.
     * @param {ProcessAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const process = await prisma.process.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProcessAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCountArgs} args - Arguments to filter Processes to count.
     * @example
     * // Count the number of Processes
     * const count = await prisma.process.count({
     *   where: {
     *     // ... the filter for the Processes we want to count
     *   }
     * })
    **/
    count<T extends ProcessCountArgs>(
      args?: Subset<T, ProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessAggregateArgs>(args: Subset<T, ProcessAggregateArgs>): Prisma.PrismaPromise<GetProcessAggregateType<T>>

    /**
     * Group by Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessGroupByArgs['orderBy'] }
        : { orderBy?: ProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Process model
   */
  readonly fields: ProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends Process$fieldArgs<ExtArgs> = {}>(args?: Subset<T, Process$fieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends Process$seasonArgs<ExtArgs> = {}>(args?: Subset<T, Process$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventoryUsages<T extends Process$inventoryUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Process$inventoryUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipmentUsages<T extends Process$equipmentUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Process$equipmentUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processCosts<T extends Process$processCostsArgs<ExtArgs> = {}>(args?: Subset<T, Process$processCostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Process$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Process$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Process model
   */
  interface ProcessFieldRefs {
    readonly id: FieldRef<"Process", 'String'>
    readonly type: FieldRef<"Process", 'ProcessType'>
    readonly status: FieldRef<"Process", 'ProcessStatus'>
    readonly fieldId: FieldRef<"Process", 'String'>
    readonly workerId: FieldRef<"Process", 'String'>
    readonly date: FieldRef<"Process", 'DateTime'>
    readonly description: FieldRef<"Process", 'String'>
    readonly totalArea: FieldRef<"Process", 'Float'>
    readonly processedArea: FieldRef<"Process", 'Float'>
    readonly processedPercentage: FieldRef<"Process", 'Float'>
    readonly seasonId: FieldRef<"Process", 'String'>
    readonly inventoryDistribution: FieldRef<"Process", 'Json'>
    readonly createdAt: FieldRef<"Process", 'DateTime'>
    readonly updatedAt: FieldRef<"Process", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Process findUnique
   */
  export type ProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findUniqueOrThrow
   */
  export type ProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process findFirst
   */
  export type ProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findFirstOrThrow
   */
  export type ProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process findMany
   */
  export type ProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Processes to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Process create
   */
  export type ProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a Process.
     */
    data: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
  }

  /**
   * Process createMany
   */
  export type ProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
  }

  /**
   * Process update
   */
  export type ProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a Process.
     */
    data: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    /**
     * Choose, which Process to update.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process updateMany
   */
  export type ProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to update.
     */
    limit?: number
  }

  /**
   * Process upsert
   */
  export type ProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the Process to update in case it exists.
     */
    where: ProcessWhereUniqueInput
    /**
     * In case the Process found by the `where` argument doesn't exist, create a new Process with this data.
     */
    create: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    /**
     * In case the Process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
  }

  /**
   * Process delete
   */
  export type ProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter which Process to delete.
     */
    where: ProcessWhereUniqueInput
  }

  /**
   * Process deleteMany
   */
  export type ProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processes to delete
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to delete.
     */
    limit?: number
  }

  /**
   * Process findRaw
   */
  export type ProcessFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Process aggregateRaw
   */
  export type ProcessAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Process.field
   */
  export type Process$fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * Process.season
   */
  export type Process$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * Process.inventoryUsages
   */
  export type Process$inventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    cursor?: InventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * Process.equipmentUsages
   */
  export type Process$equipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    where?: EquipmentUsageWhereInput
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    cursor?: EquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentUsageScalarFieldEnum | EquipmentUsageScalarFieldEnum[]
  }

  /**
   * Process.processCosts
   */
  export type Process$processCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    where?: ProcessCostWhereInput
    orderBy?: ProcessCostOrderByWithRelationInput | ProcessCostOrderByWithRelationInput[]
    cursor?: ProcessCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessCostScalarFieldEnum | ProcessCostScalarFieldEnum[]
  }

  /**
   * Process.notifications
   */
  export type Process$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Process without action
   */
  export type ProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    priority: $Enums.NotificationPriority | null
    isRead: boolean | null
    isArchived: boolean | null
    link: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    receiverId: string | null
    senderId: string | null
    processId: string | null
    debtId: string | null
    purchaseId: string | null
    inventoryId: string | null
    irrigationId: string | null
    fieldId: string | null
    seasonId: string | null
    cropId: string | null
    wellId: string | null
    processingLogId: string | null
    invoiceId: string | null
    inventoryUsageId: string | null
    transactionId: string | null
    paymentId: string | null
    contributorId: string | null
    approvalId: string | null
    equipmentId: string | null
    equipmentUsageId: string | null
    processCostId: string | null
    fieldExpenseId: string | null
    ownerExpenseId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    priority: $Enums.NotificationPriority | null
    isRead: boolean | null
    isArchived: boolean | null
    link: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    receiverId: string | null
    senderId: string | null
    processId: string | null
    debtId: string | null
    purchaseId: string | null
    inventoryId: string | null
    irrigationId: string | null
    fieldId: string | null
    seasonId: string | null
    cropId: string | null
    wellId: string | null
    processingLogId: string | null
    invoiceId: string | null
    inventoryUsageId: string | null
    transactionId: string | null
    paymentId: string | null
    contributorId: string | null
    approvalId: string | null
    equipmentId: string | null
    equipmentUsageId: string | null
    processCostId: string | null
    fieldExpenseId: string | null
    ownerExpenseId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    priority: number
    isRead: number
    isArchived: number
    link: number
    expiresAt: number
    targetRoles: number
    createdAt: number
    updatedAt: number
    receiverId: number
    senderId: number
    processId: number
    debtId: number
    purchaseId: number
    inventoryId: number
    irrigationId: number
    fieldId: number
    seasonId: number
    cropId: number
    wellId: number
    processingLogId: number
    invoiceId: number
    inventoryUsageId: number
    transactionId: number
    paymentId: number
    contributorId: number
    approvalId: number
    equipmentId: number
    equipmentUsageId: number
    processCostId: number
    fieldExpenseId: number
    ownerExpenseId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    isArchived?: true
    link?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    receiverId?: true
    senderId?: true
    processId?: true
    debtId?: true
    purchaseId?: true
    inventoryId?: true
    irrigationId?: true
    fieldId?: true
    seasonId?: true
    cropId?: true
    wellId?: true
    processingLogId?: true
    invoiceId?: true
    inventoryUsageId?: true
    transactionId?: true
    paymentId?: true
    contributorId?: true
    approvalId?: true
    equipmentId?: true
    equipmentUsageId?: true
    processCostId?: true
    fieldExpenseId?: true
    ownerExpenseId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    isArchived?: true
    link?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    receiverId?: true
    senderId?: true
    processId?: true
    debtId?: true
    purchaseId?: true
    inventoryId?: true
    irrigationId?: true
    fieldId?: true
    seasonId?: true
    cropId?: true
    wellId?: true
    processingLogId?: true
    invoiceId?: true
    inventoryUsageId?: true
    transactionId?: true
    paymentId?: true
    contributorId?: true
    approvalId?: true
    equipmentId?: true
    equipmentUsageId?: true
    processCostId?: true
    fieldExpenseId?: true
    ownerExpenseId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    isArchived?: true
    link?: true
    expiresAt?: true
    targetRoles?: true
    createdAt?: true
    updatedAt?: true
    receiverId?: true
    senderId?: true
    processId?: true
    debtId?: true
    purchaseId?: true
    inventoryId?: true
    irrigationId?: true
    fieldId?: true
    seasonId?: true
    cropId?: true
    wellId?: true
    processingLogId?: true
    invoiceId?: true
    inventoryUsageId?: true
    transactionId?: true
    paymentId?: true
    contributorId?: true
    approvalId?: true
    equipmentId?: true
    equipmentUsageId?: true
    processCostId?: true
    fieldExpenseId?: true
    ownerExpenseId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority: $Enums.NotificationPriority
    isRead: boolean
    isArchived: boolean
    link: string | null
    expiresAt: Date | null
    targetRoles: $Enums.Role[]
    createdAt: Date
    updatedAt: Date
    receiverId: string
    senderId: string | null
    processId: string | null
    debtId: string | null
    purchaseId: string | null
    inventoryId: string | null
    irrigationId: string | null
    fieldId: string | null
    seasonId: string | null
    cropId: string | null
    wellId: string | null
    processingLogId: string | null
    invoiceId: string | null
    inventoryUsageId: string | null
    transactionId: string | null
    paymentId: string | null
    contributorId: string | null
    approvalId: string | null
    equipmentId: string | null
    equipmentUsageId: string | null
    processCostId: string | null
    fieldExpenseId: string | null
    ownerExpenseId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    isArchived?: boolean
    link?: boolean
    expiresAt?: boolean
    targetRoles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    receiverId?: boolean
    senderId?: boolean
    processId?: boolean
    debtId?: boolean
    purchaseId?: boolean
    inventoryId?: boolean
    irrigationId?: boolean
    fieldId?: boolean
    seasonId?: boolean
    cropId?: boolean
    wellId?: boolean
    processingLogId?: boolean
    invoiceId?: boolean
    inventoryUsageId?: boolean
    transactionId?: boolean
    paymentId?: boolean
    contributorId?: boolean
    approvalId?: boolean
    equipmentId?: boolean
    equipmentUsageId?: boolean
    processCostId?: boolean
    fieldExpenseId?: boolean
    ownerExpenseId?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
    process?: boolean | Notification$processArgs<ExtArgs>
    debt?: boolean | Notification$debtArgs<ExtArgs>
    purchase?: boolean | Notification$purchaseArgs<ExtArgs>
    inventory?: boolean | Notification$inventoryArgs<ExtArgs>
    irrigation?: boolean | Notification$irrigationArgs<ExtArgs>
    field?: boolean | Notification$fieldArgs<ExtArgs>
    season?: boolean | Notification$seasonArgs<ExtArgs>
    crop?: boolean | Notification$cropArgs<ExtArgs>
    well?: boolean | Notification$wellArgs<ExtArgs>
    processingLog?: boolean | Notification$processingLogArgs<ExtArgs>
    invoice?: boolean | Notification$invoiceArgs<ExtArgs>
    inventoryUsage?: boolean | Notification$inventoryUsageArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    contributor?: boolean | Notification$contributorArgs<ExtArgs>
    approval?: boolean | Notification$approvalArgs<ExtArgs>
    equipment?: boolean | Notification$equipmentArgs<ExtArgs>
    equipmentUsage?: boolean | Notification$equipmentUsageArgs<ExtArgs>
    processCost?: boolean | Notification$processCostArgs<ExtArgs>
    fieldExpense?: boolean | Notification$fieldExpenseArgs<ExtArgs>
    ownerExpense?: boolean | Notification$ownerExpenseArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    isArchived?: boolean
    link?: boolean
    expiresAt?: boolean
    targetRoles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    receiverId?: boolean
    senderId?: boolean
    processId?: boolean
    debtId?: boolean
    purchaseId?: boolean
    inventoryId?: boolean
    irrigationId?: boolean
    fieldId?: boolean
    seasonId?: boolean
    cropId?: boolean
    wellId?: boolean
    processingLogId?: boolean
    invoiceId?: boolean
    inventoryUsageId?: boolean
    transactionId?: boolean
    paymentId?: boolean
    contributorId?: boolean
    approvalId?: boolean
    equipmentId?: boolean
    equipmentUsageId?: boolean
    processCostId?: boolean
    fieldExpenseId?: boolean
    ownerExpenseId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "type" | "priority" | "isRead" | "isArchived" | "link" | "expiresAt" | "targetRoles" | "createdAt" | "updatedAt" | "receiverId" | "senderId" | "processId" | "debtId" | "purchaseId" | "inventoryId" | "irrigationId" | "fieldId" | "seasonId" | "cropId" | "wellId" | "processingLogId" | "invoiceId" | "inventoryUsageId" | "transactionId" | "paymentId" | "contributorId" | "approvalId" | "equipmentId" | "equipmentUsageId" | "processCostId" | "fieldExpenseId" | "ownerExpenseId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
    process?: boolean | Notification$processArgs<ExtArgs>
    debt?: boolean | Notification$debtArgs<ExtArgs>
    purchase?: boolean | Notification$purchaseArgs<ExtArgs>
    inventory?: boolean | Notification$inventoryArgs<ExtArgs>
    irrigation?: boolean | Notification$irrigationArgs<ExtArgs>
    field?: boolean | Notification$fieldArgs<ExtArgs>
    season?: boolean | Notification$seasonArgs<ExtArgs>
    crop?: boolean | Notification$cropArgs<ExtArgs>
    well?: boolean | Notification$wellArgs<ExtArgs>
    processingLog?: boolean | Notification$processingLogArgs<ExtArgs>
    invoice?: boolean | Notification$invoiceArgs<ExtArgs>
    inventoryUsage?: boolean | Notification$inventoryUsageArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    contributor?: boolean | Notification$contributorArgs<ExtArgs>
    approval?: boolean | Notification$approvalArgs<ExtArgs>
    equipment?: boolean | Notification$equipmentArgs<ExtArgs>
    equipmentUsage?: boolean | Notification$equipmentUsageArgs<ExtArgs>
    processCost?: boolean | Notification$processCostArgs<ExtArgs>
    fieldExpense?: boolean | Notification$fieldExpenseArgs<ExtArgs>
    ownerExpense?: boolean | Notification$ownerExpenseArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      receiver: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
      process: Prisma.$ProcessPayload<ExtArgs> | null
      debt: Prisma.$DebtPayload<ExtArgs> | null
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs> | null
      irrigation: Prisma.$IrrigationLogPayload<ExtArgs> | null
      field: Prisma.$FieldPayload<ExtArgs> | null
      season: Prisma.$SeasonPayload<ExtArgs> | null
      crop: Prisma.$CropPayload<ExtArgs> | null
      well: Prisma.$WellPayload<ExtArgs> | null
      processingLog: Prisma.$ProcessingLogPayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      inventoryUsage: Prisma.$InventoryUsagePayload<ExtArgs> | null
      transaction: Prisma.$InventoryTransactionPayload<ExtArgs> | null
      payment: Prisma.$PaymentHistoryPayload<ExtArgs> | null
      contributor: Prisma.$PurchaseContributorPayload<ExtArgs> | null
      approval: Prisma.$PurchaseApprovalPayload<ExtArgs> | null
      equipment: Prisma.$EquipmentPayload<ExtArgs> | null
      equipmentUsage: Prisma.$EquipmentUsagePayload<ExtArgs> | null
      processCost: Prisma.$ProcessCostPayload<ExtArgs> | null
      fieldExpense: Prisma.$FieldExpensePayload<ExtArgs> | null
      ownerExpense: Prisma.$FieldOwnerExpensePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: $Enums.NotificationType
      priority: $Enums.NotificationPriority
      isRead: boolean
      isArchived: boolean
      link: string | null
      expiresAt: Date | null
      targetRoles: $Enums.Role[]
      createdAt: Date
      updatedAt: Date
      receiverId: string
      senderId: string | null
      processId: string | null
      debtId: string | null
      purchaseId: string | null
      inventoryId: string | null
      irrigationId: string | null
      fieldId: string | null
      seasonId: string | null
      cropId: string | null
      wellId: string | null
      processingLogId: string | null
      invoiceId: string | null
      inventoryUsageId: string | null
      transactionId: string | null
      paymentId: string | null
      contributorId: string | null
      approvalId: string | null
      equipmentId: string | null
      equipmentUsageId: string | null
      processCostId: string | null
      fieldExpenseId: string | null
      ownerExpenseId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends Notification$senderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    process<T extends Notification$processArgs<ExtArgs> = {}>(args?: Subset<T, Notification$processArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    debt<T extends Notification$debtArgs<ExtArgs> = {}>(args?: Subset<T, Notification$debtArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase<T extends Notification$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Notification$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Notification$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Notification$inventoryArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    irrigation<T extends Notification$irrigationArgs<ExtArgs> = {}>(args?: Subset<T, Notification$irrigationArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    field<T extends Notification$fieldArgs<ExtArgs> = {}>(args?: Subset<T, Notification$fieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    season<T extends Notification$seasonArgs<ExtArgs> = {}>(args?: Subset<T, Notification$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    crop<T extends Notification$cropArgs<ExtArgs> = {}>(args?: Subset<T, Notification$cropArgs<ExtArgs>>): Prisma__CropClient<$Result.GetResult<Prisma.$CropPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    well<T extends Notification$wellArgs<ExtArgs> = {}>(args?: Subset<T, Notification$wellArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processingLog<T extends Notification$processingLogArgs<ExtArgs> = {}>(args?: Subset<T, Notification$processingLogArgs<ExtArgs>>): Prisma__ProcessingLogClient<$Result.GetResult<Prisma.$ProcessingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Notification$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Notification$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventoryUsage<T extends Notification$inventoryUsageArgs<ExtArgs> = {}>(args?: Subset<T, Notification$inventoryUsageArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends Notification$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Notification$transactionArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Notification$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$paymentArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contributor<T extends Notification$contributorArgs<ExtArgs> = {}>(args?: Subset<T, Notification$contributorArgs<ExtArgs>>): Prisma__PurchaseContributorClient<$Result.GetResult<Prisma.$PurchaseContributorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approval<T extends Notification$approvalArgs<ExtArgs> = {}>(args?: Subset<T, Notification$approvalArgs<ExtArgs>>): Prisma__PurchaseApprovalClient<$Result.GetResult<Prisma.$PurchaseApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    equipment<T extends Notification$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$equipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    equipmentUsage<T extends Notification$equipmentUsageArgs<ExtArgs> = {}>(args?: Subset<T, Notification$equipmentUsageArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processCost<T extends Notification$processCostArgs<ExtArgs> = {}>(args?: Subset<T, Notification$processCostArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fieldExpense<T extends Notification$fieldExpenseArgs<ExtArgs> = {}>(args?: Subset<T, Notification$fieldExpenseArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownerExpense<T extends Notification$ownerExpenseArgs<ExtArgs> = {}>(args?: Subset<T, Notification$ownerExpenseArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly isArchived: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
    readonly targetRoles: FieldRef<"Notification", 'Role[]'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly receiverId: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly processId: FieldRef<"Notification", 'String'>
    readonly debtId: FieldRef<"Notification", 'String'>
    readonly purchaseId: FieldRef<"Notification", 'String'>
    readonly inventoryId: FieldRef<"Notification", 'String'>
    readonly irrigationId: FieldRef<"Notification", 'String'>
    readonly fieldId: FieldRef<"Notification", 'String'>
    readonly seasonId: FieldRef<"Notification", 'String'>
    readonly cropId: FieldRef<"Notification", 'String'>
    readonly wellId: FieldRef<"Notification", 'String'>
    readonly processingLogId: FieldRef<"Notification", 'String'>
    readonly invoiceId: FieldRef<"Notification", 'String'>
    readonly inventoryUsageId: FieldRef<"Notification", 'String'>
    readonly transactionId: FieldRef<"Notification", 'String'>
    readonly paymentId: FieldRef<"Notification", 'String'>
    readonly contributorId: FieldRef<"Notification", 'String'>
    readonly approvalId: FieldRef<"Notification", 'String'>
    readonly equipmentId: FieldRef<"Notification", 'String'>
    readonly equipmentUsageId: FieldRef<"Notification", 'String'>
    readonly processCostId: FieldRef<"Notification", 'String'>
    readonly fieldExpenseId: FieldRef<"Notification", 'String'>
    readonly ownerExpenseId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification.sender
   */
  export type Notification$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification.process
   */
  export type Notification$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
  }

  /**
   * Notification.debt
   */
  export type Notification$debtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
  }

  /**
   * Notification.purchase
   */
  export type Notification$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * Notification.inventory
   */
  export type Notification$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
  }

  /**
   * Notification.irrigation
   */
  export type Notification$irrigationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    where?: IrrigationLogWhereInput
  }

  /**
   * Notification.field
   */
  export type Notification$fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * Notification.season
   */
  export type Notification$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * Notification.crop
   */
  export type Notification$cropArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crop
     */
    select?: CropSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crop
     */
    omit?: CropOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CropInclude<ExtArgs> | null
    where?: CropWhereInput
  }

  /**
   * Notification.well
   */
  export type Notification$wellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Well
     */
    select?: WellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Well
     */
    omit?: WellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellInclude<ExtArgs> | null
    where?: WellWhereInput
  }

  /**
   * Notification.processingLog
   */
  export type Notification$processingLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessingLog
     */
    select?: ProcessingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessingLog
     */
    omit?: ProcessingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingLogInclude<ExtArgs> | null
    where?: ProcessingLogWhereInput
  }

  /**
   * Notification.invoice
   */
  export type Notification$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Notification.inventoryUsage
   */
  export type Notification$inventoryUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    where?: InventoryUsageWhereInput
  }

  /**
   * Notification.transaction
   */
  export type Notification$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
  }

  /**
   * Notification.payment
   */
  export type Notification$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentHistory
     */
    omit?: PaymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentHistoryInclude<ExtArgs> | null
    where?: PaymentHistoryWhereInput
  }

  /**
   * Notification.contributor
   */
  export type Notification$contributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseContributor
     */
    select?: PurchaseContributorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseContributor
     */
    omit?: PurchaseContributorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseContributorInclude<ExtArgs> | null
    where?: PurchaseContributorWhereInput
  }

  /**
   * Notification.approval
   */
  export type Notification$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseApproval
     */
    select?: PurchaseApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseApproval
     */
    omit?: PurchaseApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseApprovalInclude<ExtArgs> | null
    where?: PurchaseApprovalWhereInput
  }

  /**
   * Notification.equipment
   */
  export type Notification$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * Notification.equipmentUsage
   */
  export type Notification$equipmentUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    where?: EquipmentUsageWhereInput
  }

  /**
   * Notification.processCost
   */
  export type Notification$processCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    where?: ProcessCostWhereInput
  }

  /**
   * Notification.fieldExpense
   */
  export type Notification$fieldExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    where?: FieldExpenseWhereInput
  }

  /**
   * Notification.ownerExpense
   */
  export type Notification$ownerExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    where?: FieldOwnerExpenseWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    pushNotifications: boolean | null
    inAppNotifications: boolean | null
    dailyDigest: boolean | null
    notifyOnDebtReminders: boolean | null
    notifyOnPayments: boolean | null
    notifyOnProcessUpdates: boolean | null
    notifyOnInventoryAlerts: boolean | null
    notifyOnApprovals: boolean | null
    notifyOnIrrigation: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    pushNotifications: boolean | null
    inAppNotifications: boolean | null
    dailyDigest: boolean | null
    notifyOnDebtReminders: boolean | null
    notifyOnPayments: boolean | null
    notifyOnProcessUpdates: boolean | null
    notifyOnInventoryAlerts: boolean | null
    notifyOnApprovals: boolean | null
    notifyOnIrrigation: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    emailNotifications: number
    pushNotifications: number
    inAppNotifications: number
    dailyDigest: number
    notifyOnDebtReminders: number
    notifyOnPayments: number
    notifyOnProcessUpdates: number
    notifyOnInventoryAlerts: number
    notifyOnApprovals: number
    notifyOnIrrigation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    pushNotifications?: true
    inAppNotifications?: true
    dailyDigest?: true
    notifyOnDebtReminders?: true
    notifyOnPayments?: true
    notifyOnProcessUpdates?: true
    notifyOnInventoryAlerts?: true
    notifyOnApprovals?: true
    notifyOnIrrigation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    pushNotifications?: true
    inAppNotifications?: true
    dailyDigest?: true
    notifyOnDebtReminders?: true
    notifyOnPayments?: true
    notifyOnProcessUpdates?: true
    notifyOnInventoryAlerts?: true
    notifyOnApprovals?: true
    notifyOnIrrigation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    pushNotifications?: true
    inAppNotifications?: true
    dailyDigest?: true
    notifyOnDebtReminders?: true
    notifyOnPayments?: true
    notifyOnProcessUpdates?: true
    notifyOnInventoryAlerts?: true
    notifyOnApprovals?: true
    notifyOnIrrigation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    emailNotifications: boolean
    pushNotifications: boolean
    inAppNotifications: boolean
    dailyDigest: boolean
    notifyOnDebtReminders: boolean
    notifyOnPayments: boolean
    notifyOnProcessUpdates: boolean
    notifyOnInventoryAlerts: boolean
    notifyOnApprovals: boolean
    notifyOnIrrigation: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>



  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailNotifications" | "pushNotifications" | "inAppNotifications" | "dailyDigest" | "notifyOnDebtReminders" | "notifyOnPayments" | "notifyOnProcessUpdates" | "notifyOnInventoryAlerts" | "notifyOnApprovals" | "notifyOnIrrigation" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailNotifications: boolean
      pushNotifications: boolean
      inAppNotifications: boolean
      dailyDigest: boolean
      notifyOnDebtReminders: boolean
      notifyOnPayments: boolean
      notifyOnProcessUpdates: boolean
      notifyOnInventoryAlerts: boolean
      notifyOnApprovals: boolean
      notifyOnIrrigation: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * @param {NotificationPreferenceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notificationPreference = await prisma.notificationPreference.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationPreferenceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a NotificationPreference.
     * @param {NotificationPreferenceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notificationPreference = await prisma.notificationPreference.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationPreferenceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly emailNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly pushNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inAppNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly dailyDigest: FieldRef<"NotificationPreference", 'Boolean'>
    readonly notifyOnDebtReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly notifyOnPayments: FieldRef<"NotificationPreference", 'Boolean'>
    readonly notifyOnProcessUpdates: FieldRef<"NotificationPreference", 'Boolean'>
    readonly notifyOnInventoryAlerts: FieldRef<"NotificationPreference", 'Boolean'>
    readonly notifyOnApprovals: FieldRef<"NotificationPreference", 'Boolean'>
    readonly notifyOnIrrigation: FieldRef<"NotificationPreference", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference findRaw
   */
  export type NotificationPreferenceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * NotificationPreference aggregateRaw
   */
  export type NotificationPreferenceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    fuelConsumptionPerDecare: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    fuelConsumptionPerDecare: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.EquipmentType | null
    fuelConsumptionPerDecare: number | null
    description: string | null
    status: $Enums.EquipmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.EquipmentType | null
    fuelConsumptionPerDecare: number | null
    description: string | null
    status: $Enums.EquipmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    fuelConsumptionPerDecare: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    fuelConsumptionPerDecare?: true
  }

  export type EquipmentSumAggregateInputType = {
    fuelConsumptionPerDecare?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    fuelConsumptionPerDecare?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    fuelConsumptionPerDecare?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    fuelConsumptionPerDecare?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description: string | null
    status: $Enums.EquipmentStatus
    createdAt: Date
    updatedAt: Date
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    fuelConsumptionPerDecare?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerships?: boolean | Equipment$ownershipsArgs<ExtArgs>
    capabilities?: boolean | Equipment$capabilitiesArgs<ExtArgs>
    usages?: boolean | Equipment$usagesArgs<ExtArgs>
    notifications?: boolean | Equipment$notificationsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>



  export type EquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    fuelConsumptionPerDecare?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "fuelConsumptionPerDecare" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerships?: boolean | Equipment$ownershipsArgs<ExtArgs>
    capabilities?: boolean | Equipment$capabilitiesArgs<ExtArgs>
    usages?: boolean | Equipment$usagesArgs<ExtArgs>
    notifications?: boolean | Equipment$notificationsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      ownerships: Prisma.$EquipmentOwnershipPayload<ExtArgs>[]
      capabilities: Prisma.$EquipmentCapabilityPayload<ExtArgs>[]
      usages: Prisma.$EquipmentUsagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.EquipmentType
      fuelConsumptionPerDecare: number
      description: string | null
      status: $Enums.EquipmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * @param {EquipmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const equipment = await prisma.equipment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EquipmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Equipment.
     * @param {EquipmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const equipment = await prisma.equipment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EquipmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownerships<T extends Equipment$ownershipsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$ownershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capabilities<T extends Equipment$capabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$capabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usages<T extends Equipment$usagesArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Equipment$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'EquipmentType'>
    readonly fuelConsumptionPerDecare: FieldRef<"Equipment", 'Float'>
    readonly description: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'EquipmentStatus'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment findRaw
   */
  export type EquipmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Equipment aggregateRaw
   */
  export type EquipmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Equipment.ownerships
   */
  export type Equipment$ownershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    where?: EquipmentOwnershipWhereInput
    orderBy?: EquipmentOwnershipOrderByWithRelationInput | EquipmentOwnershipOrderByWithRelationInput[]
    cursor?: EquipmentOwnershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentOwnershipScalarFieldEnum | EquipmentOwnershipScalarFieldEnum[]
  }

  /**
   * Equipment.capabilities
   */
  export type Equipment$capabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    where?: EquipmentCapabilityWhereInput
    orderBy?: EquipmentCapabilityOrderByWithRelationInput | EquipmentCapabilityOrderByWithRelationInput[]
    cursor?: EquipmentCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentCapabilityScalarFieldEnum | EquipmentCapabilityScalarFieldEnum[]
  }

  /**
   * Equipment.usages
   */
  export type Equipment$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    where?: EquipmentUsageWhereInput
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    cursor?: EquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentUsageScalarFieldEnum | EquipmentUsageScalarFieldEnum[]
  }

  /**
   * Equipment.notifications
   */
  export type Equipment$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentOwnership
   */

  export type AggregateEquipmentOwnership = {
    _count: EquipmentOwnershipCountAggregateOutputType | null
    _avg: EquipmentOwnershipAvgAggregateOutputType | null
    _sum: EquipmentOwnershipSumAggregateOutputType | null
    _min: EquipmentOwnershipMinAggregateOutputType | null
    _max: EquipmentOwnershipMaxAggregateOutputType | null
  }

  export type EquipmentOwnershipAvgAggregateOutputType = {
    ownershipPercentage: number | null
  }

  export type EquipmentOwnershipSumAggregateOutputType = {
    ownershipPercentage: number | null
  }

  export type EquipmentOwnershipMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    userId: string | null
    ownershipPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentOwnershipMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    userId: string | null
    ownershipPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentOwnershipCountAggregateOutputType = {
    id: number
    equipmentId: number
    userId: number
    ownershipPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentOwnershipAvgAggregateInputType = {
    ownershipPercentage?: true
  }

  export type EquipmentOwnershipSumAggregateInputType = {
    ownershipPercentage?: true
  }

  export type EquipmentOwnershipMinAggregateInputType = {
    id?: true
    equipmentId?: true
    userId?: true
    ownershipPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentOwnershipMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    userId?: true
    ownershipPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentOwnershipCountAggregateInputType = {
    id?: true
    equipmentId?: true
    userId?: true
    ownershipPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentOwnershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentOwnership to aggregate.
     */
    where?: EquipmentOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentOwnerships to fetch.
     */
    orderBy?: EquipmentOwnershipOrderByWithRelationInput | EquipmentOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentOwnerships
    **/
    _count?: true | EquipmentOwnershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentOwnershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentOwnershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentOwnershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentOwnershipMaxAggregateInputType
  }

  export type GetEquipmentOwnershipAggregateType<T extends EquipmentOwnershipAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentOwnership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentOwnership[P]>
      : GetScalarType<T[P], AggregateEquipmentOwnership[P]>
  }




  export type EquipmentOwnershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentOwnershipWhereInput
    orderBy?: EquipmentOwnershipOrderByWithAggregationInput | EquipmentOwnershipOrderByWithAggregationInput[]
    by: EquipmentOwnershipScalarFieldEnum[] | EquipmentOwnershipScalarFieldEnum
    having?: EquipmentOwnershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentOwnershipCountAggregateInputType | true
    _avg?: EquipmentOwnershipAvgAggregateInputType
    _sum?: EquipmentOwnershipSumAggregateInputType
    _min?: EquipmentOwnershipMinAggregateInputType
    _max?: EquipmentOwnershipMaxAggregateInputType
  }

  export type EquipmentOwnershipGroupByOutputType = {
    id: string
    equipmentId: string
    userId: string
    ownershipPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: EquipmentOwnershipCountAggregateOutputType | null
    _avg: EquipmentOwnershipAvgAggregateOutputType | null
    _sum: EquipmentOwnershipSumAggregateOutputType | null
    _min: EquipmentOwnershipMinAggregateOutputType | null
    _max: EquipmentOwnershipMaxAggregateOutputType | null
  }

  type GetEquipmentOwnershipGroupByPayload<T extends EquipmentOwnershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentOwnershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentOwnershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentOwnershipGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentOwnershipGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentOwnershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    userId?: boolean
    ownershipPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentOwnership"]>



  export type EquipmentOwnershipSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    userId?: boolean
    ownershipPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentOwnershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentId" | "userId" | "ownershipPercentage" | "createdAt" | "updatedAt", ExtArgs["result"]["equipmentOwnership"]>
  export type EquipmentOwnershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EquipmentOwnershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentOwnership"
    objects: {
      equipment: Prisma.$EquipmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      userId: string
      ownershipPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentOwnership"]>
    composites: {}
  }

  type EquipmentOwnershipGetPayload<S extends boolean | null | undefined | EquipmentOwnershipDefaultArgs> = $Result.GetResult<Prisma.$EquipmentOwnershipPayload, S>

  type EquipmentOwnershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentOwnershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentOwnershipCountAggregateInputType | true
    }

  export interface EquipmentOwnershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentOwnership'], meta: { name: 'EquipmentOwnership' } }
    /**
     * Find zero or one EquipmentOwnership that matches the filter.
     * @param {EquipmentOwnershipFindUniqueArgs} args - Arguments to find a EquipmentOwnership
     * @example
     * // Get one EquipmentOwnership
     * const equipmentOwnership = await prisma.equipmentOwnership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentOwnershipFindUniqueArgs>(args: SelectSubset<T, EquipmentOwnershipFindUniqueArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentOwnership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentOwnershipFindUniqueOrThrowArgs} args - Arguments to find a EquipmentOwnership
     * @example
     * // Get one EquipmentOwnership
     * const equipmentOwnership = await prisma.equipmentOwnership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentOwnershipFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentOwnershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentOwnership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipFindFirstArgs} args - Arguments to find a EquipmentOwnership
     * @example
     * // Get one EquipmentOwnership
     * const equipmentOwnership = await prisma.equipmentOwnership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentOwnershipFindFirstArgs>(args?: SelectSubset<T, EquipmentOwnershipFindFirstArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentOwnership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipFindFirstOrThrowArgs} args - Arguments to find a EquipmentOwnership
     * @example
     * // Get one EquipmentOwnership
     * const equipmentOwnership = await prisma.equipmentOwnership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentOwnershipFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentOwnershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentOwnerships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentOwnerships
     * const equipmentOwnerships = await prisma.equipmentOwnership.findMany()
     * 
     * // Get first 10 EquipmentOwnerships
     * const equipmentOwnerships = await prisma.equipmentOwnership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentOwnershipWithIdOnly = await prisma.equipmentOwnership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentOwnershipFindManyArgs>(args?: SelectSubset<T, EquipmentOwnershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentOwnership.
     * @param {EquipmentOwnershipCreateArgs} args - Arguments to create a EquipmentOwnership.
     * @example
     * // Create one EquipmentOwnership
     * const EquipmentOwnership = await prisma.equipmentOwnership.create({
     *   data: {
     *     // ... data to create a EquipmentOwnership
     *   }
     * })
     * 
     */
    create<T extends EquipmentOwnershipCreateArgs>(args: SelectSubset<T, EquipmentOwnershipCreateArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentOwnerships.
     * @param {EquipmentOwnershipCreateManyArgs} args - Arguments to create many EquipmentOwnerships.
     * @example
     * // Create many EquipmentOwnerships
     * const equipmentOwnership = await prisma.equipmentOwnership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentOwnershipCreateManyArgs>(args?: SelectSubset<T, EquipmentOwnershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentOwnership.
     * @param {EquipmentOwnershipDeleteArgs} args - Arguments to delete one EquipmentOwnership.
     * @example
     * // Delete one EquipmentOwnership
     * const EquipmentOwnership = await prisma.equipmentOwnership.delete({
     *   where: {
     *     // ... filter to delete one EquipmentOwnership
     *   }
     * })
     * 
     */
    delete<T extends EquipmentOwnershipDeleteArgs>(args: SelectSubset<T, EquipmentOwnershipDeleteArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentOwnership.
     * @param {EquipmentOwnershipUpdateArgs} args - Arguments to update one EquipmentOwnership.
     * @example
     * // Update one EquipmentOwnership
     * const equipmentOwnership = await prisma.equipmentOwnership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentOwnershipUpdateArgs>(args: SelectSubset<T, EquipmentOwnershipUpdateArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentOwnerships.
     * @param {EquipmentOwnershipDeleteManyArgs} args - Arguments to filter EquipmentOwnerships to delete.
     * @example
     * // Delete a few EquipmentOwnerships
     * const { count } = await prisma.equipmentOwnership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentOwnershipDeleteManyArgs>(args?: SelectSubset<T, EquipmentOwnershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentOwnerships
     * const equipmentOwnership = await prisma.equipmentOwnership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentOwnershipUpdateManyArgs>(args: SelectSubset<T, EquipmentOwnershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentOwnership.
     * @param {EquipmentOwnershipUpsertArgs} args - Arguments to update or create a EquipmentOwnership.
     * @example
     * // Update or create a EquipmentOwnership
     * const equipmentOwnership = await prisma.equipmentOwnership.upsert({
     *   create: {
     *     // ... data to create a EquipmentOwnership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentOwnership we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentOwnershipUpsertArgs>(args: SelectSubset<T, EquipmentOwnershipUpsertArgs<ExtArgs>>): Prisma__EquipmentOwnershipClient<$Result.GetResult<Prisma.$EquipmentOwnershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentOwnerships that matches the filter.
     * @param {EquipmentOwnershipFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const equipmentOwnership = await prisma.equipmentOwnership.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EquipmentOwnershipFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EquipmentOwnership.
     * @param {EquipmentOwnershipAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const equipmentOwnership = await prisma.equipmentOwnership.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EquipmentOwnershipAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EquipmentOwnerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipCountArgs} args - Arguments to filter EquipmentOwnerships to count.
     * @example
     * // Count the number of EquipmentOwnerships
     * const count = await prisma.equipmentOwnership.count({
     *   where: {
     *     // ... the filter for the EquipmentOwnerships we want to count
     *   }
     * })
    **/
    count<T extends EquipmentOwnershipCountArgs>(
      args?: Subset<T, EquipmentOwnershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentOwnershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentOwnershipAggregateArgs>(args: Subset<T, EquipmentOwnershipAggregateArgs>): Prisma.PrismaPromise<GetEquipmentOwnershipAggregateType<T>>

    /**
     * Group by EquipmentOwnership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentOwnershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentOwnershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentOwnershipGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentOwnershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentOwnershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentOwnershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentOwnership model
   */
  readonly fields: EquipmentOwnershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentOwnership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentOwnershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentOwnership model
   */
  interface EquipmentOwnershipFieldRefs {
    readonly id: FieldRef<"EquipmentOwnership", 'String'>
    readonly equipmentId: FieldRef<"EquipmentOwnership", 'String'>
    readonly userId: FieldRef<"EquipmentOwnership", 'String'>
    readonly ownershipPercentage: FieldRef<"EquipmentOwnership", 'Float'>
    readonly createdAt: FieldRef<"EquipmentOwnership", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentOwnership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentOwnership findUnique
   */
  export type EquipmentOwnershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentOwnership to fetch.
     */
    where: EquipmentOwnershipWhereUniqueInput
  }

  /**
   * EquipmentOwnership findUniqueOrThrow
   */
  export type EquipmentOwnershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentOwnership to fetch.
     */
    where: EquipmentOwnershipWhereUniqueInput
  }

  /**
   * EquipmentOwnership findFirst
   */
  export type EquipmentOwnershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentOwnership to fetch.
     */
    where?: EquipmentOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentOwnerships to fetch.
     */
    orderBy?: EquipmentOwnershipOrderByWithRelationInput | EquipmentOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentOwnerships.
     */
    cursor?: EquipmentOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentOwnerships.
     */
    distinct?: EquipmentOwnershipScalarFieldEnum | EquipmentOwnershipScalarFieldEnum[]
  }

  /**
   * EquipmentOwnership findFirstOrThrow
   */
  export type EquipmentOwnershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentOwnership to fetch.
     */
    where?: EquipmentOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentOwnerships to fetch.
     */
    orderBy?: EquipmentOwnershipOrderByWithRelationInput | EquipmentOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentOwnerships.
     */
    cursor?: EquipmentOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentOwnerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentOwnerships.
     */
    distinct?: EquipmentOwnershipScalarFieldEnum | EquipmentOwnershipScalarFieldEnum[]
  }

  /**
   * EquipmentOwnership findMany
   */
  export type EquipmentOwnershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentOwnerships to fetch.
     */
    where?: EquipmentOwnershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentOwnerships to fetch.
     */
    orderBy?: EquipmentOwnershipOrderByWithRelationInput | EquipmentOwnershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentOwnerships.
     */
    cursor?: EquipmentOwnershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentOwnerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentOwnerships.
     */
    skip?: number
    distinct?: EquipmentOwnershipScalarFieldEnum | EquipmentOwnershipScalarFieldEnum[]
  }

  /**
   * EquipmentOwnership create
   */
  export type EquipmentOwnershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentOwnership.
     */
    data: XOR<EquipmentOwnershipCreateInput, EquipmentOwnershipUncheckedCreateInput>
  }

  /**
   * EquipmentOwnership createMany
   */
  export type EquipmentOwnershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentOwnerships.
     */
    data: EquipmentOwnershipCreateManyInput | EquipmentOwnershipCreateManyInput[]
  }

  /**
   * EquipmentOwnership update
   */
  export type EquipmentOwnershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentOwnership.
     */
    data: XOR<EquipmentOwnershipUpdateInput, EquipmentOwnershipUncheckedUpdateInput>
    /**
     * Choose, which EquipmentOwnership to update.
     */
    where: EquipmentOwnershipWhereUniqueInput
  }

  /**
   * EquipmentOwnership updateMany
   */
  export type EquipmentOwnershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentOwnerships.
     */
    data: XOR<EquipmentOwnershipUpdateManyMutationInput, EquipmentOwnershipUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentOwnerships to update
     */
    where?: EquipmentOwnershipWhereInput
    /**
     * Limit how many EquipmentOwnerships to update.
     */
    limit?: number
  }

  /**
   * EquipmentOwnership upsert
   */
  export type EquipmentOwnershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentOwnership to update in case it exists.
     */
    where: EquipmentOwnershipWhereUniqueInput
    /**
     * In case the EquipmentOwnership found by the `where` argument doesn't exist, create a new EquipmentOwnership with this data.
     */
    create: XOR<EquipmentOwnershipCreateInput, EquipmentOwnershipUncheckedCreateInput>
    /**
     * In case the EquipmentOwnership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentOwnershipUpdateInput, EquipmentOwnershipUncheckedUpdateInput>
  }

  /**
   * EquipmentOwnership delete
   */
  export type EquipmentOwnershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
    /**
     * Filter which EquipmentOwnership to delete.
     */
    where: EquipmentOwnershipWhereUniqueInput
  }

  /**
   * EquipmentOwnership deleteMany
   */
  export type EquipmentOwnershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentOwnerships to delete
     */
    where?: EquipmentOwnershipWhereInput
    /**
     * Limit how many EquipmentOwnerships to delete.
     */
    limit?: number
  }

  /**
   * EquipmentOwnership findRaw
   */
  export type EquipmentOwnershipFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EquipmentOwnership aggregateRaw
   */
  export type EquipmentOwnershipAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EquipmentOwnership without action
   */
  export type EquipmentOwnershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentOwnership
     */
    select?: EquipmentOwnershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentOwnership
     */
    omit?: EquipmentOwnershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentOwnershipInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentCapability
   */

  export type AggregateEquipmentCapability = {
    _count: EquipmentCapabilityCountAggregateOutputType | null
    _min: EquipmentCapabilityMinAggregateOutputType | null
    _max: EquipmentCapabilityMaxAggregateOutputType | null
  }

  export type EquipmentCapabilityMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    inventoryCategory: $Enums.InventoryCategory | null
    canUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCapabilityMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    inventoryCategory: $Enums.InventoryCategory | null
    canUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCapabilityCountAggregateOutputType = {
    id: number
    equipmentId: number
    inventoryCategory: number
    canUse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentCapabilityMinAggregateInputType = {
    id?: true
    equipmentId?: true
    inventoryCategory?: true
    canUse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCapabilityMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    inventoryCategory?: true
    canUse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCapabilityCountAggregateInputType = {
    id?: true
    equipmentId?: true
    inventoryCategory?: true
    canUse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentCapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentCapability to aggregate.
     */
    where?: EquipmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentCapabilities to fetch.
     */
    orderBy?: EquipmentCapabilityOrderByWithRelationInput | EquipmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentCapabilities
    **/
    _count?: true | EquipmentCapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentCapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentCapabilityMaxAggregateInputType
  }

  export type GetEquipmentCapabilityAggregateType<T extends EquipmentCapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentCapability[P]>
      : GetScalarType<T[P], AggregateEquipmentCapability[P]>
  }




  export type EquipmentCapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentCapabilityWhereInput
    orderBy?: EquipmentCapabilityOrderByWithAggregationInput | EquipmentCapabilityOrderByWithAggregationInput[]
    by: EquipmentCapabilityScalarFieldEnum[] | EquipmentCapabilityScalarFieldEnum
    having?: EquipmentCapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCapabilityCountAggregateInputType | true
    _min?: EquipmentCapabilityMinAggregateInputType
    _max?: EquipmentCapabilityMaxAggregateInputType
  }

  export type EquipmentCapabilityGroupByOutputType = {
    id: string
    equipmentId: string
    inventoryCategory: $Enums.InventoryCategory
    canUse: boolean
    createdAt: Date
    updatedAt: Date
    _count: EquipmentCapabilityCountAggregateOutputType | null
    _min: EquipmentCapabilityMinAggregateOutputType | null
    _max: EquipmentCapabilityMaxAggregateOutputType | null
  }

  type GetEquipmentCapabilityGroupByPayload<T extends EquipmentCapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentCapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentCapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentCapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentCapabilityGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentCapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    inventoryCategory?: boolean
    canUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentCapability"]>



  export type EquipmentCapabilitySelectScalar = {
    id?: boolean
    equipmentId?: boolean
    inventoryCategory?: boolean
    canUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentCapabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentId" | "inventoryCategory" | "canUse" | "createdAt" | "updatedAt", ExtArgs["result"]["equipmentCapability"]>
  export type EquipmentCapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $EquipmentCapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentCapability"
    objects: {
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      inventoryCategory: $Enums.InventoryCategory
      canUse: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentCapability"]>
    composites: {}
  }

  type EquipmentCapabilityGetPayload<S extends boolean | null | undefined | EquipmentCapabilityDefaultArgs> = $Result.GetResult<Prisma.$EquipmentCapabilityPayload, S>

  type EquipmentCapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentCapabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCapabilityCountAggregateInputType | true
    }

  export interface EquipmentCapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentCapability'], meta: { name: 'EquipmentCapability' } }
    /**
     * Find zero or one EquipmentCapability that matches the filter.
     * @param {EquipmentCapabilityFindUniqueArgs} args - Arguments to find a EquipmentCapability
     * @example
     * // Get one EquipmentCapability
     * const equipmentCapability = await prisma.equipmentCapability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentCapabilityFindUniqueArgs>(args: SelectSubset<T, EquipmentCapabilityFindUniqueArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentCapability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentCapabilityFindUniqueOrThrowArgs} args - Arguments to find a EquipmentCapability
     * @example
     * // Get one EquipmentCapability
     * const equipmentCapability = await prisma.equipmentCapability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentCapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentCapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentCapability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityFindFirstArgs} args - Arguments to find a EquipmentCapability
     * @example
     * // Get one EquipmentCapability
     * const equipmentCapability = await prisma.equipmentCapability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentCapabilityFindFirstArgs>(args?: SelectSubset<T, EquipmentCapabilityFindFirstArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentCapability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityFindFirstOrThrowArgs} args - Arguments to find a EquipmentCapability
     * @example
     * // Get one EquipmentCapability
     * const equipmentCapability = await prisma.equipmentCapability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentCapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentCapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentCapabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentCapabilities
     * const equipmentCapabilities = await prisma.equipmentCapability.findMany()
     * 
     * // Get first 10 EquipmentCapabilities
     * const equipmentCapabilities = await prisma.equipmentCapability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentCapabilityWithIdOnly = await prisma.equipmentCapability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentCapabilityFindManyArgs>(args?: SelectSubset<T, EquipmentCapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentCapability.
     * @param {EquipmentCapabilityCreateArgs} args - Arguments to create a EquipmentCapability.
     * @example
     * // Create one EquipmentCapability
     * const EquipmentCapability = await prisma.equipmentCapability.create({
     *   data: {
     *     // ... data to create a EquipmentCapability
     *   }
     * })
     * 
     */
    create<T extends EquipmentCapabilityCreateArgs>(args: SelectSubset<T, EquipmentCapabilityCreateArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentCapabilities.
     * @param {EquipmentCapabilityCreateManyArgs} args - Arguments to create many EquipmentCapabilities.
     * @example
     * // Create many EquipmentCapabilities
     * const equipmentCapability = await prisma.equipmentCapability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCapabilityCreateManyArgs>(args?: SelectSubset<T, EquipmentCapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentCapability.
     * @param {EquipmentCapabilityDeleteArgs} args - Arguments to delete one EquipmentCapability.
     * @example
     * // Delete one EquipmentCapability
     * const EquipmentCapability = await prisma.equipmentCapability.delete({
     *   where: {
     *     // ... filter to delete one EquipmentCapability
     *   }
     * })
     * 
     */
    delete<T extends EquipmentCapabilityDeleteArgs>(args: SelectSubset<T, EquipmentCapabilityDeleteArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentCapability.
     * @param {EquipmentCapabilityUpdateArgs} args - Arguments to update one EquipmentCapability.
     * @example
     * // Update one EquipmentCapability
     * const equipmentCapability = await prisma.equipmentCapability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentCapabilityUpdateArgs>(args: SelectSubset<T, EquipmentCapabilityUpdateArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentCapabilities.
     * @param {EquipmentCapabilityDeleteManyArgs} args - Arguments to filter EquipmentCapabilities to delete.
     * @example
     * // Delete a few EquipmentCapabilities
     * const { count } = await prisma.equipmentCapability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentCapabilityDeleteManyArgs>(args?: SelectSubset<T, EquipmentCapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentCapabilities
     * const equipmentCapability = await prisma.equipmentCapability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentCapabilityUpdateManyArgs>(args: SelectSubset<T, EquipmentCapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentCapability.
     * @param {EquipmentCapabilityUpsertArgs} args - Arguments to update or create a EquipmentCapability.
     * @example
     * // Update or create a EquipmentCapability
     * const equipmentCapability = await prisma.equipmentCapability.upsert({
     *   create: {
     *     // ... data to create a EquipmentCapability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentCapability we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentCapabilityUpsertArgs>(args: SelectSubset<T, EquipmentCapabilityUpsertArgs<ExtArgs>>): Prisma__EquipmentCapabilityClient<$Result.GetResult<Prisma.$EquipmentCapabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentCapabilities that matches the filter.
     * @param {EquipmentCapabilityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const equipmentCapability = await prisma.equipmentCapability.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EquipmentCapabilityFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EquipmentCapability.
     * @param {EquipmentCapabilityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const equipmentCapability = await prisma.equipmentCapability.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EquipmentCapabilityAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EquipmentCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityCountArgs} args - Arguments to filter EquipmentCapabilities to count.
     * @example
     * // Count the number of EquipmentCapabilities
     * const count = await prisma.equipmentCapability.count({
     *   where: {
     *     // ... the filter for the EquipmentCapabilities we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCapabilityCountArgs>(
      args?: Subset<T, EquipmentCapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentCapabilityAggregateArgs>(args: Subset<T, EquipmentCapabilityAggregateArgs>): Prisma.PrismaPromise<GetEquipmentCapabilityAggregateType<T>>

    /**
     * Group by EquipmentCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentCapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentCapabilityGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentCapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentCapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentCapability model
   */
  readonly fields: EquipmentCapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentCapability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentCapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentCapability model
   */
  interface EquipmentCapabilityFieldRefs {
    readonly id: FieldRef<"EquipmentCapability", 'String'>
    readonly equipmentId: FieldRef<"EquipmentCapability", 'String'>
    readonly inventoryCategory: FieldRef<"EquipmentCapability", 'InventoryCategory'>
    readonly canUse: FieldRef<"EquipmentCapability", 'Boolean'>
    readonly createdAt: FieldRef<"EquipmentCapability", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentCapability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentCapability findUnique
   */
  export type EquipmentCapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCapability to fetch.
     */
    where: EquipmentCapabilityWhereUniqueInput
  }

  /**
   * EquipmentCapability findUniqueOrThrow
   */
  export type EquipmentCapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCapability to fetch.
     */
    where: EquipmentCapabilityWhereUniqueInput
  }

  /**
   * EquipmentCapability findFirst
   */
  export type EquipmentCapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCapability to fetch.
     */
    where?: EquipmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentCapabilities to fetch.
     */
    orderBy?: EquipmentCapabilityOrderByWithRelationInput | EquipmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentCapabilities.
     */
    cursor?: EquipmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentCapabilities.
     */
    distinct?: EquipmentCapabilityScalarFieldEnum | EquipmentCapabilityScalarFieldEnum[]
  }

  /**
   * EquipmentCapability findFirstOrThrow
   */
  export type EquipmentCapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCapability to fetch.
     */
    where?: EquipmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentCapabilities to fetch.
     */
    orderBy?: EquipmentCapabilityOrderByWithRelationInput | EquipmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentCapabilities.
     */
    cursor?: EquipmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentCapabilities.
     */
    distinct?: EquipmentCapabilityScalarFieldEnum | EquipmentCapabilityScalarFieldEnum[]
  }

  /**
   * EquipmentCapability findMany
   */
  export type EquipmentCapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentCapabilities to fetch.
     */
    where?: EquipmentCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentCapabilities to fetch.
     */
    orderBy?: EquipmentCapabilityOrderByWithRelationInput | EquipmentCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentCapabilities.
     */
    cursor?: EquipmentCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentCapabilities.
     */
    skip?: number
    distinct?: EquipmentCapabilityScalarFieldEnum | EquipmentCapabilityScalarFieldEnum[]
  }

  /**
   * EquipmentCapability create
   */
  export type EquipmentCapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentCapability.
     */
    data: XOR<EquipmentCapabilityCreateInput, EquipmentCapabilityUncheckedCreateInput>
  }

  /**
   * EquipmentCapability createMany
   */
  export type EquipmentCapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentCapabilities.
     */
    data: EquipmentCapabilityCreateManyInput | EquipmentCapabilityCreateManyInput[]
  }

  /**
   * EquipmentCapability update
   */
  export type EquipmentCapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentCapability.
     */
    data: XOR<EquipmentCapabilityUpdateInput, EquipmentCapabilityUncheckedUpdateInput>
    /**
     * Choose, which EquipmentCapability to update.
     */
    where: EquipmentCapabilityWhereUniqueInput
  }

  /**
   * EquipmentCapability updateMany
   */
  export type EquipmentCapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentCapabilities.
     */
    data: XOR<EquipmentCapabilityUpdateManyMutationInput, EquipmentCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentCapabilities to update
     */
    where?: EquipmentCapabilityWhereInput
    /**
     * Limit how many EquipmentCapabilities to update.
     */
    limit?: number
  }

  /**
   * EquipmentCapability upsert
   */
  export type EquipmentCapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentCapability to update in case it exists.
     */
    where: EquipmentCapabilityWhereUniqueInput
    /**
     * In case the EquipmentCapability found by the `where` argument doesn't exist, create a new EquipmentCapability with this data.
     */
    create: XOR<EquipmentCapabilityCreateInput, EquipmentCapabilityUncheckedCreateInput>
    /**
     * In case the EquipmentCapability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentCapabilityUpdateInput, EquipmentCapabilityUncheckedUpdateInput>
  }

  /**
   * EquipmentCapability delete
   */
  export type EquipmentCapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
    /**
     * Filter which EquipmentCapability to delete.
     */
    where: EquipmentCapabilityWhereUniqueInput
  }

  /**
   * EquipmentCapability deleteMany
   */
  export type EquipmentCapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentCapabilities to delete
     */
    where?: EquipmentCapabilityWhereInput
    /**
     * Limit how many EquipmentCapabilities to delete.
     */
    limit?: number
  }

  /**
   * EquipmentCapability findRaw
   */
  export type EquipmentCapabilityFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EquipmentCapability aggregateRaw
   */
  export type EquipmentCapabilityAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EquipmentCapability without action
   */
  export type EquipmentCapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCapability
     */
    select?: EquipmentCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentCapability
     */
    omit?: EquipmentCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentCapabilityInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentUsage
   */

  export type AggregateEquipmentUsage = {
    _count: EquipmentUsageCountAggregateOutputType | null
    _avg: EquipmentUsageAvgAggregateOutputType | null
    _sum: EquipmentUsageSumAggregateOutputType | null
    _min: EquipmentUsageMinAggregateOutputType | null
    _max: EquipmentUsageMaxAggregateOutputType | null
  }

  export type EquipmentUsageAvgAggregateOutputType = {
    areaProcessed: number | null
    processedPercentage: number | null
    fuelConsumed: number | null
  }

  export type EquipmentUsageSumAggregateOutputType = {
    areaProcessed: number | null
    processedPercentage: number | null
    fuelConsumed: number | null
  }

  export type EquipmentUsageMinAggregateOutputType = {
    id: string | null
    processId: string | null
    equipmentId: string | null
    userId: string | null
    areaProcessed: number | null
    processedPercentage: number | null
    fuelConsumed: number | null
    unit: $Enums.Unit | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentUsageMaxAggregateOutputType = {
    id: string | null
    processId: string | null
    equipmentId: string | null
    userId: string | null
    areaProcessed: number | null
    processedPercentage: number | null
    fuelConsumed: number | null
    unit: $Enums.Unit | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentUsageCountAggregateOutputType = {
    id: number
    processId: number
    equipmentId: number
    userId: number
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentUsageAvgAggregateInputType = {
    areaProcessed?: true
    processedPercentage?: true
    fuelConsumed?: true
  }

  export type EquipmentUsageSumAggregateInputType = {
    areaProcessed?: true
    processedPercentage?: true
    fuelConsumed?: true
  }

  export type EquipmentUsageMinAggregateInputType = {
    id?: true
    processId?: true
    equipmentId?: true
    userId?: true
    areaProcessed?: true
    processedPercentage?: true
    fuelConsumed?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentUsageMaxAggregateInputType = {
    id?: true
    processId?: true
    equipmentId?: true
    userId?: true
    areaProcessed?: true
    processedPercentage?: true
    fuelConsumed?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentUsageCountAggregateInputType = {
    id?: true
    processId?: true
    equipmentId?: true
    userId?: true
    areaProcessed?: true
    processedPercentage?: true
    fuelConsumed?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentUsage to aggregate.
     */
    where?: EquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentUsages to fetch.
     */
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentUsages
    **/
    _count?: true | EquipmentUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentUsageMaxAggregateInputType
  }

  export type GetEquipmentUsageAggregateType<T extends EquipmentUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentUsage[P]>
      : GetScalarType<T[P], AggregateEquipmentUsage[P]>
  }




  export type EquipmentUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentUsageWhereInput
    orderBy?: EquipmentUsageOrderByWithAggregationInput | EquipmentUsageOrderByWithAggregationInput[]
    by: EquipmentUsageScalarFieldEnum[] | EquipmentUsageScalarFieldEnum
    having?: EquipmentUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentUsageCountAggregateInputType | true
    _avg?: EquipmentUsageAvgAggregateInputType
    _sum?: EquipmentUsageSumAggregateInputType
    _min?: EquipmentUsageMinAggregateInputType
    _max?: EquipmentUsageMaxAggregateInputType
  }

  export type EquipmentUsageGroupByOutputType = {
    id: string
    processId: string
    equipmentId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt: Date
    updatedAt: Date
    _count: EquipmentUsageCountAggregateOutputType | null
    _avg: EquipmentUsageAvgAggregateOutputType | null
    _sum: EquipmentUsageSumAggregateOutputType | null
    _min: EquipmentUsageMinAggregateOutputType | null
    _max: EquipmentUsageMaxAggregateOutputType | null
  }

  type GetEquipmentUsageGroupByPayload<T extends EquipmentUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentUsageGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentUsageGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    equipmentId?: boolean
    userId?: boolean
    areaProcessed?: boolean
    processedPercentage?: boolean
    fuelConsumed?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | EquipmentUsage$notificationsArgs<ExtArgs>
    _count?: boolean | EquipmentUsageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentUsage"]>



  export type EquipmentUsageSelectScalar = {
    id?: boolean
    processId?: boolean
    equipmentId?: boolean
    userId?: boolean
    areaProcessed?: boolean
    processedPercentage?: boolean
    fuelConsumed?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "equipmentId" | "userId" | "areaProcessed" | "processedPercentage" | "fuelConsumed" | "unit" | "createdAt" | "updatedAt", ExtArgs["result"]["equipmentUsage"]>
  export type EquipmentUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | EquipmentUsage$notificationsArgs<ExtArgs>
    _count?: boolean | EquipmentUsageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EquipmentUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentUsage"
    objects: {
      process: Prisma.$ProcessPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      processId: string
      equipmentId: string
      userId: string
      areaProcessed: number
      processedPercentage: number
      fuelConsumed: number
      unit: $Enums.Unit
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentUsage"]>
    composites: {}
  }

  type EquipmentUsageGetPayload<S extends boolean | null | undefined | EquipmentUsageDefaultArgs> = $Result.GetResult<Prisma.$EquipmentUsagePayload, S>

  type EquipmentUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentUsageCountAggregateInputType | true
    }

  export interface EquipmentUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentUsage'], meta: { name: 'EquipmentUsage' } }
    /**
     * Find zero or one EquipmentUsage that matches the filter.
     * @param {EquipmentUsageFindUniqueArgs} args - Arguments to find a EquipmentUsage
     * @example
     * // Get one EquipmentUsage
     * const equipmentUsage = await prisma.equipmentUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentUsageFindUniqueArgs>(args: SelectSubset<T, EquipmentUsageFindUniqueArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentUsageFindUniqueOrThrowArgs} args - Arguments to find a EquipmentUsage
     * @example
     * // Get one EquipmentUsage
     * const equipmentUsage = await prisma.equipmentUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageFindFirstArgs} args - Arguments to find a EquipmentUsage
     * @example
     * // Get one EquipmentUsage
     * const equipmentUsage = await prisma.equipmentUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentUsageFindFirstArgs>(args?: SelectSubset<T, EquipmentUsageFindFirstArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageFindFirstOrThrowArgs} args - Arguments to find a EquipmentUsage
     * @example
     * // Get one EquipmentUsage
     * const equipmentUsage = await prisma.equipmentUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentUsages
     * const equipmentUsages = await prisma.equipmentUsage.findMany()
     * 
     * // Get first 10 EquipmentUsages
     * const equipmentUsages = await prisma.equipmentUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentUsageWithIdOnly = await prisma.equipmentUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentUsageFindManyArgs>(args?: SelectSubset<T, EquipmentUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentUsage.
     * @param {EquipmentUsageCreateArgs} args - Arguments to create a EquipmentUsage.
     * @example
     * // Create one EquipmentUsage
     * const EquipmentUsage = await prisma.equipmentUsage.create({
     *   data: {
     *     // ... data to create a EquipmentUsage
     *   }
     * })
     * 
     */
    create<T extends EquipmentUsageCreateArgs>(args: SelectSubset<T, EquipmentUsageCreateArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentUsages.
     * @param {EquipmentUsageCreateManyArgs} args - Arguments to create many EquipmentUsages.
     * @example
     * // Create many EquipmentUsages
     * const equipmentUsage = await prisma.equipmentUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentUsageCreateManyArgs>(args?: SelectSubset<T, EquipmentUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentUsage.
     * @param {EquipmentUsageDeleteArgs} args - Arguments to delete one EquipmentUsage.
     * @example
     * // Delete one EquipmentUsage
     * const EquipmentUsage = await prisma.equipmentUsage.delete({
     *   where: {
     *     // ... filter to delete one EquipmentUsage
     *   }
     * })
     * 
     */
    delete<T extends EquipmentUsageDeleteArgs>(args: SelectSubset<T, EquipmentUsageDeleteArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentUsage.
     * @param {EquipmentUsageUpdateArgs} args - Arguments to update one EquipmentUsage.
     * @example
     * // Update one EquipmentUsage
     * const equipmentUsage = await prisma.equipmentUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUsageUpdateArgs>(args: SelectSubset<T, EquipmentUsageUpdateArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentUsages.
     * @param {EquipmentUsageDeleteManyArgs} args - Arguments to filter EquipmentUsages to delete.
     * @example
     * // Delete a few EquipmentUsages
     * const { count } = await prisma.equipmentUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentUsageDeleteManyArgs>(args?: SelectSubset<T, EquipmentUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentUsages
     * const equipmentUsage = await prisma.equipmentUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUsageUpdateManyArgs>(args: SelectSubset<T, EquipmentUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentUsage.
     * @param {EquipmentUsageUpsertArgs} args - Arguments to update or create a EquipmentUsage.
     * @example
     * // Update or create a EquipmentUsage
     * const equipmentUsage = await prisma.equipmentUsage.upsert({
     *   create: {
     *     // ... data to create a EquipmentUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentUsage we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUsageUpsertArgs>(args: SelectSubset<T, EquipmentUsageUpsertArgs<ExtArgs>>): Prisma__EquipmentUsageClient<$Result.GetResult<Prisma.$EquipmentUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentUsages that matches the filter.
     * @param {EquipmentUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const equipmentUsage = await prisma.equipmentUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EquipmentUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EquipmentUsage.
     * @param {EquipmentUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const equipmentUsage = await prisma.equipmentUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EquipmentUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EquipmentUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageCountArgs} args - Arguments to filter EquipmentUsages to count.
     * @example
     * // Count the number of EquipmentUsages
     * const count = await prisma.equipmentUsage.count({
     *   where: {
     *     // ... the filter for the EquipmentUsages we want to count
     *   }
     * })
    **/
    count<T extends EquipmentUsageCountArgs>(
      args?: Subset<T, EquipmentUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentUsageAggregateArgs>(args: Subset<T, EquipmentUsageAggregateArgs>): Prisma.PrismaPromise<GetEquipmentUsageAggregateType<T>>

    /**
     * Group by EquipmentUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentUsageGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentUsage model
   */
  readonly fields: EquipmentUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends EquipmentUsage$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentUsage$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentUsage model
   */
  interface EquipmentUsageFieldRefs {
    readonly id: FieldRef<"EquipmentUsage", 'String'>
    readonly processId: FieldRef<"EquipmentUsage", 'String'>
    readonly equipmentId: FieldRef<"EquipmentUsage", 'String'>
    readonly userId: FieldRef<"EquipmentUsage", 'String'>
    readonly areaProcessed: FieldRef<"EquipmentUsage", 'Float'>
    readonly processedPercentage: FieldRef<"EquipmentUsage", 'Float'>
    readonly fuelConsumed: FieldRef<"EquipmentUsage", 'Float'>
    readonly unit: FieldRef<"EquipmentUsage", 'Unit'>
    readonly createdAt: FieldRef<"EquipmentUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentUsage findUnique
   */
  export type EquipmentUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentUsage to fetch.
     */
    where: EquipmentUsageWhereUniqueInput
  }

  /**
   * EquipmentUsage findUniqueOrThrow
   */
  export type EquipmentUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentUsage to fetch.
     */
    where: EquipmentUsageWhereUniqueInput
  }

  /**
   * EquipmentUsage findFirst
   */
  export type EquipmentUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentUsage to fetch.
     */
    where?: EquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentUsages to fetch.
     */
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentUsages.
     */
    cursor?: EquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentUsages.
     */
    distinct?: EquipmentUsageScalarFieldEnum | EquipmentUsageScalarFieldEnum[]
  }

  /**
   * EquipmentUsage findFirstOrThrow
   */
  export type EquipmentUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentUsage to fetch.
     */
    where?: EquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentUsages to fetch.
     */
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentUsages.
     */
    cursor?: EquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentUsages.
     */
    distinct?: EquipmentUsageScalarFieldEnum | EquipmentUsageScalarFieldEnum[]
  }

  /**
   * EquipmentUsage findMany
   */
  export type EquipmentUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentUsages to fetch.
     */
    where?: EquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentUsages to fetch.
     */
    orderBy?: EquipmentUsageOrderByWithRelationInput | EquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentUsages.
     */
    cursor?: EquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentUsages.
     */
    skip?: number
    distinct?: EquipmentUsageScalarFieldEnum | EquipmentUsageScalarFieldEnum[]
  }

  /**
   * EquipmentUsage create
   */
  export type EquipmentUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentUsage.
     */
    data: XOR<EquipmentUsageCreateInput, EquipmentUsageUncheckedCreateInput>
  }

  /**
   * EquipmentUsage createMany
   */
  export type EquipmentUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentUsages.
     */
    data: EquipmentUsageCreateManyInput | EquipmentUsageCreateManyInput[]
  }

  /**
   * EquipmentUsage update
   */
  export type EquipmentUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentUsage.
     */
    data: XOR<EquipmentUsageUpdateInput, EquipmentUsageUncheckedUpdateInput>
    /**
     * Choose, which EquipmentUsage to update.
     */
    where: EquipmentUsageWhereUniqueInput
  }

  /**
   * EquipmentUsage updateMany
   */
  export type EquipmentUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentUsages.
     */
    data: XOR<EquipmentUsageUpdateManyMutationInput, EquipmentUsageUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentUsages to update
     */
    where?: EquipmentUsageWhereInput
    /**
     * Limit how many EquipmentUsages to update.
     */
    limit?: number
  }

  /**
   * EquipmentUsage upsert
   */
  export type EquipmentUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentUsage to update in case it exists.
     */
    where: EquipmentUsageWhereUniqueInput
    /**
     * In case the EquipmentUsage found by the `where` argument doesn't exist, create a new EquipmentUsage with this data.
     */
    create: XOR<EquipmentUsageCreateInput, EquipmentUsageUncheckedCreateInput>
    /**
     * In case the EquipmentUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUsageUpdateInput, EquipmentUsageUncheckedUpdateInput>
  }

  /**
   * EquipmentUsage delete
   */
  export type EquipmentUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter which EquipmentUsage to delete.
     */
    where: EquipmentUsageWhereUniqueInput
  }

  /**
   * EquipmentUsage deleteMany
   */
  export type EquipmentUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentUsages to delete
     */
    where?: EquipmentUsageWhereInput
    /**
     * Limit how many EquipmentUsages to delete.
     */
    limit?: number
  }

  /**
   * EquipmentUsage findRaw
   */
  export type EquipmentUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EquipmentUsage aggregateRaw
   */
  export type EquipmentUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EquipmentUsage.notifications
   */
  export type EquipmentUsage$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * EquipmentUsage without action
   */
  export type EquipmentUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentUsage
     */
    select?: EquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentUsage
     */
    omit?: EquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentUsageInclude<ExtArgs> | null
  }


  /**
   * Model ProcessCost
   */

  export type AggregateProcessCost = {
    _count: ProcessCostCountAggregateOutputType | null
    _avg: ProcessCostAvgAggregateOutputType | null
    _sum: ProcessCostSumAggregateOutputType | null
    _min: ProcessCostMinAggregateOutputType | null
    _max: ProcessCostMaxAggregateOutputType | null
  }

  export type ProcessCostAvgAggregateOutputType = {
    laborCost: number | null
    equipmentCost: number | null
    inventoryCost: number | null
    fuelCost: number | null
    totalCost: number | null
  }

  export type ProcessCostSumAggregateOutputType = {
    laborCost: number | null
    equipmentCost: number | null
    inventoryCost: number | null
    fuelCost: number | null
    totalCost: number | null
  }

  export type ProcessCostMinAggregateOutputType = {
    id: string | null
    processId: string | null
    laborCost: number | null
    equipmentCost: number | null
    inventoryCost: number | null
    fuelCost: number | null
    totalCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fieldId: string | null
  }

  export type ProcessCostMaxAggregateOutputType = {
    id: string | null
    processId: string | null
    laborCost: number | null
    equipmentCost: number | null
    inventoryCost: number | null
    fuelCost: number | null
    totalCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fieldId: string | null
  }

  export type ProcessCostCountAggregateOutputType = {
    id: number
    processId: number
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt: number
    updatedAt: number
    fieldId: number
    _all: number
  }


  export type ProcessCostAvgAggregateInputType = {
    laborCost?: true
    equipmentCost?: true
    inventoryCost?: true
    fuelCost?: true
    totalCost?: true
  }

  export type ProcessCostSumAggregateInputType = {
    laborCost?: true
    equipmentCost?: true
    inventoryCost?: true
    fuelCost?: true
    totalCost?: true
  }

  export type ProcessCostMinAggregateInputType = {
    id?: true
    processId?: true
    laborCost?: true
    equipmentCost?: true
    inventoryCost?: true
    fuelCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
  }

  export type ProcessCostMaxAggregateInputType = {
    id?: true
    processId?: true
    laborCost?: true
    equipmentCost?: true
    inventoryCost?: true
    fuelCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
  }

  export type ProcessCostCountAggregateInputType = {
    id?: true
    processId?: true
    laborCost?: true
    equipmentCost?: true
    inventoryCost?: true
    fuelCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    fieldId?: true
    _all?: true
  }

  export type ProcessCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessCost to aggregate.
     */
    where?: ProcessCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessCosts to fetch.
     */
    orderBy?: ProcessCostOrderByWithRelationInput | ProcessCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessCosts
    **/
    _count?: true | ProcessCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessCostMaxAggregateInputType
  }

  export type GetProcessCostAggregateType<T extends ProcessCostAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessCost[P]>
      : GetScalarType<T[P], AggregateProcessCost[P]>
  }




  export type ProcessCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessCostWhereInput
    orderBy?: ProcessCostOrderByWithAggregationInput | ProcessCostOrderByWithAggregationInput[]
    by: ProcessCostScalarFieldEnum[] | ProcessCostScalarFieldEnum
    having?: ProcessCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCostCountAggregateInputType | true
    _avg?: ProcessCostAvgAggregateInputType
    _sum?: ProcessCostSumAggregateInputType
    _min?: ProcessCostMinAggregateInputType
    _max?: ProcessCostMaxAggregateInputType
  }

  export type ProcessCostGroupByOutputType = {
    id: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt: Date
    updatedAt: Date
    fieldId: string
    _count: ProcessCostCountAggregateOutputType | null
    _avg: ProcessCostAvgAggregateOutputType | null
    _sum: ProcessCostSumAggregateOutputType | null
    _min: ProcessCostMinAggregateOutputType | null
    _max: ProcessCostMaxAggregateOutputType | null
  }

  type GetProcessCostGroupByPayload<T extends ProcessCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessCostGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessCostGroupByOutputType[P]>
        }
      >
    >


  export type ProcessCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    laborCost?: boolean
    equipmentCost?: boolean
    inventoryCost?: boolean
    fuelCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldId?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    ownerExpenses?: boolean | ProcessCost$ownerExpensesArgs<ExtArgs>
    notifications?: boolean | ProcessCost$notificationsArgs<ExtArgs>
    _count?: boolean | ProcessCostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processCost"]>



  export type ProcessCostSelectScalar = {
    id?: boolean
    processId?: boolean
    laborCost?: boolean
    equipmentCost?: boolean
    inventoryCost?: boolean
    fuelCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldId?: boolean
  }

  export type ProcessCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "laborCost" | "equipmentCost" | "inventoryCost" | "fuelCost" | "totalCost" | "createdAt" | "updatedAt" | "fieldId", ExtArgs["result"]["processCost"]>
  export type ProcessCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    ownerExpenses?: boolean | ProcessCost$ownerExpensesArgs<ExtArgs>
    notifications?: boolean | ProcessCost$notificationsArgs<ExtArgs>
    _count?: boolean | ProcessCostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcessCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessCost"
    objects: {
      process: Prisma.$ProcessPayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs>
      ownerExpenses: Prisma.$FieldOwnerExpensePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      processId: string
      laborCost: number
      equipmentCost: number
      inventoryCost: number
      fuelCost: number
      totalCost: number
      createdAt: Date
      updatedAt: Date
      fieldId: string
    }, ExtArgs["result"]["processCost"]>
    composites: {}
  }

  type ProcessCostGetPayload<S extends boolean | null | undefined | ProcessCostDefaultArgs> = $Result.GetResult<Prisma.$ProcessCostPayload, S>

  type ProcessCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcessCostCountAggregateInputType | true
    }

  export interface ProcessCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessCost'], meta: { name: 'ProcessCost' } }
    /**
     * Find zero or one ProcessCost that matches the filter.
     * @param {ProcessCostFindUniqueArgs} args - Arguments to find a ProcessCost
     * @example
     * // Get one ProcessCost
     * const processCost = await prisma.processCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessCostFindUniqueArgs>(args: SelectSubset<T, ProcessCostFindUniqueArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessCostFindUniqueOrThrowArgs} args - Arguments to find a ProcessCost
     * @example
     * // Get one ProcessCost
     * const processCost = await prisma.processCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessCostFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostFindFirstArgs} args - Arguments to find a ProcessCost
     * @example
     * // Get one ProcessCost
     * const processCost = await prisma.processCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessCostFindFirstArgs>(args?: SelectSubset<T, ProcessCostFindFirstArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostFindFirstOrThrowArgs} args - Arguments to find a ProcessCost
     * @example
     * // Get one ProcessCost
     * const processCost = await prisma.processCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessCostFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessCosts
     * const processCosts = await prisma.processCost.findMany()
     * 
     * // Get first 10 ProcessCosts
     * const processCosts = await prisma.processCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processCostWithIdOnly = await prisma.processCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessCostFindManyArgs>(args?: SelectSubset<T, ProcessCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessCost.
     * @param {ProcessCostCreateArgs} args - Arguments to create a ProcessCost.
     * @example
     * // Create one ProcessCost
     * const ProcessCost = await prisma.processCost.create({
     *   data: {
     *     // ... data to create a ProcessCost
     *   }
     * })
     * 
     */
    create<T extends ProcessCostCreateArgs>(args: SelectSubset<T, ProcessCostCreateArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessCosts.
     * @param {ProcessCostCreateManyArgs} args - Arguments to create many ProcessCosts.
     * @example
     * // Create many ProcessCosts
     * const processCost = await prisma.processCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCostCreateManyArgs>(args?: SelectSubset<T, ProcessCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessCost.
     * @param {ProcessCostDeleteArgs} args - Arguments to delete one ProcessCost.
     * @example
     * // Delete one ProcessCost
     * const ProcessCost = await prisma.processCost.delete({
     *   where: {
     *     // ... filter to delete one ProcessCost
     *   }
     * })
     * 
     */
    delete<T extends ProcessCostDeleteArgs>(args: SelectSubset<T, ProcessCostDeleteArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessCost.
     * @param {ProcessCostUpdateArgs} args - Arguments to update one ProcessCost.
     * @example
     * // Update one ProcessCost
     * const processCost = await prisma.processCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessCostUpdateArgs>(args: SelectSubset<T, ProcessCostUpdateArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessCosts.
     * @param {ProcessCostDeleteManyArgs} args - Arguments to filter ProcessCosts to delete.
     * @example
     * // Delete a few ProcessCosts
     * const { count } = await prisma.processCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessCostDeleteManyArgs>(args?: SelectSubset<T, ProcessCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessCosts
     * const processCost = await prisma.processCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessCostUpdateManyArgs>(args: SelectSubset<T, ProcessCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessCost.
     * @param {ProcessCostUpsertArgs} args - Arguments to update or create a ProcessCost.
     * @example
     * // Update or create a ProcessCost
     * const processCost = await prisma.processCost.upsert({
     *   create: {
     *     // ... data to create a ProcessCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessCost we want to update
     *   }
     * })
     */
    upsert<T extends ProcessCostUpsertArgs>(args: SelectSubset<T, ProcessCostUpsertArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessCosts that matches the filter.
     * @param {ProcessCostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const processCost = await prisma.processCost.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProcessCostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProcessCost.
     * @param {ProcessCostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const processCost = await prisma.processCost.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProcessCostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProcessCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostCountArgs} args - Arguments to filter ProcessCosts to count.
     * @example
     * // Count the number of ProcessCosts
     * const count = await prisma.processCost.count({
     *   where: {
     *     // ... the filter for the ProcessCosts we want to count
     *   }
     * })
    **/
    count<T extends ProcessCostCountArgs>(
      args?: Subset<T, ProcessCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessCostAggregateArgs>(args: Subset<T, ProcessCostAggregateArgs>): Prisma.PrismaPromise<GetProcessCostAggregateType<T>>

    /**
     * Group by ProcessCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessCostGroupByArgs['orderBy'] }
        : { orderBy?: ProcessCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessCost model
   */
  readonly fields: ProcessCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ownerExpenses<T extends ProcessCost$ownerExpensesArgs<ExtArgs> = {}>(args?: Subset<T, ProcessCost$ownerExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends ProcessCost$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, ProcessCost$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessCost model
   */
  interface ProcessCostFieldRefs {
    readonly id: FieldRef<"ProcessCost", 'String'>
    readonly processId: FieldRef<"ProcessCost", 'String'>
    readonly laborCost: FieldRef<"ProcessCost", 'Float'>
    readonly equipmentCost: FieldRef<"ProcessCost", 'Float'>
    readonly inventoryCost: FieldRef<"ProcessCost", 'Float'>
    readonly fuelCost: FieldRef<"ProcessCost", 'Float'>
    readonly totalCost: FieldRef<"ProcessCost", 'Float'>
    readonly createdAt: FieldRef<"ProcessCost", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessCost", 'DateTime'>
    readonly fieldId: FieldRef<"ProcessCost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProcessCost findUnique
   */
  export type ProcessCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * Filter, which ProcessCost to fetch.
     */
    where: ProcessCostWhereUniqueInput
  }

  /**
   * ProcessCost findUniqueOrThrow
   */
  export type ProcessCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * Filter, which ProcessCost to fetch.
     */
    where: ProcessCostWhereUniqueInput
  }

  /**
   * ProcessCost findFirst
   */
  export type ProcessCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * Filter, which ProcessCost to fetch.
     */
    where?: ProcessCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessCosts to fetch.
     */
    orderBy?: ProcessCostOrderByWithRelationInput | ProcessCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessCosts.
     */
    cursor?: ProcessCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessCosts.
     */
    distinct?: ProcessCostScalarFieldEnum | ProcessCostScalarFieldEnum[]
  }

  /**
   * ProcessCost findFirstOrThrow
   */
  export type ProcessCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * Filter, which ProcessCost to fetch.
     */
    where?: ProcessCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessCosts to fetch.
     */
    orderBy?: ProcessCostOrderByWithRelationInput | ProcessCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessCosts.
     */
    cursor?: ProcessCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessCosts.
     */
    distinct?: ProcessCostScalarFieldEnum | ProcessCostScalarFieldEnum[]
  }

  /**
   * ProcessCost findMany
   */
  export type ProcessCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * Filter, which ProcessCosts to fetch.
     */
    where?: ProcessCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessCosts to fetch.
     */
    orderBy?: ProcessCostOrderByWithRelationInput | ProcessCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessCosts.
     */
    cursor?: ProcessCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessCosts.
     */
    skip?: number
    distinct?: ProcessCostScalarFieldEnum | ProcessCostScalarFieldEnum[]
  }

  /**
   * ProcessCost create
   */
  export type ProcessCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessCost.
     */
    data: XOR<ProcessCostCreateInput, ProcessCostUncheckedCreateInput>
  }

  /**
   * ProcessCost createMany
   */
  export type ProcessCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessCosts.
     */
    data: ProcessCostCreateManyInput | ProcessCostCreateManyInput[]
  }

  /**
   * ProcessCost update
   */
  export type ProcessCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessCost.
     */
    data: XOR<ProcessCostUpdateInput, ProcessCostUncheckedUpdateInput>
    /**
     * Choose, which ProcessCost to update.
     */
    where: ProcessCostWhereUniqueInput
  }

  /**
   * ProcessCost updateMany
   */
  export type ProcessCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessCosts.
     */
    data: XOR<ProcessCostUpdateManyMutationInput, ProcessCostUncheckedUpdateManyInput>
    /**
     * Filter which ProcessCosts to update
     */
    where?: ProcessCostWhereInput
    /**
     * Limit how many ProcessCosts to update.
     */
    limit?: number
  }

  /**
   * ProcessCost upsert
   */
  export type ProcessCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessCost to update in case it exists.
     */
    where: ProcessCostWhereUniqueInput
    /**
     * In case the ProcessCost found by the `where` argument doesn't exist, create a new ProcessCost with this data.
     */
    create: XOR<ProcessCostCreateInput, ProcessCostUncheckedCreateInput>
    /**
     * In case the ProcessCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessCostUpdateInput, ProcessCostUncheckedUpdateInput>
  }

  /**
   * ProcessCost delete
   */
  export type ProcessCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
    /**
     * Filter which ProcessCost to delete.
     */
    where: ProcessCostWhereUniqueInput
  }

  /**
   * ProcessCost deleteMany
   */
  export type ProcessCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessCosts to delete
     */
    where?: ProcessCostWhereInput
    /**
     * Limit how many ProcessCosts to delete.
     */
    limit?: number
  }

  /**
   * ProcessCost findRaw
   */
  export type ProcessCostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProcessCost aggregateRaw
   */
  export type ProcessCostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProcessCost.ownerExpenses
   */
  export type ProcessCost$ownerExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    where?: FieldOwnerExpenseWhereInput
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    cursor?: FieldOwnerExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldOwnerExpenseScalarFieldEnum | FieldOwnerExpenseScalarFieldEnum[]
  }

  /**
   * ProcessCost.notifications
   */
  export type ProcessCost$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * ProcessCost without action
   */
  export type ProcessCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCost
     */
    select?: ProcessCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessCost
     */
    omit?: ProcessCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCostInclude<ExtArgs> | null
  }


  /**
   * Model FieldExpense
   */

  export type AggregateFieldExpense = {
    _count: FieldExpenseCountAggregateOutputType | null
    _avg: FieldExpenseAvgAggregateOutputType | null
    _sum: FieldExpenseSumAggregateOutputType | null
    _min: FieldExpenseMinAggregateOutputType | null
    _max: FieldExpenseMaxAggregateOutputType | null
  }

  export type FieldExpenseAvgAggregateOutputType = {
    totalCost: number | null
  }

  export type FieldExpenseSumAggregateOutputType = {
    totalCost: number | null
  }

  export type FieldExpenseMinAggregateOutputType = {
    id: string | null
    fieldId: string | null
    seasonId: string | null
    totalCost: number | null
    description: string | null
    expenseDate: Date | null
    sourceType: string | null
    sourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FieldExpenseMaxAggregateOutputType = {
    id: string | null
    fieldId: string | null
    seasonId: string | null
    totalCost: number | null
    description: string | null
    expenseDate: Date | null
    sourceType: string | null
    sourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FieldExpenseCountAggregateOutputType = {
    id: number
    fieldId: number
    seasonId: number
    totalCost: number
    description: number
    expenseDate: number
    sourceType: number
    sourceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FieldExpenseAvgAggregateInputType = {
    totalCost?: true
  }

  export type FieldExpenseSumAggregateInputType = {
    totalCost?: true
  }

  export type FieldExpenseMinAggregateInputType = {
    id?: true
    fieldId?: true
    seasonId?: true
    totalCost?: true
    description?: true
    expenseDate?: true
    sourceType?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FieldExpenseMaxAggregateInputType = {
    id?: true
    fieldId?: true
    seasonId?: true
    totalCost?: true
    description?: true
    expenseDate?: true
    sourceType?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FieldExpenseCountAggregateInputType = {
    id?: true
    fieldId?: true
    seasonId?: true
    totalCost?: true
    description?: true
    expenseDate?: true
    sourceType?: true
    sourceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FieldExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldExpense to aggregate.
     */
    where?: FieldExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExpenses to fetch.
     */
    orderBy?: FieldExpenseOrderByWithRelationInput | FieldExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldExpenses
    **/
    _count?: true | FieldExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldExpenseMaxAggregateInputType
  }

  export type GetFieldExpenseAggregateType<T extends FieldExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldExpense[P]>
      : GetScalarType<T[P], AggregateFieldExpense[P]>
  }




  export type FieldExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldExpenseWhereInput
    orderBy?: FieldExpenseOrderByWithAggregationInput | FieldExpenseOrderByWithAggregationInput[]
    by: FieldExpenseScalarFieldEnum[] | FieldExpenseScalarFieldEnum
    having?: FieldExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldExpenseCountAggregateInputType | true
    _avg?: FieldExpenseAvgAggregateInputType
    _sum?: FieldExpenseSumAggregateInputType
    _min?: FieldExpenseMinAggregateInputType
    _max?: FieldExpenseMaxAggregateInputType
  }

  export type FieldExpenseGroupByOutputType = {
    id: string
    fieldId: string
    seasonId: string
    totalCost: number
    description: string
    expenseDate: Date
    sourceType: string
    sourceId: string
    createdAt: Date
    updatedAt: Date
    _count: FieldExpenseCountAggregateOutputType | null
    _avg: FieldExpenseAvgAggregateOutputType | null
    _sum: FieldExpenseSumAggregateOutputType | null
    _min: FieldExpenseMinAggregateOutputType | null
    _max: FieldExpenseMaxAggregateOutputType | null
  }

  type GetFieldExpenseGroupByPayload<T extends FieldExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], FieldExpenseGroupByOutputType[P]>
        }
      >
    >


  export type FieldExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    seasonId?: boolean
    totalCost?: boolean
    description?: boolean
    expenseDate?: boolean
    sourceType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    field?: boolean | FieldDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    notifications?: boolean | FieldExpense$notificationsArgs<ExtArgs>
    _count?: boolean | FieldExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldExpense"]>



  export type FieldExpenseSelectScalar = {
    id?: boolean
    fieldId?: boolean
    seasonId?: boolean
    totalCost?: boolean
    description?: boolean
    expenseDate?: boolean
    sourceType?: boolean
    sourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FieldExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldId" | "seasonId" | "totalCost" | "description" | "expenseDate" | "sourceType" | "sourceId" | "createdAt" | "updatedAt", ExtArgs["result"]["fieldExpense"]>
  export type FieldExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | FieldDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    notifications?: boolean | FieldExpense$notificationsArgs<ExtArgs>
    _count?: boolean | FieldExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FieldExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldExpense"
    objects: {
      field: Prisma.$FieldPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldId: string
      seasonId: string
      totalCost: number
      description: string
      expenseDate: Date
      sourceType: string
      sourceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fieldExpense"]>
    composites: {}
  }

  type FieldExpenseGetPayload<S extends boolean | null | undefined | FieldExpenseDefaultArgs> = $Result.GetResult<Prisma.$FieldExpensePayload, S>

  type FieldExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldExpenseCountAggregateInputType | true
    }

  export interface FieldExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldExpense'], meta: { name: 'FieldExpense' } }
    /**
     * Find zero or one FieldExpense that matches the filter.
     * @param {FieldExpenseFindUniqueArgs} args - Arguments to find a FieldExpense
     * @example
     * // Get one FieldExpense
     * const fieldExpense = await prisma.fieldExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldExpenseFindUniqueArgs>(args: SelectSubset<T, FieldExpenseFindUniqueArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldExpenseFindUniqueOrThrowArgs} args - Arguments to find a FieldExpense
     * @example
     * // Get one FieldExpense
     * const fieldExpense = await prisma.fieldExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseFindFirstArgs} args - Arguments to find a FieldExpense
     * @example
     * // Get one FieldExpense
     * const fieldExpense = await prisma.fieldExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldExpenseFindFirstArgs>(args?: SelectSubset<T, FieldExpenseFindFirstArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseFindFirstOrThrowArgs} args - Arguments to find a FieldExpense
     * @example
     * // Get one FieldExpense
     * const fieldExpense = await prisma.fieldExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldExpenses
     * const fieldExpenses = await prisma.fieldExpense.findMany()
     * 
     * // Get first 10 FieldExpenses
     * const fieldExpenses = await prisma.fieldExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldExpenseWithIdOnly = await prisma.fieldExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldExpenseFindManyArgs>(args?: SelectSubset<T, FieldExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldExpense.
     * @param {FieldExpenseCreateArgs} args - Arguments to create a FieldExpense.
     * @example
     * // Create one FieldExpense
     * const FieldExpense = await prisma.fieldExpense.create({
     *   data: {
     *     // ... data to create a FieldExpense
     *   }
     * })
     * 
     */
    create<T extends FieldExpenseCreateArgs>(args: SelectSubset<T, FieldExpenseCreateArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldExpenses.
     * @param {FieldExpenseCreateManyArgs} args - Arguments to create many FieldExpenses.
     * @example
     * // Create many FieldExpenses
     * const fieldExpense = await prisma.fieldExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldExpenseCreateManyArgs>(args?: SelectSubset<T, FieldExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldExpense.
     * @param {FieldExpenseDeleteArgs} args - Arguments to delete one FieldExpense.
     * @example
     * // Delete one FieldExpense
     * const FieldExpense = await prisma.fieldExpense.delete({
     *   where: {
     *     // ... filter to delete one FieldExpense
     *   }
     * })
     * 
     */
    delete<T extends FieldExpenseDeleteArgs>(args: SelectSubset<T, FieldExpenseDeleteArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldExpense.
     * @param {FieldExpenseUpdateArgs} args - Arguments to update one FieldExpense.
     * @example
     * // Update one FieldExpense
     * const fieldExpense = await prisma.fieldExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldExpenseUpdateArgs>(args: SelectSubset<T, FieldExpenseUpdateArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldExpenses.
     * @param {FieldExpenseDeleteManyArgs} args - Arguments to filter FieldExpenses to delete.
     * @example
     * // Delete a few FieldExpenses
     * const { count } = await prisma.fieldExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldExpenseDeleteManyArgs>(args?: SelectSubset<T, FieldExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldExpenses
     * const fieldExpense = await prisma.fieldExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldExpenseUpdateManyArgs>(args: SelectSubset<T, FieldExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldExpense.
     * @param {FieldExpenseUpsertArgs} args - Arguments to update or create a FieldExpense.
     * @example
     * // Update or create a FieldExpense
     * const fieldExpense = await prisma.fieldExpense.upsert({
     *   create: {
     *     // ... data to create a FieldExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldExpense we want to update
     *   }
     * })
     */
    upsert<T extends FieldExpenseUpsertArgs>(args: SelectSubset<T, FieldExpenseUpsertArgs<ExtArgs>>): Prisma__FieldExpenseClient<$Result.GetResult<Prisma.$FieldExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldExpenses that matches the filter.
     * @param {FieldExpenseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fieldExpense = await prisma.fieldExpense.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldExpenseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FieldExpense.
     * @param {FieldExpenseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fieldExpense = await prisma.fieldExpense.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldExpenseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FieldExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseCountArgs} args - Arguments to filter FieldExpenses to count.
     * @example
     * // Count the number of FieldExpenses
     * const count = await prisma.fieldExpense.count({
     *   where: {
     *     // ... the filter for the FieldExpenses we want to count
     *   }
     * })
    **/
    count<T extends FieldExpenseCountArgs>(
      args?: Subset<T, FieldExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldExpenseAggregateArgs>(args: Subset<T, FieldExpenseAggregateArgs>): Prisma.PrismaPromise<GetFieldExpenseAggregateType<T>>

    /**
     * Group by FieldExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldExpenseGroupByArgs['orderBy'] }
        : { orderBy?: FieldExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldExpense model
   */
  readonly fields: FieldExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends FieldExpense$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, FieldExpense$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldExpense model
   */
  interface FieldExpenseFieldRefs {
    readonly id: FieldRef<"FieldExpense", 'String'>
    readonly fieldId: FieldRef<"FieldExpense", 'String'>
    readonly seasonId: FieldRef<"FieldExpense", 'String'>
    readonly totalCost: FieldRef<"FieldExpense", 'Float'>
    readonly description: FieldRef<"FieldExpense", 'String'>
    readonly expenseDate: FieldRef<"FieldExpense", 'DateTime'>
    readonly sourceType: FieldRef<"FieldExpense", 'String'>
    readonly sourceId: FieldRef<"FieldExpense", 'String'>
    readonly createdAt: FieldRef<"FieldExpense", 'DateTime'>
    readonly updatedAt: FieldRef<"FieldExpense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FieldExpense findUnique
   */
  export type FieldExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldExpense to fetch.
     */
    where: FieldExpenseWhereUniqueInput
  }

  /**
   * FieldExpense findUniqueOrThrow
   */
  export type FieldExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldExpense to fetch.
     */
    where: FieldExpenseWhereUniqueInput
  }

  /**
   * FieldExpense findFirst
   */
  export type FieldExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldExpense to fetch.
     */
    where?: FieldExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExpenses to fetch.
     */
    orderBy?: FieldExpenseOrderByWithRelationInput | FieldExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldExpenses.
     */
    cursor?: FieldExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldExpenses.
     */
    distinct?: FieldExpenseScalarFieldEnum | FieldExpenseScalarFieldEnum[]
  }

  /**
   * FieldExpense findFirstOrThrow
   */
  export type FieldExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldExpense to fetch.
     */
    where?: FieldExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExpenses to fetch.
     */
    orderBy?: FieldExpenseOrderByWithRelationInput | FieldExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldExpenses.
     */
    cursor?: FieldExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldExpenses.
     */
    distinct?: FieldExpenseScalarFieldEnum | FieldExpenseScalarFieldEnum[]
  }

  /**
   * FieldExpense findMany
   */
  export type FieldExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldExpenses to fetch.
     */
    where?: FieldExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldExpenses to fetch.
     */
    orderBy?: FieldExpenseOrderByWithRelationInput | FieldExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldExpenses.
     */
    cursor?: FieldExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldExpenses.
     */
    skip?: number
    distinct?: FieldExpenseScalarFieldEnum | FieldExpenseScalarFieldEnum[]
  }

  /**
   * FieldExpense create
   */
  export type FieldExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldExpense.
     */
    data: XOR<FieldExpenseCreateInput, FieldExpenseUncheckedCreateInput>
  }

  /**
   * FieldExpense createMany
   */
  export type FieldExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldExpenses.
     */
    data: FieldExpenseCreateManyInput | FieldExpenseCreateManyInput[]
  }

  /**
   * FieldExpense update
   */
  export type FieldExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldExpense.
     */
    data: XOR<FieldExpenseUpdateInput, FieldExpenseUncheckedUpdateInput>
    /**
     * Choose, which FieldExpense to update.
     */
    where: FieldExpenseWhereUniqueInput
  }

  /**
   * FieldExpense updateMany
   */
  export type FieldExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldExpenses.
     */
    data: XOR<FieldExpenseUpdateManyMutationInput, FieldExpenseUncheckedUpdateManyInput>
    /**
     * Filter which FieldExpenses to update
     */
    where?: FieldExpenseWhereInput
    /**
     * Limit how many FieldExpenses to update.
     */
    limit?: number
  }

  /**
   * FieldExpense upsert
   */
  export type FieldExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldExpense to update in case it exists.
     */
    where: FieldExpenseWhereUniqueInput
    /**
     * In case the FieldExpense found by the `where` argument doesn't exist, create a new FieldExpense with this data.
     */
    create: XOR<FieldExpenseCreateInput, FieldExpenseUncheckedCreateInput>
    /**
     * In case the FieldExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldExpenseUpdateInput, FieldExpenseUncheckedUpdateInput>
  }

  /**
   * FieldExpense delete
   */
  export type FieldExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
    /**
     * Filter which FieldExpense to delete.
     */
    where: FieldExpenseWhereUniqueInput
  }

  /**
   * FieldExpense deleteMany
   */
  export type FieldExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldExpenses to delete
     */
    where?: FieldExpenseWhereInput
    /**
     * Limit how many FieldExpenses to delete.
     */
    limit?: number
  }

  /**
   * FieldExpense findRaw
   */
  export type FieldExpenseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldExpense aggregateRaw
   */
  export type FieldExpenseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldExpense.notifications
   */
  export type FieldExpense$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * FieldExpense without action
   */
  export type FieldExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldExpense
     */
    select?: FieldExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldExpense
     */
    omit?: FieldExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldExpenseInclude<ExtArgs> | null
  }


  /**
   * Model FieldOwnerExpense
   */

  export type AggregateFieldOwnerExpense = {
    _count: FieldOwnerExpenseCountAggregateOutputType | null
    _avg: FieldOwnerExpenseAvgAggregateOutputType | null
    _sum: FieldOwnerExpenseSumAggregateOutputType | null
    _min: FieldOwnerExpenseMinAggregateOutputType | null
    _max: FieldOwnerExpenseMaxAggregateOutputType | null
  }

  export type FieldOwnerExpenseAvgAggregateOutputType = {
    amount: number | null
    percentage: number | null
  }

  export type FieldOwnerExpenseSumAggregateOutputType = {
    amount: number | null
    percentage: number | null
  }

  export type FieldOwnerExpenseMinAggregateOutputType = {
    id: string | null
    fieldOwnershipId: string | null
    processCostId: string | null
    userId: string | null
    amount: number | null
    percentage: number | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FieldOwnerExpenseMaxAggregateOutputType = {
    id: string | null
    fieldOwnershipId: string | null
    processCostId: string | null
    userId: string | null
    amount: number | null
    percentage: number | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FieldOwnerExpenseCountAggregateOutputType = {
    id: number
    fieldOwnershipId: number
    processCostId: number
    userId: number
    amount: number
    percentage: number
    periodStart: number
    periodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FieldOwnerExpenseAvgAggregateInputType = {
    amount?: true
    percentage?: true
  }

  export type FieldOwnerExpenseSumAggregateInputType = {
    amount?: true
    percentage?: true
  }

  export type FieldOwnerExpenseMinAggregateInputType = {
    id?: true
    fieldOwnershipId?: true
    processCostId?: true
    userId?: true
    amount?: true
    percentage?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FieldOwnerExpenseMaxAggregateInputType = {
    id?: true
    fieldOwnershipId?: true
    processCostId?: true
    userId?: true
    amount?: true
    percentage?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FieldOwnerExpenseCountAggregateInputType = {
    id?: true
    fieldOwnershipId?: true
    processCostId?: true
    userId?: true
    amount?: true
    percentage?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FieldOwnerExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOwnerExpense to aggregate.
     */
    where?: FieldOwnerExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerExpenses to fetch.
     */
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldOwnerExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldOwnerExpenses
    **/
    _count?: true | FieldOwnerExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldOwnerExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldOwnerExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldOwnerExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldOwnerExpenseMaxAggregateInputType
  }

  export type GetFieldOwnerExpenseAggregateType<T extends FieldOwnerExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldOwnerExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldOwnerExpense[P]>
      : GetScalarType<T[P], AggregateFieldOwnerExpense[P]>
  }




  export type FieldOwnerExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOwnerExpenseWhereInput
    orderBy?: FieldOwnerExpenseOrderByWithAggregationInput | FieldOwnerExpenseOrderByWithAggregationInput[]
    by: FieldOwnerExpenseScalarFieldEnum[] | FieldOwnerExpenseScalarFieldEnum
    having?: FieldOwnerExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldOwnerExpenseCountAggregateInputType | true
    _avg?: FieldOwnerExpenseAvgAggregateInputType
    _sum?: FieldOwnerExpenseSumAggregateInputType
    _min?: FieldOwnerExpenseMinAggregateInputType
    _max?: FieldOwnerExpenseMaxAggregateInputType
  }

  export type FieldOwnerExpenseGroupByOutputType = {
    id: string
    fieldOwnershipId: string
    processCostId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date
    periodEnd: Date
    createdAt: Date
    updatedAt: Date
    _count: FieldOwnerExpenseCountAggregateOutputType | null
    _avg: FieldOwnerExpenseAvgAggregateOutputType | null
    _sum: FieldOwnerExpenseSumAggregateOutputType | null
    _min: FieldOwnerExpenseMinAggregateOutputType | null
    _max: FieldOwnerExpenseMaxAggregateOutputType | null
  }

  type GetFieldOwnerExpenseGroupByPayload<T extends FieldOwnerExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldOwnerExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldOwnerExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldOwnerExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], FieldOwnerExpenseGroupByOutputType[P]>
        }
      >
    >


  export type FieldOwnerExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldOwnershipId?: boolean
    processCostId?: boolean
    userId?: boolean
    amount?: boolean
    percentage?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fieldOwnership?: boolean | FieldOwnershipDefaultArgs<ExtArgs>
    processCost?: boolean | ProcessCostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | FieldOwnerExpense$notificationsArgs<ExtArgs>
    _count?: boolean | FieldOwnerExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldOwnerExpense"]>



  export type FieldOwnerExpenseSelectScalar = {
    id?: boolean
    fieldOwnershipId?: boolean
    processCostId?: boolean
    userId?: boolean
    amount?: boolean
    percentage?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FieldOwnerExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldOwnershipId" | "processCostId" | "userId" | "amount" | "percentage" | "periodStart" | "periodEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["fieldOwnerExpense"]>
  export type FieldOwnerExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fieldOwnership?: boolean | FieldOwnershipDefaultArgs<ExtArgs>
    processCost?: boolean | ProcessCostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | FieldOwnerExpense$notificationsArgs<ExtArgs>
    _count?: boolean | FieldOwnerExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FieldOwnerExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldOwnerExpense"
    objects: {
      fieldOwnership: Prisma.$FieldOwnershipPayload<ExtArgs>
      processCost: Prisma.$ProcessCostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldOwnershipId: string
      processCostId: string
      userId: string
      amount: number
      percentage: number
      periodStart: Date
      periodEnd: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fieldOwnerExpense"]>
    composites: {}
  }

  type FieldOwnerExpenseGetPayload<S extends boolean | null | undefined | FieldOwnerExpenseDefaultArgs> = $Result.GetResult<Prisma.$FieldOwnerExpensePayload, S>

  type FieldOwnerExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldOwnerExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldOwnerExpenseCountAggregateInputType | true
    }

  export interface FieldOwnerExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldOwnerExpense'], meta: { name: 'FieldOwnerExpense' } }
    /**
     * Find zero or one FieldOwnerExpense that matches the filter.
     * @param {FieldOwnerExpenseFindUniqueArgs} args - Arguments to find a FieldOwnerExpense
     * @example
     * // Get one FieldOwnerExpense
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldOwnerExpenseFindUniqueArgs>(args: SelectSubset<T, FieldOwnerExpenseFindUniqueArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldOwnerExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldOwnerExpenseFindUniqueOrThrowArgs} args - Arguments to find a FieldOwnerExpense
     * @example
     * // Get one FieldOwnerExpense
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldOwnerExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldOwnerExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOwnerExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseFindFirstArgs} args - Arguments to find a FieldOwnerExpense
     * @example
     * // Get one FieldOwnerExpense
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldOwnerExpenseFindFirstArgs>(args?: SelectSubset<T, FieldOwnerExpenseFindFirstArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOwnerExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseFindFirstOrThrowArgs} args - Arguments to find a FieldOwnerExpense
     * @example
     * // Get one FieldOwnerExpense
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldOwnerExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldOwnerExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldOwnerExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldOwnerExpenses
     * const fieldOwnerExpenses = await prisma.fieldOwnerExpense.findMany()
     * 
     * // Get first 10 FieldOwnerExpenses
     * const fieldOwnerExpenses = await prisma.fieldOwnerExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldOwnerExpenseWithIdOnly = await prisma.fieldOwnerExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldOwnerExpenseFindManyArgs>(args?: SelectSubset<T, FieldOwnerExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldOwnerExpense.
     * @param {FieldOwnerExpenseCreateArgs} args - Arguments to create a FieldOwnerExpense.
     * @example
     * // Create one FieldOwnerExpense
     * const FieldOwnerExpense = await prisma.fieldOwnerExpense.create({
     *   data: {
     *     // ... data to create a FieldOwnerExpense
     *   }
     * })
     * 
     */
    create<T extends FieldOwnerExpenseCreateArgs>(args: SelectSubset<T, FieldOwnerExpenseCreateArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldOwnerExpenses.
     * @param {FieldOwnerExpenseCreateManyArgs} args - Arguments to create many FieldOwnerExpenses.
     * @example
     * // Create many FieldOwnerExpenses
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldOwnerExpenseCreateManyArgs>(args?: SelectSubset<T, FieldOwnerExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FieldOwnerExpense.
     * @param {FieldOwnerExpenseDeleteArgs} args - Arguments to delete one FieldOwnerExpense.
     * @example
     * // Delete one FieldOwnerExpense
     * const FieldOwnerExpense = await prisma.fieldOwnerExpense.delete({
     *   where: {
     *     // ... filter to delete one FieldOwnerExpense
     *   }
     * })
     * 
     */
    delete<T extends FieldOwnerExpenseDeleteArgs>(args: SelectSubset<T, FieldOwnerExpenseDeleteArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldOwnerExpense.
     * @param {FieldOwnerExpenseUpdateArgs} args - Arguments to update one FieldOwnerExpense.
     * @example
     * // Update one FieldOwnerExpense
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldOwnerExpenseUpdateArgs>(args: SelectSubset<T, FieldOwnerExpenseUpdateArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldOwnerExpenses.
     * @param {FieldOwnerExpenseDeleteManyArgs} args - Arguments to filter FieldOwnerExpenses to delete.
     * @example
     * // Delete a few FieldOwnerExpenses
     * const { count } = await prisma.fieldOwnerExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldOwnerExpenseDeleteManyArgs>(args?: SelectSubset<T, FieldOwnerExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOwnerExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldOwnerExpenses
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldOwnerExpenseUpdateManyArgs>(args: SelectSubset<T, FieldOwnerExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FieldOwnerExpense.
     * @param {FieldOwnerExpenseUpsertArgs} args - Arguments to update or create a FieldOwnerExpense.
     * @example
     * // Update or create a FieldOwnerExpense
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.upsert({
     *   create: {
     *     // ... data to create a FieldOwnerExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldOwnerExpense we want to update
     *   }
     * })
     */
    upsert<T extends FieldOwnerExpenseUpsertArgs>(args: SelectSubset<T, FieldOwnerExpenseUpsertArgs<ExtArgs>>): Prisma__FieldOwnerExpenseClient<$Result.GetResult<Prisma.$FieldOwnerExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldOwnerExpenses that matches the filter.
     * @param {FieldOwnerExpenseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FieldOwnerExpenseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FieldOwnerExpense.
     * @param {FieldOwnerExpenseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fieldOwnerExpense = await prisma.fieldOwnerExpense.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FieldOwnerExpenseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FieldOwnerExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseCountArgs} args - Arguments to filter FieldOwnerExpenses to count.
     * @example
     * // Count the number of FieldOwnerExpenses
     * const count = await prisma.fieldOwnerExpense.count({
     *   where: {
     *     // ... the filter for the FieldOwnerExpenses we want to count
     *   }
     * })
    **/
    count<T extends FieldOwnerExpenseCountArgs>(
      args?: Subset<T, FieldOwnerExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldOwnerExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldOwnerExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldOwnerExpenseAggregateArgs>(args: Subset<T, FieldOwnerExpenseAggregateArgs>): Prisma.PrismaPromise<GetFieldOwnerExpenseAggregateType<T>>

    /**
     * Group by FieldOwnerExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOwnerExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldOwnerExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldOwnerExpenseGroupByArgs['orderBy'] }
        : { orderBy?: FieldOwnerExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldOwnerExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldOwnerExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldOwnerExpense model
   */
  readonly fields: FieldOwnerExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldOwnerExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldOwnerExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fieldOwnership<T extends FieldOwnershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldOwnershipDefaultArgs<ExtArgs>>): Prisma__FieldOwnershipClient<$Result.GetResult<Prisma.$FieldOwnershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processCost<T extends ProcessCostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessCostDefaultArgs<ExtArgs>>): Prisma__ProcessCostClient<$Result.GetResult<Prisma.$ProcessCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends FieldOwnerExpense$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, FieldOwnerExpense$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldOwnerExpense model
   */
  interface FieldOwnerExpenseFieldRefs {
    readonly id: FieldRef<"FieldOwnerExpense", 'String'>
    readonly fieldOwnershipId: FieldRef<"FieldOwnerExpense", 'String'>
    readonly processCostId: FieldRef<"FieldOwnerExpense", 'String'>
    readonly userId: FieldRef<"FieldOwnerExpense", 'String'>
    readonly amount: FieldRef<"FieldOwnerExpense", 'Float'>
    readonly percentage: FieldRef<"FieldOwnerExpense", 'Float'>
    readonly periodStart: FieldRef<"FieldOwnerExpense", 'DateTime'>
    readonly periodEnd: FieldRef<"FieldOwnerExpense", 'DateTime'>
    readonly createdAt: FieldRef<"FieldOwnerExpense", 'DateTime'>
    readonly updatedAt: FieldRef<"FieldOwnerExpense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FieldOwnerExpense findUnique
   */
  export type FieldOwnerExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnerExpense to fetch.
     */
    where: FieldOwnerExpenseWhereUniqueInput
  }

  /**
   * FieldOwnerExpense findUniqueOrThrow
   */
  export type FieldOwnerExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnerExpense to fetch.
     */
    where: FieldOwnerExpenseWhereUniqueInput
  }

  /**
   * FieldOwnerExpense findFirst
   */
  export type FieldOwnerExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnerExpense to fetch.
     */
    where?: FieldOwnerExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerExpenses to fetch.
     */
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOwnerExpenses.
     */
    cursor?: FieldOwnerExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOwnerExpenses.
     */
    distinct?: FieldOwnerExpenseScalarFieldEnum | FieldOwnerExpenseScalarFieldEnum[]
  }

  /**
   * FieldOwnerExpense findFirstOrThrow
   */
  export type FieldOwnerExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnerExpense to fetch.
     */
    where?: FieldOwnerExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerExpenses to fetch.
     */
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOwnerExpenses.
     */
    cursor?: FieldOwnerExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOwnerExpenses.
     */
    distinct?: FieldOwnerExpenseScalarFieldEnum | FieldOwnerExpenseScalarFieldEnum[]
  }

  /**
   * FieldOwnerExpense findMany
   */
  export type FieldOwnerExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * Filter, which FieldOwnerExpenses to fetch.
     */
    where?: FieldOwnerExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOwnerExpenses to fetch.
     */
    orderBy?: FieldOwnerExpenseOrderByWithRelationInput | FieldOwnerExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldOwnerExpenses.
     */
    cursor?: FieldOwnerExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOwnerExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOwnerExpenses.
     */
    skip?: number
    distinct?: FieldOwnerExpenseScalarFieldEnum | FieldOwnerExpenseScalarFieldEnum[]
  }

  /**
   * FieldOwnerExpense create
   */
  export type FieldOwnerExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldOwnerExpense.
     */
    data: XOR<FieldOwnerExpenseCreateInput, FieldOwnerExpenseUncheckedCreateInput>
  }

  /**
   * FieldOwnerExpense createMany
   */
  export type FieldOwnerExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldOwnerExpenses.
     */
    data: FieldOwnerExpenseCreateManyInput | FieldOwnerExpenseCreateManyInput[]
  }

  /**
   * FieldOwnerExpense update
   */
  export type FieldOwnerExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldOwnerExpense.
     */
    data: XOR<FieldOwnerExpenseUpdateInput, FieldOwnerExpenseUncheckedUpdateInput>
    /**
     * Choose, which FieldOwnerExpense to update.
     */
    where: FieldOwnerExpenseWhereUniqueInput
  }

  /**
   * FieldOwnerExpense updateMany
   */
  export type FieldOwnerExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldOwnerExpenses.
     */
    data: XOR<FieldOwnerExpenseUpdateManyMutationInput, FieldOwnerExpenseUncheckedUpdateManyInput>
    /**
     * Filter which FieldOwnerExpenses to update
     */
    where?: FieldOwnerExpenseWhereInput
    /**
     * Limit how many FieldOwnerExpenses to update.
     */
    limit?: number
  }

  /**
   * FieldOwnerExpense upsert
   */
  export type FieldOwnerExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldOwnerExpense to update in case it exists.
     */
    where: FieldOwnerExpenseWhereUniqueInput
    /**
     * In case the FieldOwnerExpense found by the `where` argument doesn't exist, create a new FieldOwnerExpense with this data.
     */
    create: XOR<FieldOwnerExpenseCreateInput, FieldOwnerExpenseUncheckedCreateInput>
    /**
     * In case the FieldOwnerExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldOwnerExpenseUpdateInput, FieldOwnerExpenseUncheckedUpdateInput>
  }

  /**
   * FieldOwnerExpense delete
   */
  export type FieldOwnerExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
    /**
     * Filter which FieldOwnerExpense to delete.
     */
    where: FieldOwnerExpenseWhereUniqueInput
  }

  /**
   * FieldOwnerExpense deleteMany
   */
  export type FieldOwnerExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOwnerExpenses to delete
     */
    where?: FieldOwnerExpenseWhereInput
    /**
     * Limit how many FieldOwnerExpenses to delete.
     */
    limit?: number
  }

  /**
   * FieldOwnerExpense findRaw
   */
  export type FieldOwnerExpenseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldOwnerExpense aggregateRaw
   */
  export type FieldOwnerExpenseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FieldOwnerExpense.notifications
   */
  export type FieldOwnerExpense$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * FieldOwnerExpense without action
   */
  export type FieldOwnerExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOwnerExpense
     */
    select?: FieldOwnerExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOwnerExpense
     */
    omit?: FieldOwnerExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOwnerExpenseInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationLog
   */

  export type AggregateIrrigationLog = {
    _count: IrrigationLogCountAggregateOutputType | null
    _avg: IrrigationLogAvgAggregateOutputType | null
    _sum: IrrigationLogSumAggregateOutputType | null
    _min: IrrigationLogMinAggregateOutputType | null
    _max: IrrigationLogMaxAggregateOutputType | null
  }

  export type IrrigationLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type IrrigationLogSumAggregateOutputType = {
    duration: number | null
  }

  export type IrrigationLogMinAggregateOutputType = {
    id: string | null
    startDateTime: Date | null
    duration: number | null
    wellId: string | null
    notes: string | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
  }

  export type IrrigationLogMaxAggregateOutputType = {
    id: string | null
    startDateTime: Date | null
    duration: number | null
    wellId: string | null
    notes: string | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
  }

  export type IrrigationLogCountAggregateOutputType = {
    id: number
    startDateTime: number
    duration: number
    wellId: number
    notes: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    seasonId: number
    _all: number
  }


  export type IrrigationLogAvgAggregateInputType = {
    duration?: true
  }

  export type IrrigationLogSumAggregateInputType = {
    duration?: true
  }

  export type IrrigationLogMinAggregateInputType = {
    id?: true
    startDateTime?: true
    duration?: true
    wellId?: true
    notes?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
  }

  export type IrrigationLogMaxAggregateInputType = {
    id?: true
    startDateTime?: true
    duration?: true
    wellId?: true
    notes?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
  }

  export type IrrigationLogCountAggregateInputType = {
    id?: true
    startDateTime?: true
    duration?: true
    wellId?: true
    notes?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    _all?: true
  }

  export type IrrigationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationLog to aggregate.
     */
    where?: IrrigationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationLogs to fetch.
     */
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationLogs
    **/
    _count?: true | IrrigationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationLogMaxAggregateInputType
  }

  export type GetIrrigationLogAggregateType<T extends IrrigationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationLog[P]>
      : GetScalarType<T[P], AggregateIrrigationLog[P]>
  }




  export type IrrigationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationLogWhereInput
    orderBy?: IrrigationLogOrderByWithAggregationInput | IrrigationLogOrderByWithAggregationInput[]
    by: IrrigationLogScalarFieldEnum[] | IrrigationLogScalarFieldEnum
    having?: IrrigationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationLogCountAggregateInputType | true
    _avg?: IrrigationLogAvgAggregateInputType
    _sum?: IrrigationLogSumAggregateInputType
    _min?: IrrigationLogMinAggregateInputType
    _max?: IrrigationLogMaxAggregateInputType
  }

  export type IrrigationLogGroupByOutputType = {
    id: string
    startDateTime: Date
    duration: number
    wellId: string
    notes: string | null
    status: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    seasonId: string | null
    _count: IrrigationLogCountAggregateOutputType | null
    _avg: IrrigationLogAvgAggregateOutputType | null
    _sum: IrrigationLogSumAggregateOutputType | null
    _min: IrrigationLogMinAggregateOutputType | null
    _max: IrrigationLogMaxAggregateOutputType | null
  }

  type GetIrrigationLogGroupByPayload<T extends IrrigationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationLogGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationLogGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDateTime?: boolean
    duration?: boolean
    wellId?: boolean
    notes?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
    well?: boolean | WellDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | IrrigationLog$seasonArgs<ExtArgs>
    fieldUsages?: boolean | IrrigationLog$fieldUsagesArgs<ExtArgs>
    inventoryUsages?: boolean | IrrigationLog$inventoryUsagesArgs<ExtArgs>
    billingUsages?: boolean | IrrigationLog$billingUsagesArgs<ExtArgs>
    ownerSummaries?: boolean | IrrigationLog$ownerSummariesArgs<ExtArgs>
    notifications?: boolean | IrrigationLog$notificationsArgs<ExtArgs>
    _count?: boolean | IrrigationLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationLog"]>



  export type IrrigationLogSelectScalar = {
    id?: boolean
    startDateTime?: boolean
    duration?: boolean
    wellId?: boolean
    notes?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
  }

  export type IrrigationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDateTime" | "duration" | "wellId" | "notes" | "status" | "createdBy" | "createdAt" | "updatedAt" | "seasonId", ExtArgs["result"]["irrigationLog"]>
  export type IrrigationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    well?: boolean | WellDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | IrrigationLog$seasonArgs<ExtArgs>
    fieldUsages?: boolean | IrrigationLog$fieldUsagesArgs<ExtArgs>
    inventoryUsages?: boolean | IrrigationLog$inventoryUsagesArgs<ExtArgs>
    billingUsages?: boolean | IrrigationLog$billingUsagesArgs<ExtArgs>
    ownerSummaries?: boolean | IrrigationLog$ownerSummariesArgs<ExtArgs>
    notifications?: boolean | IrrigationLog$notificationsArgs<ExtArgs>
    _count?: boolean | IrrigationLogCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $IrrigationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationLog"
    objects: {
      well: Prisma.$WellPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs> | null
      fieldUsages: Prisma.$IrrigationFieldUsagePayload<ExtArgs>[]
      inventoryUsages: Prisma.$IrrigationInventoryUsagePayload<ExtArgs>[]
      billingUsages: Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>[]
      ownerSummaries: Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDateTime: Date
      duration: number
      wellId: string
      notes: string | null
      status: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
      seasonId: string | null
    }, ExtArgs["result"]["irrigationLog"]>
    composites: {}
  }

  type IrrigationLogGetPayload<S extends boolean | null | undefined | IrrigationLogDefaultArgs> = $Result.GetResult<Prisma.$IrrigationLogPayload, S>

  type IrrigationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationLogCountAggregateInputType | true
    }

  export interface IrrigationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationLog'], meta: { name: 'IrrigationLog' } }
    /**
     * Find zero or one IrrigationLog that matches the filter.
     * @param {IrrigationLogFindUniqueArgs} args - Arguments to find a IrrigationLog
     * @example
     * // Get one IrrigationLog
     * const irrigationLog = await prisma.irrigationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationLogFindUniqueArgs>(args: SelectSubset<T, IrrigationLogFindUniqueArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationLogFindUniqueOrThrowArgs} args - Arguments to find a IrrigationLog
     * @example
     * // Get one IrrigationLog
     * const irrigationLog = await prisma.irrigationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogFindFirstArgs} args - Arguments to find a IrrigationLog
     * @example
     * // Get one IrrigationLog
     * const irrigationLog = await prisma.irrigationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationLogFindFirstArgs>(args?: SelectSubset<T, IrrigationLogFindFirstArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogFindFirstOrThrowArgs} args - Arguments to find a IrrigationLog
     * @example
     * // Get one IrrigationLog
     * const irrigationLog = await prisma.irrigationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationLogs
     * const irrigationLogs = await prisma.irrigationLog.findMany()
     * 
     * // Get first 10 IrrigationLogs
     * const irrigationLogs = await prisma.irrigationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationLogWithIdOnly = await prisma.irrigationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationLogFindManyArgs>(args?: SelectSubset<T, IrrigationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationLog.
     * @param {IrrigationLogCreateArgs} args - Arguments to create a IrrigationLog.
     * @example
     * // Create one IrrigationLog
     * const IrrigationLog = await prisma.irrigationLog.create({
     *   data: {
     *     // ... data to create a IrrigationLog
     *   }
     * })
     * 
     */
    create<T extends IrrigationLogCreateArgs>(args: SelectSubset<T, IrrigationLogCreateArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationLogs.
     * @param {IrrigationLogCreateManyArgs} args - Arguments to create many IrrigationLogs.
     * @example
     * // Create many IrrigationLogs
     * const irrigationLog = await prisma.irrigationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationLogCreateManyArgs>(args?: SelectSubset<T, IrrigationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IrrigationLog.
     * @param {IrrigationLogDeleteArgs} args - Arguments to delete one IrrigationLog.
     * @example
     * // Delete one IrrigationLog
     * const IrrigationLog = await prisma.irrigationLog.delete({
     *   where: {
     *     // ... filter to delete one IrrigationLog
     *   }
     * })
     * 
     */
    delete<T extends IrrigationLogDeleteArgs>(args: SelectSubset<T, IrrigationLogDeleteArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationLog.
     * @param {IrrigationLogUpdateArgs} args - Arguments to update one IrrigationLog.
     * @example
     * // Update one IrrigationLog
     * const irrigationLog = await prisma.irrigationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationLogUpdateArgs>(args: SelectSubset<T, IrrigationLogUpdateArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationLogs.
     * @param {IrrigationLogDeleteManyArgs} args - Arguments to filter IrrigationLogs to delete.
     * @example
     * // Delete a few IrrigationLogs
     * const { count } = await prisma.irrigationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationLogDeleteManyArgs>(args?: SelectSubset<T, IrrigationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationLogs
     * const irrigationLog = await prisma.irrigationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationLogUpdateManyArgs>(args: SelectSubset<T, IrrigationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IrrigationLog.
     * @param {IrrigationLogUpsertArgs} args - Arguments to update or create a IrrigationLog.
     * @example
     * // Update or create a IrrigationLog
     * const irrigationLog = await prisma.irrigationLog.upsert({
     *   create: {
     *     // ... data to create a IrrigationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationLog we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationLogUpsertArgs>(args: SelectSubset<T, IrrigationLogUpsertArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationLogs that matches the filter.
     * @param {IrrigationLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const irrigationLog = await prisma.irrigationLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IrrigationLogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IrrigationLog.
     * @param {IrrigationLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const irrigationLog = await prisma.irrigationLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IrrigationLogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IrrigationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogCountArgs} args - Arguments to filter IrrigationLogs to count.
     * @example
     * // Count the number of IrrigationLogs
     * const count = await prisma.irrigationLog.count({
     *   where: {
     *     // ... the filter for the IrrigationLogs we want to count
     *   }
     * })
    **/
    count<T extends IrrigationLogCountArgs>(
      args?: Subset<T, IrrigationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationLogAggregateArgs>(args: Subset<T, IrrigationLogAggregateArgs>): Prisma.PrismaPromise<GetIrrigationLogAggregateType<T>>

    /**
     * Group by IrrigationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationLogGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationLog model
   */
  readonly fields: IrrigationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    well<T extends WellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellDefaultArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends IrrigationLog$seasonArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLog$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fieldUsages<T extends IrrigationLog$fieldUsagesArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLog$fieldUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryUsages<T extends IrrigationLog$inventoryUsagesArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLog$inventoryUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    billingUsages<T extends IrrigationLog$billingUsagesArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLog$billingUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownerSummaries<T extends IrrigationLog$ownerSummariesArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLog$ownerSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends IrrigationLog$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLog$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationLog model
   */
  interface IrrigationLogFieldRefs {
    readonly id: FieldRef<"IrrigationLog", 'String'>
    readonly startDateTime: FieldRef<"IrrigationLog", 'DateTime'>
    readonly duration: FieldRef<"IrrigationLog", 'Float'>
    readonly wellId: FieldRef<"IrrigationLog", 'String'>
    readonly notes: FieldRef<"IrrigationLog", 'String'>
    readonly status: FieldRef<"IrrigationLog", 'String'>
    readonly createdBy: FieldRef<"IrrigationLog", 'String'>
    readonly createdAt: FieldRef<"IrrigationLog", 'DateTime'>
    readonly updatedAt: FieldRef<"IrrigationLog", 'DateTime'>
    readonly seasonId: FieldRef<"IrrigationLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationLog findUnique
   */
  export type IrrigationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationLog to fetch.
     */
    where: IrrigationLogWhereUniqueInput
  }

  /**
   * IrrigationLog findUniqueOrThrow
   */
  export type IrrigationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationLog to fetch.
     */
    where: IrrigationLogWhereUniqueInput
  }

  /**
   * IrrigationLog findFirst
   */
  export type IrrigationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationLog to fetch.
     */
    where?: IrrigationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationLogs to fetch.
     */
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationLogs.
     */
    cursor?: IrrigationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationLogs.
     */
    distinct?: IrrigationLogScalarFieldEnum | IrrigationLogScalarFieldEnum[]
  }

  /**
   * IrrigationLog findFirstOrThrow
   */
  export type IrrigationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationLog to fetch.
     */
    where?: IrrigationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationLogs to fetch.
     */
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationLogs.
     */
    cursor?: IrrigationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationLogs.
     */
    distinct?: IrrigationLogScalarFieldEnum | IrrigationLogScalarFieldEnum[]
  }

  /**
   * IrrigationLog findMany
   */
  export type IrrigationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationLogs to fetch.
     */
    where?: IrrigationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationLogs to fetch.
     */
    orderBy?: IrrigationLogOrderByWithRelationInput | IrrigationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationLogs.
     */
    cursor?: IrrigationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationLogs.
     */
    skip?: number
    distinct?: IrrigationLogScalarFieldEnum | IrrigationLogScalarFieldEnum[]
  }

  /**
   * IrrigationLog create
   */
  export type IrrigationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationLog.
     */
    data: XOR<IrrigationLogCreateInput, IrrigationLogUncheckedCreateInput>
  }

  /**
   * IrrigationLog createMany
   */
  export type IrrigationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationLogs.
     */
    data: IrrigationLogCreateManyInput | IrrigationLogCreateManyInput[]
  }

  /**
   * IrrigationLog update
   */
  export type IrrigationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationLog.
     */
    data: XOR<IrrigationLogUpdateInput, IrrigationLogUncheckedUpdateInput>
    /**
     * Choose, which IrrigationLog to update.
     */
    where: IrrigationLogWhereUniqueInput
  }

  /**
   * IrrigationLog updateMany
   */
  export type IrrigationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationLogs.
     */
    data: XOR<IrrigationLogUpdateManyMutationInput, IrrigationLogUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationLogs to update
     */
    where?: IrrigationLogWhereInput
    /**
     * Limit how many IrrigationLogs to update.
     */
    limit?: number
  }

  /**
   * IrrigationLog upsert
   */
  export type IrrigationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationLog to update in case it exists.
     */
    where: IrrigationLogWhereUniqueInput
    /**
     * In case the IrrigationLog found by the `where` argument doesn't exist, create a new IrrigationLog with this data.
     */
    create: XOR<IrrigationLogCreateInput, IrrigationLogUncheckedCreateInput>
    /**
     * In case the IrrigationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationLogUpdateInput, IrrigationLogUncheckedUpdateInput>
  }

  /**
   * IrrigationLog delete
   */
  export type IrrigationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
    /**
     * Filter which IrrigationLog to delete.
     */
    where: IrrigationLogWhereUniqueInput
  }

  /**
   * IrrigationLog deleteMany
   */
  export type IrrigationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationLogs to delete
     */
    where?: IrrigationLogWhereInput
    /**
     * Limit how many IrrigationLogs to delete.
     */
    limit?: number
  }

  /**
   * IrrigationLog findRaw
   */
  export type IrrigationLogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationLog aggregateRaw
   */
  export type IrrigationLogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationLog.season
   */
  export type IrrigationLog$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * IrrigationLog.fieldUsages
   */
  export type IrrigationLog$fieldUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    where?: IrrigationFieldUsageWhereInput
    orderBy?: IrrigationFieldUsageOrderByWithRelationInput | IrrigationFieldUsageOrderByWithRelationInput[]
    cursor?: IrrigationFieldUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationFieldUsageScalarFieldEnum | IrrigationFieldUsageScalarFieldEnum[]
  }

  /**
   * IrrigationLog.inventoryUsages
   */
  export type IrrigationLog$inventoryUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    where?: IrrigationInventoryUsageWhereInput
    orderBy?: IrrigationInventoryUsageOrderByWithRelationInput | IrrigationInventoryUsageOrderByWithRelationInput[]
    cursor?: IrrigationInventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationInventoryUsageScalarFieldEnum | IrrigationInventoryUsageScalarFieldEnum[]
  }

  /**
   * IrrigationLog.billingUsages
   */
  export type IrrigationLog$billingUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    where?: WellBillingIrrigationUsageWhereInput
    orderBy?: WellBillingIrrigationUsageOrderByWithRelationInput | WellBillingIrrigationUsageOrderByWithRelationInput[]
    cursor?: WellBillingIrrigationUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillingIrrigationUsageScalarFieldEnum | WellBillingIrrigationUsageScalarFieldEnum[]
  }

  /**
   * IrrigationLog.ownerSummaries
   */
  export type IrrigationLog$ownerSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    where?: IrrigationOwnerSummaryWhereInput
    orderBy?: IrrigationOwnerSummaryOrderByWithRelationInput | IrrigationOwnerSummaryOrderByWithRelationInput[]
    cursor?: IrrigationOwnerSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationOwnerSummaryScalarFieldEnum | IrrigationOwnerSummaryScalarFieldEnum[]
  }

  /**
   * IrrigationLog.notifications
   */
  export type IrrigationLog$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * IrrigationLog without action
   */
  export type IrrigationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationLog
     */
    select?: IrrigationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationLog
     */
    omit?: IrrigationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationLogInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationFieldUsage
   */

  export type AggregateIrrigationFieldUsage = {
    _count: IrrigationFieldUsageCountAggregateOutputType | null
    _avg: IrrigationFieldUsageAvgAggregateOutputType | null
    _sum: IrrigationFieldUsageSumAggregateOutputType | null
    _min: IrrigationFieldUsageMinAggregateOutputType | null
    _max: IrrigationFieldUsageMaxAggregateOutputType | null
  }

  export type IrrigationFieldUsageAvgAggregateOutputType = {
    percentage: number | null
    actualIrrigatedArea: number | null
  }

  export type IrrigationFieldUsageSumAggregateOutputType = {
    percentage: number | null
    actualIrrigatedArea: number | null
  }

  export type IrrigationFieldUsageMinAggregateOutputType = {
    id: string | null
    irrigationLogId: string | null
    fieldId: string | null
    percentage: number | null
    actualIrrigatedArea: number | null
    createdAt: Date | null
  }

  export type IrrigationFieldUsageMaxAggregateOutputType = {
    id: string | null
    irrigationLogId: string | null
    fieldId: string | null
    percentage: number | null
    actualIrrigatedArea: number | null
    createdAt: Date | null
  }

  export type IrrigationFieldUsageCountAggregateOutputType = {
    id: number
    irrigationLogId: number
    fieldId: number
    percentage: number
    actualIrrigatedArea: number
    createdAt: number
    _all: number
  }


  export type IrrigationFieldUsageAvgAggregateInputType = {
    percentage?: true
    actualIrrigatedArea?: true
  }

  export type IrrigationFieldUsageSumAggregateInputType = {
    percentage?: true
    actualIrrigatedArea?: true
  }

  export type IrrigationFieldUsageMinAggregateInputType = {
    id?: true
    irrigationLogId?: true
    fieldId?: true
    percentage?: true
    actualIrrigatedArea?: true
    createdAt?: true
  }

  export type IrrigationFieldUsageMaxAggregateInputType = {
    id?: true
    irrigationLogId?: true
    fieldId?: true
    percentage?: true
    actualIrrigatedArea?: true
    createdAt?: true
  }

  export type IrrigationFieldUsageCountAggregateInputType = {
    id?: true
    irrigationLogId?: true
    fieldId?: true
    percentage?: true
    actualIrrigatedArea?: true
    createdAt?: true
    _all?: true
  }

  export type IrrigationFieldUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationFieldUsage to aggregate.
     */
    where?: IrrigationFieldUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationFieldUsages to fetch.
     */
    orderBy?: IrrigationFieldUsageOrderByWithRelationInput | IrrigationFieldUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationFieldUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationFieldUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationFieldUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationFieldUsages
    **/
    _count?: true | IrrigationFieldUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationFieldUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationFieldUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationFieldUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationFieldUsageMaxAggregateInputType
  }

  export type GetIrrigationFieldUsageAggregateType<T extends IrrigationFieldUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationFieldUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationFieldUsage[P]>
      : GetScalarType<T[P], AggregateIrrigationFieldUsage[P]>
  }




  export type IrrigationFieldUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationFieldUsageWhereInput
    orderBy?: IrrigationFieldUsageOrderByWithAggregationInput | IrrigationFieldUsageOrderByWithAggregationInput[]
    by: IrrigationFieldUsageScalarFieldEnum[] | IrrigationFieldUsageScalarFieldEnum
    having?: IrrigationFieldUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationFieldUsageCountAggregateInputType | true
    _avg?: IrrigationFieldUsageAvgAggregateInputType
    _sum?: IrrigationFieldUsageSumAggregateInputType
    _min?: IrrigationFieldUsageMinAggregateInputType
    _max?: IrrigationFieldUsageMaxAggregateInputType
  }

  export type IrrigationFieldUsageGroupByOutputType = {
    id: string
    irrigationLogId: string
    fieldId: string
    percentage: number
    actualIrrigatedArea: number | null
    createdAt: Date
    _count: IrrigationFieldUsageCountAggregateOutputType | null
    _avg: IrrigationFieldUsageAvgAggregateOutputType | null
    _sum: IrrigationFieldUsageSumAggregateOutputType | null
    _min: IrrigationFieldUsageMinAggregateOutputType | null
    _max: IrrigationFieldUsageMaxAggregateOutputType | null
  }

  type GetIrrigationFieldUsageGroupByPayload<T extends IrrigationFieldUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationFieldUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationFieldUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationFieldUsageGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationFieldUsageGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationFieldUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    irrigationLogId?: boolean
    fieldId?: boolean
    percentage?: boolean
    actualIrrigatedArea?: boolean
    createdAt?: boolean
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    ownerUsages?: boolean | IrrigationFieldUsage$ownerUsagesArgs<ExtArgs>
    _count?: boolean | IrrigationFieldUsageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationFieldUsage"]>



  export type IrrigationFieldUsageSelectScalar = {
    id?: boolean
    irrigationLogId?: boolean
    fieldId?: boolean
    percentage?: boolean
    actualIrrigatedArea?: boolean
    createdAt?: boolean
  }

  export type IrrigationFieldUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "irrigationLogId" | "fieldId" | "percentage" | "actualIrrigatedArea" | "createdAt", ExtArgs["result"]["irrigationFieldUsage"]>
  export type IrrigationFieldUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    ownerUsages?: boolean | IrrigationFieldUsage$ownerUsagesArgs<ExtArgs>
    _count?: boolean | IrrigationFieldUsageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $IrrigationFieldUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationFieldUsage"
    objects: {
      irrigationLog: Prisma.$IrrigationLogPayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs>
      ownerUsages: Prisma.$IrrigationOwnerUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      irrigationLogId: string
      fieldId: string
      percentage: number
      actualIrrigatedArea: number | null
      createdAt: Date
    }, ExtArgs["result"]["irrigationFieldUsage"]>
    composites: {}
  }

  type IrrigationFieldUsageGetPayload<S extends boolean | null | undefined | IrrigationFieldUsageDefaultArgs> = $Result.GetResult<Prisma.$IrrigationFieldUsagePayload, S>

  type IrrigationFieldUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationFieldUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationFieldUsageCountAggregateInputType | true
    }

  export interface IrrigationFieldUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationFieldUsage'], meta: { name: 'IrrigationFieldUsage' } }
    /**
     * Find zero or one IrrigationFieldUsage that matches the filter.
     * @param {IrrigationFieldUsageFindUniqueArgs} args - Arguments to find a IrrigationFieldUsage
     * @example
     * // Get one IrrigationFieldUsage
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationFieldUsageFindUniqueArgs>(args: SelectSubset<T, IrrigationFieldUsageFindUniqueArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationFieldUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationFieldUsageFindUniqueOrThrowArgs} args - Arguments to find a IrrigationFieldUsage
     * @example
     * // Get one IrrigationFieldUsage
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationFieldUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationFieldUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationFieldUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageFindFirstArgs} args - Arguments to find a IrrigationFieldUsage
     * @example
     * // Get one IrrigationFieldUsage
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationFieldUsageFindFirstArgs>(args?: SelectSubset<T, IrrigationFieldUsageFindFirstArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationFieldUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageFindFirstOrThrowArgs} args - Arguments to find a IrrigationFieldUsage
     * @example
     * // Get one IrrigationFieldUsage
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationFieldUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationFieldUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationFieldUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationFieldUsages
     * const irrigationFieldUsages = await prisma.irrigationFieldUsage.findMany()
     * 
     * // Get first 10 IrrigationFieldUsages
     * const irrigationFieldUsages = await prisma.irrigationFieldUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationFieldUsageWithIdOnly = await prisma.irrigationFieldUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationFieldUsageFindManyArgs>(args?: SelectSubset<T, IrrigationFieldUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationFieldUsage.
     * @param {IrrigationFieldUsageCreateArgs} args - Arguments to create a IrrigationFieldUsage.
     * @example
     * // Create one IrrigationFieldUsage
     * const IrrigationFieldUsage = await prisma.irrigationFieldUsage.create({
     *   data: {
     *     // ... data to create a IrrigationFieldUsage
     *   }
     * })
     * 
     */
    create<T extends IrrigationFieldUsageCreateArgs>(args: SelectSubset<T, IrrigationFieldUsageCreateArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationFieldUsages.
     * @param {IrrigationFieldUsageCreateManyArgs} args - Arguments to create many IrrigationFieldUsages.
     * @example
     * // Create many IrrigationFieldUsages
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationFieldUsageCreateManyArgs>(args?: SelectSubset<T, IrrigationFieldUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IrrigationFieldUsage.
     * @param {IrrigationFieldUsageDeleteArgs} args - Arguments to delete one IrrigationFieldUsage.
     * @example
     * // Delete one IrrigationFieldUsage
     * const IrrigationFieldUsage = await prisma.irrigationFieldUsage.delete({
     *   where: {
     *     // ... filter to delete one IrrigationFieldUsage
     *   }
     * })
     * 
     */
    delete<T extends IrrigationFieldUsageDeleteArgs>(args: SelectSubset<T, IrrigationFieldUsageDeleteArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationFieldUsage.
     * @param {IrrigationFieldUsageUpdateArgs} args - Arguments to update one IrrigationFieldUsage.
     * @example
     * // Update one IrrigationFieldUsage
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationFieldUsageUpdateArgs>(args: SelectSubset<T, IrrigationFieldUsageUpdateArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationFieldUsages.
     * @param {IrrigationFieldUsageDeleteManyArgs} args - Arguments to filter IrrigationFieldUsages to delete.
     * @example
     * // Delete a few IrrigationFieldUsages
     * const { count } = await prisma.irrigationFieldUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationFieldUsageDeleteManyArgs>(args?: SelectSubset<T, IrrigationFieldUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationFieldUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationFieldUsages
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationFieldUsageUpdateManyArgs>(args: SelectSubset<T, IrrigationFieldUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IrrigationFieldUsage.
     * @param {IrrigationFieldUsageUpsertArgs} args - Arguments to update or create a IrrigationFieldUsage.
     * @example
     * // Update or create a IrrigationFieldUsage
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.upsert({
     *   create: {
     *     // ... data to create a IrrigationFieldUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationFieldUsage we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationFieldUsageUpsertArgs>(args: SelectSubset<T, IrrigationFieldUsageUpsertArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationFieldUsages that matches the filter.
     * @param {IrrigationFieldUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IrrigationFieldUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IrrigationFieldUsage.
     * @param {IrrigationFieldUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const irrigationFieldUsage = await prisma.irrigationFieldUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IrrigationFieldUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IrrigationFieldUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageCountArgs} args - Arguments to filter IrrigationFieldUsages to count.
     * @example
     * // Count the number of IrrigationFieldUsages
     * const count = await prisma.irrigationFieldUsage.count({
     *   where: {
     *     // ... the filter for the IrrigationFieldUsages we want to count
     *   }
     * })
    **/
    count<T extends IrrigationFieldUsageCountArgs>(
      args?: Subset<T, IrrigationFieldUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationFieldUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationFieldUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationFieldUsageAggregateArgs>(args: Subset<T, IrrigationFieldUsageAggregateArgs>): Prisma.PrismaPromise<GetIrrigationFieldUsageAggregateType<T>>

    /**
     * Group by IrrigationFieldUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationFieldUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationFieldUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationFieldUsageGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationFieldUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationFieldUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationFieldUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationFieldUsage model
   */
  readonly fields: IrrigationFieldUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationFieldUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationFieldUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    irrigationLog<T extends IrrigationLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLogDefaultArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ownerUsages<T extends IrrigationFieldUsage$ownerUsagesArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationFieldUsage$ownerUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationFieldUsage model
   */
  interface IrrigationFieldUsageFieldRefs {
    readonly id: FieldRef<"IrrigationFieldUsage", 'String'>
    readonly irrigationLogId: FieldRef<"IrrigationFieldUsage", 'String'>
    readonly fieldId: FieldRef<"IrrigationFieldUsage", 'String'>
    readonly percentage: FieldRef<"IrrigationFieldUsage", 'Float'>
    readonly actualIrrigatedArea: FieldRef<"IrrigationFieldUsage", 'Float'>
    readonly createdAt: FieldRef<"IrrigationFieldUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationFieldUsage findUnique
   */
  export type IrrigationFieldUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationFieldUsage to fetch.
     */
    where: IrrigationFieldUsageWhereUniqueInput
  }

  /**
   * IrrigationFieldUsage findUniqueOrThrow
   */
  export type IrrigationFieldUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationFieldUsage to fetch.
     */
    where: IrrigationFieldUsageWhereUniqueInput
  }

  /**
   * IrrigationFieldUsage findFirst
   */
  export type IrrigationFieldUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationFieldUsage to fetch.
     */
    where?: IrrigationFieldUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationFieldUsages to fetch.
     */
    orderBy?: IrrigationFieldUsageOrderByWithRelationInput | IrrigationFieldUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationFieldUsages.
     */
    cursor?: IrrigationFieldUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationFieldUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationFieldUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationFieldUsages.
     */
    distinct?: IrrigationFieldUsageScalarFieldEnum | IrrigationFieldUsageScalarFieldEnum[]
  }

  /**
   * IrrigationFieldUsage findFirstOrThrow
   */
  export type IrrigationFieldUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationFieldUsage to fetch.
     */
    where?: IrrigationFieldUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationFieldUsages to fetch.
     */
    orderBy?: IrrigationFieldUsageOrderByWithRelationInput | IrrigationFieldUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationFieldUsages.
     */
    cursor?: IrrigationFieldUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationFieldUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationFieldUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationFieldUsages.
     */
    distinct?: IrrigationFieldUsageScalarFieldEnum | IrrigationFieldUsageScalarFieldEnum[]
  }

  /**
   * IrrigationFieldUsage findMany
   */
  export type IrrigationFieldUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationFieldUsages to fetch.
     */
    where?: IrrigationFieldUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationFieldUsages to fetch.
     */
    orderBy?: IrrigationFieldUsageOrderByWithRelationInput | IrrigationFieldUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationFieldUsages.
     */
    cursor?: IrrigationFieldUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationFieldUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationFieldUsages.
     */
    skip?: number
    distinct?: IrrigationFieldUsageScalarFieldEnum | IrrigationFieldUsageScalarFieldEnum[]
  }

  /**
   * IrrigationFieldUsage create
   */
  export type IrrigationFieldUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationFieldUsage.
     */
    data: XOR<IrrigationFieldUsageCreateInput, IrrigationFieldUsageUncheckedCreateInput>
  }

  /**
   * IrrigationFieldUsage createMany
   */
  export type IrrigationFieldUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationFieldUsages.
     */
    data: IrrigationFieldUsageCreateManyInput | IrrigationFieldUsageCreateManyInput[]
  }

  /**
   * IrrigationFieldUsage update
   */
  export type IrrigationFieldUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationFieldUsage.
     */
    data: XOR<IrrigationFieldUsageUpdateInput, IrrigationFieldUsageUncheckedUpdateInput>
    /**
     * Choose, which IrrigationFieldUsage to update.
     */
    where: IrrigationFieldUsageWhereUniqueInput
  }

  /**
   * IrrigationFieldUsage updateMany
   */
  export type IrrigationFieldUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationFieldUsages.
     */
    data: XOR<IrrigationFieldUsageUpdateManyMutationInput, IrrigationFieldUsageUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationFieldUsages to update
     */
    where?: IrrigationFieldUsageWhereInput
    /**
     * Limit how many IrrigationFieldUsages to update.
     */
    limit?: number
  }

  /**
   * IrrigationFieldUsage upsert
   */
  export type IrrigationFieldUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationFieldUsage to update in case it exists.
     */
    where: IrrigationFieldUsageWhereUniqueInput
    /**
     * In case the IrrigationFieldUsage found by the `where` argument doesn't exist, create a new IrrigationFieldUsage with this data.
     */
    create: XOR<IrrigationFieldUsageCreateInput, IrrigationFieldUsageUncheckedCreateInput>
    /**
     * In case the IrrigationFieldUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationFieldUsageUpdateInput, IrrigationFieldUsageUncheckedUpdateInput>
  }

  /**
   * IrrigationFieldUsage delete
   */
  export type IrrigationFieldUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
    /**
     * Filter which IrrigationFieldUsage to delete.
     */
    where: IrrigationFieldUsageWhereUniqueInput
  }

  /**
   * IrrigationFieldUsage deleteMany
   */
  export type IrrigationFieldUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationFieldUsages to delete
     */
    where?: IrrigationFieldUsageWhereInput
    /**
     * Limit how many IrrigationFieldUsages to delete.
     */
    limit?: number
  }

  /**
   * IrrigationFieldUsage findRaw
   */
  export type IrrigationFieldUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationFieldUsage aggregateRaw
   */
  export type IrrigationFieldUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationFieldUsage.ownerUsages
   */
  export type IrrigationFieldUsage$ownerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    where?: IrrigationOwnerUsageWhereInput
    orderBy?: IrrigationOwnerUsageOrderByWithRelationInput | IrrigationOwnerUsageOrderByWithRelationInput[]
    cursor?: IrrigationOwnerUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationOwnerUsageScalarFieldEnum | IrrigationOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationFieldUsage without action
   */
  export type IrrigationFieldUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationFieldUsage
     */
    select?: IrrigationFieldUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationFieldUsage
     */
    omit?: IrrigationFieldUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationFieldUsageInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationOwnerUsage
   */

  export type AggregateIrrigationOwnerUsage = {
    _count: IrrigationOwnerUsageCountAggregateOutputType | null
    _avg: IrrigationOwnerUsageAvgAggregateOutputType | null
    _sum: IrrigationOwnerUsageSumAggregateOutputType | null
    _min: IrrigationOwnerUsageMinAggregateOutputType | null
    _max: IrrigationOwnerUsageMaxAggregateOutputType | null
  }

  export type IrrigationOwnerUsageAvgAggregateOutputType = {
    ownershipPercentage: number | null
    usagePercentage: number | null
  }

  export type IrrigationOwnerUsageSumAggregateOutputType = {
    ownershipPercentage: number | null
    usagePercentage: number | null
  }

  export type IrrigationOwnerUsageMinAggregateOutputType = {
    id: string | null
    irrigationFieldUsageId: string | null
    ownerId: string | null
    ownershipPercentage: number | null
    usagePercentage: number | null
    createdAt: Date | null
  }

  export type IrrigationOwnerUsageMaxAggregateOutputType = {
    id: string | null
    irrigationFieldUsageId: string | null
    ownerId: string | null
    ownershipPercentage: number | null
    usagePercentage: number | null
    createdAt: Date | null
  }

  export type IrrigationOwnerUsageCountAggregateOutputType = {
    id: number
    irrigationFieldUsageId: number
    ownerId: number
    ownershipPercentage: number
    usagePercentage: number
    createdAt: number
    _all: number
  }


  export type IrrigationOwnerUsageAvgAggregateInputType = {
    ownershipPercentage?: true
    usagePercentage?: true
  }

  export type IrrigationOwnerUsageSumAggregateInputType = {
    ownershipPercentage?: true
    usagePercentage?: true
  }

  export type IrrigationOwnerUsageMinAggregateInputType = {
    id?: true
    irrigationFieldUsageId?: true
    ownerId?: true
    ownershipPercentage?: true
    usagePercentage?: true
    createdAt?: true
  }

  export type IrrigationOwnerUsageMaxAggregateInputType = {
    id?: true
    irrigationFieldUsageId?: true
    ownerId?: true
    ownershipPercentage?: true
    usagePercentage?: true
    createdAt?: true
  }

  export type IrrigationOwnerUsageCountAggregateInputType = {
    id?: true
    irrigationFieldUsageId?: true
    ownerId?: true
    ownershipPercentage?: true
    usagePercentage?: true
    createdAt?: true
    _all?: true
  }

  export type IrrigationOwnerUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationOwnerUsage to aggregate.
     */
    where?: IrrigationOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerUsages to fetch.
     */
    orderBy?: IrrigationOwnerUsageOrderByWithRelationInput | IrrigationOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationOwnerUsages
    **/
    _count?: true | IrrigationOwnerUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationOwnerUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationOwnerUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationOwnerUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationOwnerUsageMaxAggregateInputType
  }

  export type GetIrrigationOwnerUsageAggregateType<T extends IrrigationOwnerUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationOwnerUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationOwnerUsage[P]>
      : GetScalarType<T[P], AggregateIrrigationOwnerUsage[P]>
  }




  export type IrrigationOwnerUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationOwnerUsageWhereInput
    orderBy?: IrrigationOwnerUsageOrderByWithAggregationInput | IrrigationOwnerUsageOrderByWithAggregationInput[]
    by: IrrigationOwnerUsageScalarFieldEnum[] | IrrigationOwnerUsageScalarFieldEnum
    having?: IrrigationOwnerUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationOwnerUsageCountAggregateInputType | true
    _avg?: IrrigationOwnerUsageAvgAggregateInputType
    _sum?: IrrigationOwnerUsageSumAggregateInputType
    _min?: IrrigationOwnerUsageMinAggregateInputType
    _max?: IrrigationOwnerUsageMaxAggregateInputType
  }

  export type IrrigationOwnerUsageGroupByOutputType = {
    id: string
    irrigationFieldUsageId: string
    ownerId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt: Date
    _count: IrrigationOwnerUsageCountAggregateOutputType | null
    _avg: IrrigationOwnerUsageAvgAggregateOutputType | null
    _sum: IrrigationOwnerUsageSumAggregateOutputType | null
    _min: IrrigationOwnerUsageMinAggregateOutputType | null
    _max: IrrigationOwnerUsageMaxAggregateOutputType | null
  }

  type GetIrrigationOwnerUsageGroupByPayload<T extends IrrigationOwnerUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationOwnerUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationOwnerUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationOwnerUsageGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationOwnerUsageGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationOwnerUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    irrigationFieldUsageId?: boolean
    ownerId?: boolean
    ownershipPercentage?: boolean
    usagePercentage?: boolean
    createdAt?: boolean
    irrigationFieldUsage?: boolean | IrrigationFieldUsageDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationOwnerUsage"]>



  export type IrrigationOwnerUsageSelectScalar = {
    id?: boolean
    irrigationFieldUsageId?: boolean
    ownerId?: boolean
    ownershipPercentage?: boolean
    usagePercentage?: boolean
    createdAt?: boolean
  }

  export type IrrigationOwnerUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "irrigationFieldUsageId" | "ownerId" | "ownershipPercentage" | "usagePercentage" | "createdAt", ExtArgs["result"]["irrigationOwnerUsage"]>
  export type IrrigationOwnerUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationFieldUsage?: boolean | IrrigationFieldUsageDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IrrigationOwnerUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationOwnerUsage"
    objects: {
      irrigationFieldUsage: Prisma.$IrrigationFieldUsagePayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      irrigationFieldUsageId: string
      ownerId: string
      ownershipPercentage: number
      usagePercentage: number
      createdAt: Date
    }, ExtArgs["result"]["irrigationOwnerUsage"]>
    composites: {}
  }

  type IrrigationOwnerUsageGetPayload<S extends boolean | null | undefined | IrrigationOwnerUsageDefaultArgs> = $Result.GetResult<Prisma.$IrrigationOwnerUsagePayload, S>

  type IrrigationOwnerUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationOwnerUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationOwnerUsageCountAggregateInputType | true
    }

  export interface IrrigationOwnerUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationOwnerUsage'], meta: { name: 'IrrigationOwnerUsage' } }
    /**
     * Find zero or one IrrigationOwnerUsage that matches the filter.
     * @param {IrrigationOwnerUsageFindUniqueArgs} args - Arguments to find a IrrigationOwnerUsage
     * @example
     * // Get one IrrigationOwnerUsage
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationOwnerUsageFindUniqueArgs>(args: SelectSubset<T, IrrigationOwnerUsageFindUniqueArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationOwnerUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationOwnerUsageFindUniqueOrThrowArgs} args - Arguments to find a IrrigationOwnerUsage
     * @example
     * // Get one IrrigationOwnerUsage
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationOwnerUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationOwnerUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationOwnerUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageFindFirstArgs} args - Arguments to find a IrrigationOwnerUsage
     * @example
     * // Get one IrrigationOwnerUsage
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationOwnerUsageFindFirstArgs>(args?: SelectSubset<T, IrrigationOwnerUsageFindFirstArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationOwnerUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageFindFirstOrThrowArgs} args - Arguments to find a IrrigationOwnerUsage
     * @example
     * // Get one IrrigationOwnerUsage
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationOwnerUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationOwnerUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationOwnerUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationOwnerUsages
     * const irrigationOwnerUsages = await prisma.irrigationOwnerUsage.findMany()
     * 
     * // Get first 10 IrrigationOwnerUsages
     * const irrigationOwnerUsages = await prisma.irrigationOwnerUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationOwnerUsageWithIdOnly = await prisma.irrigationOwnerUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationOwnerUsageFindManyArgs>(args?: SelectSubset<T, IrrigationOwnerUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationOwnerUsage.
     * @param {IrrigationOwnerUsageCreateArgs} args - Arguments to create a IrrigationOwnerUsage.
     * @example
     * // Create one IrrigationOwnerUsage
     * const IrrigationOwnerUsage = await prisma.irrigationOwnerUsage.create({
     *   data: {
     *     // ... data to create a IrrigationOwnerUsage
     *   }
     * })
     * 
     */
    create<T extends IrrigationOwnerUsageCreateArgs>(args: SelectSubset<T, IrrigationOwnerUsageCreateArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationOwnerUsages.
     * @param {IrrigationOwnerUsageCreateManyArgs} args - Arguments to create many IrrigationOwnerUsages.
     * @example
     * // Create many IrrigationOwnerUsages
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationOwnerUsageCreateManyArgs>(args?: SelectSubset<T, IrrigationOwnerUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IrrigationOwnerUsage.
     * @param {IrrigationOwnerUsageDeleteArgs} args - Arguments to delete one IrrigationOwnerUsage.
     * @example
     * // Delete one IrrigationOwnerUsage
     * const IrrigationOwnerUsage = await prisma.irrigationOwnerUsage.delete({
     *   where: {
     *     // ... filter to delete one IrrigationOwnerUsage
     *   }
     * })
     * 
     */
    delete<T extends IrrigationOwnerUsageDeleteArgs>(args: SelectSubset<T, IrrigationOwnerUsageDeleteArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationOwnerUsage.
     * @param {IrrigationOwnerUsageUpdateArgs} args - Arguments to update one IrrigationOwnerUsage.
     * @example
     * // Update one IrrigationOwnerUsage
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationOwnerUsageUpdateArgs>(args: SelectSubset<T, IrrigationOwnerUsageUpdateArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationOwnerUsages.
     * @param {IrrigationOwnerUsageDeleteManyArgs} args - Arguments to filter IrrigationOwnerUsages to delete.
     * @example
     * // Delete a few IrrigationOwnerUsages
     * const { count } = await prisma.irrigationOwnerUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationOwnerUsageDeleteManyArgs>(args?: SelectSubset<T, IrrigationOwnerUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationOwnerUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationOwnerUsages
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationOwnerUsageUpdateManyArgs>(args: SelectSubset<T, IrrigationOwnerUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IrrigationOwnerUsage.
     * @param {IrrigationOwnerUsageUpsertArgs} args - Arguments to update or create a IrrigationOwnerUsage.
     * @example
     * // Update or create a IrrigationOwnerUsage
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.upsert({
     *   create: {
     *     // ... data to create a IrrigationOwnerUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationOwnerUsage we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationOwnerUsageUpsertArgs>(args: SelectSubset<T, IrrigationOwnerUsageUpsertArgs<ExtArgs>>): Prisma__IrrigationOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationOwnerUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationOwnerUsages that matches the filter.
     * @param {IrrigationOwnerUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IrrigationOwnerUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IrrigationOwnerUsage.
     * @param {IrrigationOwnerUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const irrigationOwnerUsage = await prisma.irrigationOwnerUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IrrigationOwnerUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IrrigationOwnerUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageCountArgs} args - Arguments to filter IrrigationOwnerUsages to count.
     * @example
     * // Count the number of IrrigationOwnerUsages
     * const count = await prisma.irrigationOwnerUsage.count({
     *   where: {
     *     // ... the filter for the IrrigationOwnerUsages we want to count
     *   }
     * })
    **/
    count<T extends IrrigationOwnerUsageCountArgs>(
      args?: Subset<T, IrrigationOwnerUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationOwnerUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationOwnerUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationOwnerUsageAggregateArgs>(args: Subset<T, IrrigationOwnerUsageAggregateArgs>): Prisma.PrismaPromise<GetIrrigationOwnerUsageAggregateType<T>>

    /**
     * Group by IrrigationOwnerUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationOwnerUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationOwnerUsageGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationOwnerUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationOwnerUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationOwnerUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationOwnerUsage model
   */
  readonly fields: IrrigationOwnerUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationOwnerUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationOwnerUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    irrigationFieldUsage<T extends IrrigationFieldUsageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationFieldUsageDefaultArgs<ExtArgs>>): Prisma__IrrigationFieldUsageClient<$Result.GetResult<Prisma.$IrrigationFieldUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationOwnerUsage model
   */
  interface IrrigationOwnerUsageFieldRefs {
    readonly id: FieldRef<"IrrigationOwnerUsage", 'String'>
    readonly irrigationFieldUsageId: FieldRef<"IrrigationOwnerUsage", 'String'>
    readonly ownerId: FieldRef<"IrrigationOwnerUsage", 'String'>
    readonly ownershipPercentage: FieldRef<"IrrigationOwnerUsage", 'Float'>
    readonly usagePercentage: FieldRef<"IrrigationOwnerUsage", 'Float'>
    readonly createdAt: FieldRef<"IrrigationOwnerUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationOwnerUsage findUnique
   */
  export type IrrigationOwnerUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerUsage to fetch.
     */
    where: IrrigationOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationOwnerUsage findUniqueOrThrow
   */
  export type IrrigationOwnerUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerUsage to fetch.
     */
    where: IrrigationOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationOwnerUsage findFirst
   */
  export type IrrigationOwnerUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerUsage to fetch.
     */
    where?: IrrigationOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerUsages to fetch.
     */
    orderBy?: IrrigationOwnerUsageOrderByWithRelationInput | IrrigationOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationOwnerUsages.
     */
    cursor?: IrrigationOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationOwnerUsages.
     */
    distinct?: IrrigationOwnerUsageScalarFieldEnum | IrrigationOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationOwnerUsage findFirstOrThrow
   */
  export type IrrigationOwnerUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerUsage to fetch.
     */
    where?: IrrigationOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerUsages to fetch.
     */
    orderBy?: IrrigationOwnerUsageOrderByWithRelationInput | IrrigationOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationOwnerUsages.
     */
    cursor?: IrrigationOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationOwnerUsages.
     */
    distinct?: IrrigationOwnerUsageScalarFieldEnum | IrrigationOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationOwnerUsage findMany
   */
  export type IrrigationOwnerUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerUsages to fetch.
     */
    where?: IrrigationOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerUsages to fetch.
     */
    orderBy?: IrrigationOwnerUsageOrderByWithRelationInput | IrrigationOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationOwnerUsages.
     */
    cursor?: IrrigationOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerUsages.
     */
    skip?: number
    distinct?: IrrigationOwnerUsageScalarFieldEnum | IrrigationOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationOwnerUsage create
   */
  export type IrrigationOwnerUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationOwnerUsage.
     */
    data: XOR<IrrigationOwnerUsageCreateInput, IrrigationOwnerUsageUncheckedCreateInput>
  }

  /**
   * IrrigationOwnerUsage createMany
   */
  export type IrrigationOwnerUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationOwnerUsages.
     */
    data: IrrigationOwnerUsageCreateManyInput | IrrigationOwnerUsageCreateManyInput[]
  }

  /**
   * IrrigationOwnerUsage update
   */
  export type IrrigationOwnerUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationOwnerUsage.
     */
    data: XOR<IrrigationOwnerUsageUpdateInput, IrrigationOwnerUsageUncheckedUpdateInput>
    /**
     * Choose, which IrrigationOwnerUsage to update.
     */
    where: IrrigationOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationOwnerUsage updateMany
   */
  export type IrrigationOwnerUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationOwnerUsages.
     */
    data: XOR<IrrigationOwnerUsageUpdateManyMutationInput, IrrigationOwnerUsageUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationOwnerUsages to update
     */
    where?: IrrigationOwnerUsageWhereInput
    /**
     * Limit how many IrrigationOwnerUsages to update.
     */
    limit?: number
  }

  /**
   * IrrigationOwnerUsage upsert
   */
  export type IrrigationOwnerUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationOwnerUsage to update in case it exists.
     */
    where: IrrigationOwnerUsageWhereUniqueInput
    /**
     * In case the IrrigationOwnerUsage found by the `where` argument doesn't exist, create a new IrrigationOwnerUsage with this data.
     */
    create: XOR<IrrigationOwnerUsageCreateInput, IrrigationOwnerUsageUncheckedCreateInput>
    /**
     * In case the IrrigationOwnerUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationOwnerUsageUpdateInput, IrrigationOwnerUsageUncheckedUpdateInput>
  }

  /**
   * IrrigationOwnerUsage delete
   */
  export type IrrigationOwnerUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter which IrrigationOwnerUsage to delete.
     */
    where: IrrigationOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationOwnerUsage deleteMany
   */
  export type IrrigationOwnerUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationOwnerUsages to delete
     */
    where?: IrrigationOwnerUsageWhereInput
    /**
     * Limit how many IrrigationOwnerUsages to delete.
     */
    limit?: number
  }

  /**
   * IrrigationOwnerUsage findRaw
   */
  export type IrrigationOwnerUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationOwnerUsage aggregateRaw
   */
  export type IrrigationOwnerUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationOwnerUsage without action
   */
  export type IrrigationOwnerUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerUsage
     */
    select?: IrrigationOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerUsage
     */
    omit?: IrrigationOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerUsageInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationOwnerSummary
   */

  export type AggregateIrrigationOwnerSummary = {
    _count: IrrigationOwnerSummaryCountAggregateOutputType | null
    _avg: IrrigationOwnerSummaryAvgAggregateOutputType | null
    _sum: IrrigationOwnerSummarySumAggregateOutputType | null
    _min: IrrigationOwnerSummaryMinAggregateOutputType | null
    _max: IrrigationOwnerSummaryMaxAggregateOutputType | null
  }

  export type IrrigationOwnerSummaryAvgAggregateOutputType = {
    totalIrrigatedArea: number | null
    totalAllocatedDuration: number | null
  }

  export type IrrigationOwnerSummarySumAggregateOutputType = {
    totalIrrigatedArea: number | null
    totalAllocatedDuration: number | null
  }

  export type IrrigationOwnerSummaryMinAggregateOutputType = {
    id: string | null
    irrigationLogId: string | null
    ownerId: string | null
    totalIrrigatedArea: number | null
    totalAllocatedDuration: number | null
    createdAt: Date | null
  }

  export type IrrigationOwnerSummaryMaxAggregateOutputType = {
    id: string | null
    irrigationLogId: string | null
    ownerId: string | null
    totalIrrigatedArea: number | null
    totalAllocatedDuration: number | null
    createdAt: Date | null
  }

  export type IrrigationOwnerSummaryCountAggregateOutputType = {
    id: number
    irrigationLogId: number
    ownerId: number
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt: number
    _all: number
  }


  export type IrrigationOwnerSummaryAvgAggregateInputType = {
    totalIrrigatedArea?: true
    totalAllocatedDuration?: true
  }

  export type IrrigationOwnerSummarySumAggregateInputType = {
    totalIrrigatedArea?: true
    totalAllocatedDuration?: true
  }

  export type IrrigationOwnerSummaryMinAggregateInputType = {
    id?: true
    irrigationLogId?: true
    ownerId?: true
    totalIrrigatedArea?: true
    totalAllocatedDuration?: true
    createdAt?: true
  }

  export type IrrigationOwnerSummaryMaxAggregateInputType = {
    id?: true
    irrigationLogId?: true
    ownerId?: true
    totalIrrigatedArea?: true
    totalAllocatedDuration?: true
    createdAt?: true
  }

  export type IrrigationOwnerSummaryCountAggregateInputType = {
    id?: true
    irrigationLogId?: true
    ownerId?: true
    totalIrrigatedArea?: true
    totalAllocatedDuration?: true
    createdAt?: true
    _all?: true
  }

  export type IrrigationOwnerSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationOwnerSummary to aggregate.
     */
    where?: IrrigationOwnerSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerSummaries to fetch.
     */
    orderBy?: IrrigationOwnerSummaryOrderByWithRelationInput | IrrigationOwnerSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationOwnerSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationOwnerSummaries
    **/
    _count?: true | IrrigationOwnerSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationOwnerSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationOwnerSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationOwnerSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationOwnerSummaryMaxAggregateInputType
  }

  export type GetIrrigationOwnerSummaryAggregateType<T extends IrrigationOwnerSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationOwnerSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationOwnerSummary[P]>
      : GetScalarType<T[P], AggregateIrrigationOwnerSummary[P]>
  }




  export type IrrigationOwnerSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationOwnerSummaryWhereInput
    orderBy?: IrrigationOwnerSummaryOrderByWithAggregationInput | IrrigationOwnerSummaryOrderByWithAggregationInput[]
    by: IrrigationOwnerSummaryScalarFieldEnum[] | IrrigationOwnerSummaryScalarFieldEnum
    having?: IrrigationOwnerSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationOwnerSummaryCountAggregateInputType | true
    _avg?: IrrigationOwnerSummaryAvgAggregateInputType
    _sum?: IrrigationOwnerSummarySumAggregateInputType
    _min?: IrrigationOwnerSummaryMinAggregateInputType
    _max?: IrrigationOwnerSummaryMaxAggregateInputType
  }

  export type IrrigationOwnerSummaryGroupByOutputType = {
    id: string
    irrigationLogId: string
    ownerId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt: Date
    _count: IrrigationOwnerSummaryCountAggregateOutputType | null
    _avg: IrrigationOwnerSummaryAvgAggregateOutputType | null
    _sum: IrrigationOwnerSummarySumAggregateOutputType | null
    _min: IrrigationOwnerSummaryMinAggregateOutputType | null
    _max: IrrigationOwnerSummaryMaxAggregateOutputType | null
  }

  type GetIrrigationOwnerSummaryGroupByPayload<T extends IrrigationOwnerSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationOwnerSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationOwnerSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationOwnerSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationOwnerSummaryGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationOwnerSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    irrigationLogId?: boolean
    ownerId?: boolean
    totalIrrigatedArea?: boolean
    totalAllocatedDuration?: boolean
    createdAt?: boolean
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationOwnerSummary"]>



  export type IrrigationOwnerSummarySelectScalar = {
    id?: boolean
    irrigationLogId?: boolean
    ownerId?: boolean
    totalIrrigatedArea?: boolean
    totalAllocatedDuration?: boolean
    createdAt?: boolean
  }

  export type IrrigationOwnerSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "irrigationLogId" | "ownerId" | "totalIrrigatedArea" | "totalAllocatedDuration" | "createdAt", ExtArgs["result"]["irrigationOwnerSummary"]>
  export type IrrigationOwnerSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IrrigationOwnerSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationOwnerSummary"
    objects: {
      irrigationLog: Prisma.$IrrigationLogPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      irrigationLogId: string
      ownerId: string
      totalIrrigatedArea: number
      totalAllocatedDuration: number
      createdAt: Date
    }, ExtArgs["result"]["irrigationOwnerSummary"]>
    composites: {}
  }

  type IrrigationOwnerSummaryGetPayload<S extends boolean | null | undefined | IrrigationOwnerSummaryDefaultArgs> = $Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload, S>

  type IrrigationOwnerSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationOwnerSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationOwnerSummaryCountAggregateInputType | true
    }

  export interface IrrigationOwnerSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationOwnerSummary'], meta: { name: 'IrrigationOwnerSummary' } }
    /**
     * Find zero or one IrrigationOwnerSummary that matches the filter.
     * @param {IrrigationOwnerSummaryFindUniqueArgs} args - Arguments to find a IrrigationOwnerSummary
     * @example
     * // Get one IrrigationOwnerSummary
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationOwnerSummaryFindUniqueArgs>(args: SelectSubset<T, IrrigationOwnerSummaryFindUniqueArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationOwnerSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationOwnerSummaryFindUniqueOrThrowArgs} args - Arguments to find a IrrigationOwnerSummary
     * @example
     * // Get one IrrigationOwnerSummary
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationOwnerSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationOwnerSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationOwnerSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryFindFirstArgs} args - Arguments to find a IrrigationOwnerSummary
     * @example
     * // Get one IrrigationOwnerSummary
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationOwnerSummaryFindFirstArgs>(args?: SelectSubset<T, IrrigationOwnerSummaryFindFirstArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationOwnerSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryFindFirstOrThrowArgs} args - Arguments to find a IrrigationOwnerSummary
     * @example
     * // Get one IrrigationOwnerSummary
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationOwnerSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationOwnerSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationOwnerSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationOwnerSummaries
     * const irrigationOwnerSummaries = await prisma.irrigationOwnerSummary.findMany()
     * 
     * // Get first 10 IrrigationOwnerSummaries
     * const irrigationOwnerSummaries = await prisma.irrigationOwnerSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationOwnerSummaryWithIdOnly = await prisma.irrigationOwnerSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationOwnerSummaryFindManyArgs>(args?: SelectSubset<T, IrrigationOwnerSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationOwnerSummary.
     * @param {IrrigationOwnerSummaryCreateArgs} args - Arguments to create a IrrigationOwnerSummary.
     * @example
     * // Create one IrrigationOwnerSummary
     * const IrrigationOwnerSummary = await prisma.irrigationOwnerSummary.create({
     *   data: {
     *     // ... data to create a IrrigationOwnerSummary
     *   }
     * })
     * 
     */
    create<T extends IrrigationOwnerSummaryCreateArgs>(args: SelectSubset<T, IrrigationOwnerSummaryCreateArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationOwnerSummaries.
     * @param {IrrigationOwnerSummaryCreateManyArgs} args - Arguments to create many IrrigationOwnerSummaries.
     * @example
     * // Create many IrrigationOwnerSummaries
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationOwnerSummaryCreateManyArgs>(args?: SelectSubset<T, IrrigationOwnerSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IrrigationOwnerSummary.
     * @param {IrrigationOwnerSummaryDeleteArgs} args - Arguments to delete one IrrigationOwnerSummary.
     * @example
     * // Delete one IrrigationOwnerSummary
     * const IrrigationOwnerSummary = await prisma.irrigationOwnerSummary.delete({
     *   where: {
     *     // ... filter to delete one IrrigationOwnerSummary
     *   }
     * })
     * 
     */
    delete<T extends IrrigationOwnerSummaryDeleteArgs>(args: SelectSubset<T, IrrigationOwnerSummaryDeleteArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationOwnerSummary.
     * @param {IrrigationOwnerSummaryUpdateArgs} args - Arguments to update one IrrigationOwnerSummary.
     * @example
     * // Update one IrrigationOwnerSummary
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationOwnerSummaryUpdateArgs>(args: SelectSubset<T, IrrigationOwnerSummaryUpdateArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationOwnerSummaries.
     * @param {IrrigationOwnerSummaryDeleteManyArgs} args - Arguments to filter IrrigationOwnerSummaries to delete.
     * @example
     * // Delete a few IrrigationOwnerSummaries
     * const { count } = await prisma.irrigationOwnerSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationOwnerSummaryDeleteManyArgs>(args?: SelectSubset<T, IrrigationOwnerSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationOwnerSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationOwnerSummaries
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationOwnerSummaryUpdateManyArgs>(args: SelectSubset<T, IrrigationOwnerSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IrrigationOwnerSummary.
     * @param {IrrigationOwnerSummaryUpsertArgs} args - Arguments to update or create a IrrigationOwnerSummary.
     * @example
     * // Update or create a IrrigationOwnerSummary
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.upsert({
     *   create: {
     *     // ... data to create a IrrigationOwnerSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationOwnerSummary we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationOwnerSummaryUpsertArgs>(args: SelectSubset<T, IrrigationOwnerSummaryUpsertArgs<ExtArgs>>): Prisma__IrrigationOwnerSummaryClient<$Result.GetResult<Prisma.$IrrigationOwnerSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationOwnerSummaries that matches the filter.
     * @param {IrrigationOwnerSummaryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IrrigationOwnerSummaryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IrrigationOwnerSummary.
     * @param {IrrigationOwnerSummaryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const irrigationOwnerSummary = await prisma.irrigationOwnerSummary.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IrrigationOwnerSummaryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IrrigationOwnerSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryCountArgs} args - Arguments to filter IrrigationOwnerSummaries to count.
     * @example
     * // Count the number of IrrigationOwnerSummaries
     * const count = await prisma.irrigationOwnerSummary.count({
     *   where: {
     *     // ... the filter for the IrrigationOwnerSummaries we want to count
     *   }
     * })
    **/
    count<T extends IrrigationOwnerSummaryCountArgs>(
      args?: Subset<T, IrrigationOwnerSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationOwnerSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationOwnerSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationOwnerSummaryAggregateArgs>(args: Subset<T, IrrigationOwnerSummaryAggregateArgs>): Prisma.PrismaPromise<GetIrrigationOwnerSummaryAggregateType<T>>

    /**
     * Group by IrrigationOwnerSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationOwnerSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationOwnerSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationOwnerSummaryGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationOwnerSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationOwnerSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationOwnerSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationOwnerSummary model
   */
  readonly fields: IrrigationOwnerSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationOwnerSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationOwnerSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    irrigationLog<T extends IrrigationLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLogDefaultArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationOwnerSummary model
   */
  interface IrrigationOwnerSummaryFieldRefs {
    readonly id: FieldRef<"IrrigationOwnerSummary", 'String'>
    readonly irrigationLogId: FieldRef<"IrrigationOwnerSummary", 'String'>
    readonly ownerId: FieldRef<"IrrigationOwnerSummary", 'String'>
    readonly totalIrrigatedArea: FieldRef<"IrrigationOwnerSummary", 'Float'>
    readonly totalAllocatedDuration: FieldRef<"IrrigationOwnerSummary", 'Float'>
    readonly createdAt: FieldRef<"IrrigationOwnerSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationOwnerSummary findUnique
   */
  export type IrrigationOwnerSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerSummary to fetch.
     */
    where: IrrigationOwnerSummaryWhereUniqueInput
  }

  /**
   * IrrigationOwnerSummary findUniqueOrThrow
   */
  export type IrrigationOwnerSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerSummary to fetch.
     */
    where: IrrigationOwnerSummaryWhereUniqueInput
  }

  /**
   * IrrigationOwnerSummary findFirst
   */
  export type IrrigationOwnerSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerSummary to fetch.
     */
    where?: IrrigationOwnerSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerSummaries to fetch.
     */
    orderBy?: IrrigationOwnerSummaryOrderByWithRelationInput | IrrigationOwnerSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationOwnerSummaries.
     */
    cursor?: IrrigationOwnerSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationOwnerSummaries.
     */
    distinct?: IrrigationOwnerSummaryScalarFieldEnum | IrrigationOwnerSummaryScalarFieldEnum[]
  }

  /**
   * IrrigationOwnerSummary findFirstOrThrow
   */
  export type IrrigationOwnerSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerSummary to fetch.
     */
    where?: IrrigationOwnerSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerSummaries to fetch.
     */
    orderBy?: IrrigationOwnerSummaryOrderByWithRelationInput | IrrigationOwnerSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationOwnerSummaries.
     */
    cursor?: IrrigationOwnerSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationOwnerSummaries.
     */
    distinct?: IrrigationOwnerSummaryScalarFieldEnum | IrrigationOwnerSummaryScalarFieldEnum[]
  }

  /**
   * IrrigationOwnerSummary findMany
   */
  export type IrrigationOwnerSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationOwnerSummaries to fetch.
     */
    where?: IrrigationOwnerSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationOwnerSummaries to fetch.
     */
    orderBy?: IrrigationOwnerSummaryOrderByWithRelationInput | IrrigationOwnerSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationOwnerSummaries.
     */
    cursor?: IrrigationOwnerSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationOwnerSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationOwnerSummaries.
     */
    skip?: number
    distinct?: IrrigationOwnerSummaryScalarFieldEnum | IrrigationOwnerSummaryScalarFieldEnum[]
  }

  /**
   * IrrigationOwnerSummary create
   */
  export type IrrigationOwnerSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationOwnerSummary.
     */
    data: XOR<IrrigationOwnerSummaryCreateInput, IrrigationOwnerSummaryUncheckedCreateInput>
  }

  /**
   * IrrigationOwnerSummary createMany
   */
  export type IrrigationOwnerSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationOwnerSummaries.
     */
    data: IrrigationOwnerSummaryCreateManyInput | IrrigationOwnerSummaryCreateManyInput[]
  }

  /**
   * IrrigationOwnerSummary update
   */
  export type IrrigationOwnerSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationOwnerSummary.
     */
    data: XOR<IrrigationOwnerSummaryUpdateInput, IrrigationOwnerSummaryUncheckedUpdateInput>
    /**
     * Choose, which IrrigationOwnerSummary to update.
     */
    where: IrrigationOwnerSummaryWhereUniqueInput
  }

  /**
   * IrrigationOwnerSummary updateMany
   */
  export type IrrigationOwnerSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationOwnerSummaries.
     */
    data: XOR<IrrigationOwnerSummaryUpdateManyMutationInput, IrrigationOwnerSummaryUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationOwnerSummaries to update
     */
    where?: IrrigationOwnerSummaryWhereInput
    /**
     * Limit how many IrrigationOwnerSummaries to update.
     */
    limit?: number
  }

  /**
   * IrrigationOwnerSummary upsert
   */
  export type IrrigationOwnerSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationOwnerSummary to update in case it exists.
     */
    where: IrrigationOwnerSummaryWhereUniqueInput
    /**
     * In case the IrrigationOwnerSummary found by the `where` argument doesn't exist, create a new IrrigationOwnerSummary with this data.
     */
    create: XOR<IrrigationOwnerSummaryCreateInput, IrrigationOwnerSummaryUncheckedCreateInput>
    /**
     * In case the IrrigationOwnerSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationOwnerSummaryUpdateInput, IrrigationOwnerSummaryUncheckedUpdateInput>
  }

  /**
   * IrrigationOwnerSummary delete
   */
  export type IrrigationOwnerSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
    /**
     * Filter which IrrigationOwnerSummary to delete.
     */
    where: IrrigationOwnerSummaryWhereUniqueInput
  }

  /**
   * IrrigationOwnerSummary deleteMany
   */
  export type IrrigationOwnerSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationOwnerSummaries to delete
     */
    where?: IrrigationOwnerSummaryWhereInput
    /**
     * Limit how many IrrigationOwnerSummaries to delete.
     */
    limit?: number
  }

  /**
   * IrrigationOwnerSummary findRaw
   */
  export type IrrigationOwnerSummaryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationOwnerSummary aggregateRaw
   */
  export type IrrigationOwnerSummaryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationOwnerSummary without action
   */
  export type IrrigationOwnerSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationOwnerSummary
     */
    select?: IrrigationOwnerSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationOwnerSummary
     */
    omit?: IrrigationOwnerSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationOwnerSummaryInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationInventoryUsage
   */

  export type AggregateIrrigationInventoryUsage = {
    _count: IrrigationInventoryUsageCountAggregateOutputType | null
    _avg: IrrigationInventoryUsageAvgAggregateOutputType | null
    _sum: IrrigationInventoryUsageSumAggregateOutputType | null
    _min: IrrigationInventoryUsageMinAggregateOutputType | null
    _max: IrrigationInventoryUsageMaxAggregateOutputType | null
  }

  export type IrrigationInventoryUsageAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalCost: number | null
  }

  export type IrrigationInventoryUsageSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalCost: number | null
  }

  export type IrrigationInventoryUsageMinAggregateOutputType = {
    id: string | null
    irrigationLogId: string | null
    inventoryId: string | null
    quantity: number | null
    unitPrice: number | null
    totalCost: number | null
    createdAt: Date | null
  }

  export type IrrigationInventoryUsageMaxAggregateOutputType = {
    id: string | null
    irrigationLogId: string | null
    inventoryId: string | null
    quantity: number | null
    unitPrice: number | null
    totalCost: number | null
    createdAt: Date | null
  }

  export type IrrigationInventoryUsageCountAggregateOutputType = {
    id: number
    irrigationLogId: number
    inventoryId: number
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt: number
    _all: number
  }


  export type IrrigationInventoryUsageAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
  }

  export type IrrigationInventoryUsageSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalCost?: true
  }

  export type IrrigationInventoryUsageMinAggregateInputType = {
    id?: true
    irrigationLogId?: true
    inventoryId?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    createdAt?: true
  }

  export type IrrigationInventoryUsageMaxAggregateInputType = {
    id?: true
    irrigationLogId?: true
    inventoryId?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    createdAt?: true
  }

  export type IrrigationInventoryUsageCountAggregateInputType = {
    id?: true
    irrigationLogId?: true
    inventoryId?: true
    quantity?: true
    unitPrice?: true
    totalCost?: true
    createdAt?: true
    _all?: true
  }

  export type IrrigationInventoryUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationInventoryUsage to aggregate.
     */
    where?: IrrigationInventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryUsages to fetch.
     */
    orderBy?: IrrigationInventoryUsageOrderByWithRelationInput | IrrigationInventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationInventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationInventoryUsages
    **/
    _count?: true | IrrigationInventoryUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationInventoryUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationInventoryUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationInventoryUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationInventoryUsageMaxAggregateInputType
  }

  export type GetIrrigationInventoryUsageAggregateType<T extends IrrigationInventoryUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationInventoryUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationInventoryUsage[P]>
      : GetScalarType<T[P], AggregateIrrigationInventoryUsage[P]>
  }




  export type IrrigationInventoryUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationInventoryUsageWhereInput
    orderBy?: IrrigationInventoryUsageOrderByWithAggregationInput | IrrigationInventoryUsageOrderByWithAggregationInput[]
    by: IrrigationInventoryUsageScalarFieldEnum[] | IrrigationInventoryUsageScalarFieldEnum
    having?: IrrigationInventoryUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationInventoryUsageCountAggregateInputType | true
    _avg?: IrrigationInventoryUsageAvgAggregateInputType
    _sum?: IrrigationInventoryUsageSumAggregateInputType
    _min?: IrrigationInventoryUsageMinAggregateInputType
    _max?: IrrigationInventoryUsageMaxAggregateInputType
  }

  export type IrrigationInventoryUsageGroupByOutputType = {
    id: string
    irrigationLogId: string
    inventoryId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt: Date
    _count: IrrigationInventoryUsageCountAggregateOutputType | null
    _avg: IrrigationInventoryUsageAvgAggregateOutputType | null
    _sum: IrrigationInventoryUsageSumAggregateOutputType | null
    _min: IrrigationInventoryUsageMinAggregateOutputType | null
    _max: IrrigationInventoryUsageMaxAggregateOutputType | null
  }

  type GetIrrigationInventoryUsageGroupByPayload<T extends IrrigationInventoryUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationInventoryUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationInventoryUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationInventoryUsageGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationInventoryUsageGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationInventoryUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    irrigationLogId?: boolean
    inventoryId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    createdAt?: boolean
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    ownerUsages?: boolean | IrrigationInventoryUsage$ownerUsagesArgs<ExtArgs>
    _count?: boolean | IrrigationInventoryUsageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationInventoryUsage"]>



  export type IrrigationInventoryUsageSelectScalar = {
    id?: boolean
    irrigationLogId?: boolean
    inventoryId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalCost?: boolean
    createdAt?: boolean
  }

  export type IrrigationInventoryUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "irrigationLogId" | "inventoryId" | "quantity" | "unitPrice" | "totalCost" | "createdAt", ExtArgs["result"]["irrigationInventoryUsage"]>
  export type IrrigationInventoryUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    ownerUsages?: boolean | IrrigationInventoryUsage$ownerUsagesArgs<ExtArgs>
    _count?: boolean | IrrigationInventoryUsageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $IrrigationInventoryUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationInventoryUsage"
    objects: {
      irrigationLog: Prisma.$IrrigationLogPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>
      ownerUsages: Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      irrigationLogId: string
      inventoryId: string
      quantity: number
      unitPrice: number
      totalCost: number
      createdAt: Date
    }, ExtArgs["result"]["irrigationInventoryUsage"]>
    composites: {}
  }

  type IrrigationInventoryUsageGetPayload<S extends boolean | null | undefined | IrrigationInventoryUsageDefaultArgs> = $Result.GetResult<Prisma.$IrrigationInventoryUsagePayload, S>

  type IrrigationInventoryUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationInventoryUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationInventoryUsageCountAggregateInputType | true
    }

  export interface IrrigationInventoryUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationInventoryUsage'], meta: { name: 'IrrigationInventoryUsage' } }
    /**
     * Find zero or one IrrigationInventoryUsage that matches the filter.
     * @param {IrrigationInventoryUsageFindUniqueArgs} args - Arguments to find a IrrigationInventoryUsage
     * @example
     * // Get one IrrigationInventoryUsage
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationInventoryUsageFindUniqueArgs>(args: SelectSubset<T, IrrigationInventoryUsageFindUniqueArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationInventoryUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationInventoryUsageFindUniqueOrThrowArgs} args - Arguments to find a IrrigationInventoryUsage
     * @example
     * // Get one IrrigationInventoryUsage
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationInventoryUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationInventoryUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationInventoryUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageFindFirstArgs} args - Arguments to find a IrrigationInventoryUsage
     * @example
     * // Get one IrrigationInventoryUsage
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationInventoryUsageFindFirstArgs>(args?: SelectSubset<T, IrrigationInventoryUsageFindFirstArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationInventoryUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageFindFirstOrThrowArgs} args - Arguments to find a IrrigationInventoryUsage
     * @example
     * // Get one IrrigationInventoryUsage
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationInventoryUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationInventoryUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationInventoryUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationInventoryUsages
     * const irrigationInventoryUsages = await prisma.irrigationInventoryUsage.findMany()
     * 
     * // Get first 10 IrrigationInventoryUsages
     * const irrigationInventoryUsages = await prisma.irrigationInventoryUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationInventoryUsageWithIdOnly = await prisma.irrigationInventoryUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationInventoryUsageFindManyArgs>(args?: SelectSubset<T, IrrigationInventoryUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationInventoryUsage.
     * @param {IrrigationInventoryUsageCreateArgs} args - Arguments to create a IrrigationInventoryUsage.
     * @example
     * // Create one IrrigationInventoryUsage
     * const IrrigationInventoryUsage = await prisma.irrigationInventoryUsage.create({
     *   data: {
     *     // ... data to create a IrrigationInventoryUsage
     *   }
     * })
     * 
     */
    create<T extends IrrigationInventoryUsageCreateArgs>(args: SelectSubset<T, IrrigationInventoryUsageCreateArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationInventoryUsages.
     * @param {IrrigationInventoryUsageCreateManyArgs} args - Arguments to create many IrrigationInventoryUsages.
     * @example
     * // Create many IrrigationInventoryUsages
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationInventoryUsageCreateManyArgs>(args?: SelectSubset<T, IrrigationInventoryUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IrrigationInventoryUsage.
     * @param {IrrigationInventoryUsageDeleteArgs} args - Arguments to delete one IrrigationInventoryUsage.
     * @example
     * // Delete one IrrigationInventoryUsage
     * const IrrigationInventoryUsage = await prisma.irrigationInventoryUsage.delete({
     *   where: {
     *     // ... filter to delete one IrrigationInventoryUsage
     *   }
     * })
     * 
     */
    delete<T extends IrrigationInventoryUsageDeleteArgs>(args: SelectSubset<T, IrrigationInventoryUsageDeleteArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationInventoryUsage.
     * @param {IrrigationInventoryUsageUpdateArgs} args - Arguments to update one IrrigationInventoryUsage.
     * @example
     * // Update one IrrigationInventoryUsage
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationInventoryUsageUpdateArgs>(args: SelectSubset<T, IrrigationInventoryUsageUpdateArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationInventoryUsages.
     * @param {IrrigationInventoryUsageDeleteManyArgs} args - Arguments to filter IrrigationInventoryUsages to delete.
     * @example
     * // Delete a few IrrigationInventoryUsages
     * const { count } = await prisma.irrigationInventoryUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationInventoryUsageDeleteManyArgs>(args?: SelectSubset<T, IrrigationInventoryUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationInventoryUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationInventoryUsages
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationInventoryUsageUpdateManyArgs>(args: SelectSubset<T, IrrigationInventoryUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IrrigationInventoryUsage.
     * @param {IrrigationInventoryUsageUpsertArgs} args - Arguments to update or create a IrrigationInventoryUsage.
     * @example
     * // Update or create a IrrigationInventoryUsage
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.upsert({
     *   create: {
     *     // ... data to create a IrrigationInventoryUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationInventoryUsage we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationInventoryUsageUpsertArgs>(args: SelectSubset<T, IrrigationInventoryUsageUpsertArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationInventoryUsages that matches the filter.
     * @param {IrrigationInventoryUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IrrigationInventoryUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IrrigationInventoryUsage.
     * @param {IrrigationInventoryUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const irrigationInventoryUsage = await prisma.irrigationInventoryUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IrrigationInventoryUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IrrigationInventoryUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageCountArgs} args - Arguments to filter IrrigationInventoryUsages to count.
     * @example
     * // Count the number of IrrigationInventoryUsages
     * const count = await prisma.irrigationInventoryUsage.count({
     *   where: {
     *     // ... the filter for the IrrigationInventoryUsages we want to count
     *   }
     * })
    **/
    count<T extends IrrigationInventoryUsageCountArgs>(
      args?: Subset<T, IrrigationInventoryUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationInventoryUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationInventoryUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationInventoryUsageAggregateArgs>(args: Subset<T, IrrigationInventoryUsageAggregateArgs>): Prisma.PrismaPromise<GetIrrigationInventoryUsageAggregateType<T>>

    /**
     * Group by IrrigationInventoryUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationInventoryUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationInventoryUsageGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationInventoryUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationInventoryUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationInventoryUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationInventoryUsage model
   */
  readonly fields: IrrigationInventoryUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationInventoryUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationInventoryUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    irrigationLog<T extends IrrigationLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLogDefaultArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ownerUsages<T extends IrrigationInventoryUsage$ownerUsagesArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationInventoryUsage$ownerUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationInventoryUsage model
   */
  interface IrrigationInventoryUsageFieldRefs {
    readonly id: FieldRef<"IrrigationInventoryUsage", 'String'>
    readonly irrigationLogId: FieldRef<"IrrigationInventoryUsage", 'String'>
    readonly inventoryId: FieldRef<"IrrigationInventoryUsage", 'String'>
    readonly quantity: FieldRef<"IrrigationInventoryUsage", 'Float'>
    readonly unitPrice: FieldRef<"IrrigationInventoryUsage", 'Float'>
    readonly totalCost: FieldRef<"IrrigationInventoryUsage", 'Float'>
    readonly createdAt: FieldRef<"IrrigationInventoryUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationInventoryUsage findUnique
   */
  export type IrrigationInventoryUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryUsage to fetch.
     */
    where: IrrigationInventoryUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryUsage findUniqueOrThrow
   */
  export type IrrigationInventoryUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryUsage to fetch.
     */
    where: IrrigationInventoryUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryUsage findFirst
   */
  export type IrrigationInventoryUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryUsage to fetch.
     */
    where?: IrrigationInventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryUsages to fetch.
     */
    orderBy?: IrrigationInventoryUsageOrderByWithRelationInput | IrrigationInventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationInventoryUsages.
     */
    cursor?: IrrigationInventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationInventoryUsages.
     */
    distinct?: IrrigationInventoryUsageScalarFieldEnum | IrrigationInventoryUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryUsage findFirstOrThrow
   */
  export type IrrigationInventoryUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryUsage to fetch.
     */
    where?: IrrigationInventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryUsages to fetch.
     */
    orderBy?: IrrigationInventoryUsageOrderByWithRelationInput | IrrigationInventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationInventoryUsages.
     */
    cursor?: IrrigationInventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationInventoryUsages.
     */
    distinct?: IrrigationInventoryUsageScalarFieldEnum | IrrigationInventoryUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryUsage findMany
   */
  export type IrrigationInventoryUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryUsages to fetch.
     */
    where?: IrrigationInventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryUsages to fetch.
     */
    orderBy?: IrrigationInventoryUsageOrderByWithRelationInput | IrrigationInventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationInventoryUsages.
     */
    cursor?: IrrigationInventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryUsages.
     */
    skip?: number
    distinct?: IrrigationInventoryUsageScalarFieldEnum | IrrigationInventoryUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryUsage create
   */
  export type IrrigationInventoryUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationInventoryUsage.
     */
    data: XOR<IrrigationInventoryUsageCreateInput, IrrigationInventoryUsageUncheckedCreateInput>
  }

  /**
   * IrrigationInventoryUsage createMany
   */
  export type IrrigationInventoryUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationInventoryUsages.
     */
    data: IrrigationInventoryUsageCreateManyInput | IrrigationInventoryUsageCreateManyInput[]
  }

  /**
   * IrrigationInventoryUsage update
   */
  export type IrrigationInventoryUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationInventoryUsage.
     */
    data: XOR<IrrigationInventoryUsageUpdateInput, IrrigationInventoryUsageUncheckedUpdateInput>
    /**
     * Choose, which IrrigationInventoryUsage to update.
     */
    where: IrrigationInventoryUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryUsage updateMany
   */
  export type IrrigationInventoryUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationInventoryUsages.
     */
    data: XOR<IrrigationInventoryUsageUpdateManyMutationInput, IrrigationInventoryUsageUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationInventoryUsages to update
     */
    where?: IrrigationInventoryUsageWhereInput
    /**
     * Limit how many IrrigationInventoryUsages to update.
     */
    limit?: number
  }

  /**
   * IrrigationInventoryUsage upsert
   */
  export type IrrigationInventoryUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationInventoryUsage to update in case it exists.
     */
    where: IrrigationInventoryUsageWhereUniqueInput
    /**
     * In case the IrrigationInventoryUsage found by the `where` argument doesn't exist, create a new IrrigationInventoryUsage with this data.
     */
    create: XOR<IrrigationInventoryUsageCreateInput, IrrigationInventoryUsageUncheckedCreateInput>
    /**
     * In case the IrrigationInventoryUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationInventoryUsageUpdateInput, IrrigationInventoryUsageUncheckedUpdateInput>
  }

  /**
   * IrrigationInventoryUsage delete
   */
  export type IrrigationInventoryUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
    /**
     * Filter which IrrigationInventoryUsage to delete.
     */
    where: IrrigationInventoryUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryUsage deleteMany
   */
  export type IrrigationInventoryUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationInventoryUsages to delete
     */
    where?: IrrigationInventoryUsageWhereInput
    /**
     * Limit how many IrrigationInventoryUsages to delete.
     */
    limit?: number
  }

  /**
   * IrrigationInventoryUsage findRaw
   */
  export type IrrigationInventoryUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationInventoryUsage aggregateRaw
   */
  export type IrrigationInventoryUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationInventoryUsage.ownerUsages
   */
  export type IrrigationInventoryUsage$ownerUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    where?: IrrigationInventoryOwnerUsageWhereInput
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithRelationInput | IrrigationInventoryOwnerUsageOrderByWithRelationInput[]
    cursor?: IrrigationInventoryOwnerUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationInventoryOwnerUsageScalarFieldEnum | IrrigationInventoryOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryUsage without action
   */
  export type IrrigationInventoryUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryUsage
     */
    select?: IrrigationInventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryUsage
     */
    omit?: IrrigationInventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryUsageInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationInventoryOwnerUsage
   */

  export type AggregateIrrigationInventoryOwnerUsage = {
    _count: IrrigationInventoryOwnerUsageCountAggregateOutputType | null
    _avg: IrrigationInventoryOwnerUsageAvgAggregateOutputType | null
    _sum: IrrigationInventoryOwnerUsageSumAggregateOutputType | null
    _min: IrrigationInventoryOwnerUsageMinAggregateOutputType | null
    _max: IrrigationInventoryOwnerUsageMaxAggregateOutputType | null
  }

  export type IrrigationInventoryOwnerUsageAvgAggregateOutputType = {
    percentage: number | null
    quantity: number | null
    cost: number | null
  }

  export type IrrigationInventoryOwnerUsageSumAggregateOutputType = {
    percentage: number | null
    quantity: number | null
    cost: number | null
  }

  export type IrrigationInventoryOwnerUsageMinAggregateOutputType = {
    id: string | null
    irrigationInventoryUsageId: string | null
    ownerId: string | null
    percentage: number | null
    quantity: number | null
    cost: number | null
    createdAt: Date | null
  }

  export type IrrigationInventoryOwnerUsageMaxAggregateOutputType = {
    id: string | null
    irrigationInventoryUsageId: string | null
    ownerId: string | null
    percentage: number | null
    quantity: number | null
    cost: number | null
    createdAt: Date | null
  }

  export type IrrigationInventoryOwnerUsageCountAggregateOutputType = {
    id: number
    irrigationInventoryUsageId: number
    ownerId: number
    percentage: number
    quantity: number
    cost: number
    createdAt: number
    _all: number
  }


  export type IrrigationInventoryOwnerUsageAvgAggregateInputType = {
    percentage?: true
    quantity?: true
    cost?: true
  }

  export type IrrigationInventoryOwnerUsageSumAggregateInputType = {
    percentage?: true
    quantity?: true
    cost?: true
  }

  export type IrrigationInventoryOwnerUsageMinAggregateInputType = {
    id?: true
    irrigationInventoryUsageId?: true
    ownerId?: true
    percentage?: true
    quantity?: true
    cost?: true
    createdAt?: true
  }

  export type IrrigationInventoryOwnerUsageMaxAggregateInputType = {
    id?: true
    irrigationInventoryUsageId?: true
    ownerId?: true
    percentage?: true
    quantity?: true
    cost?: true
    createdAt?: true
  }

  export type IrrigationInventoryOwnerUsageCountAggregateInputType = {
    id?: true
    irrigationInventoryUsageId?: true
    ownerId?: true
    percentage?: true
    quantity?: true
    cost?: true
    createdAt?: true
    _all?: true
  }

  export type IrrigationInventoryOwnerUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationInventoryOwnerUsage to aggregate.
     */
    where?: IrrigationInventoryOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryOwnerUsages to fetch.
     */
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithRelationInput | IrrigationInventoryOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationInventoryOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryOwnerUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationInventoryOwnerUsages
    **/
    _count?: true | IrrigationInventoryOwnerUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationInventoryOwnerUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationInventoryOwnerUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationInventoryOwnerUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationInventoryOwnerUsageMaxAggregateInputType
  }

  export type GetIrrigationInventoryOwnerUsageAggregateType<T extends IrrigationInventoryOwnerUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationInventoryOwnerUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationInventoryOwnerUsage[P]>
      : GetScalarType<T[P], AggregateIrrigationInventoryOwnerUsage[P]>
  }




  export type IrrigationInventoryOwnerUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationInventoryOwnerUsageWhereInput
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithAggregationInput | IrrigationInventoryOwnerUsageOrderByWithAggregationInput[]
    by: IrrigationInventoryOwnerUsageScalarFieldEnum[] | IrrigationInventoryOwnerUsageScalarFieldEnum
    having?: IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationInventoryOwnerUsageCountAggregateInputType | true
    _avg?: IrrigationInventoryOwnerUsageAvgAggregateInputType
    _sum?: IrrigationInventoryOwnerUsageSumAggregateInputType
    _min?: IrrigationInventoryOwnerUsageMinAggregateInputType
    _max?: IrrigationInventoryOwnerUsageMaxAggregateInputType
  }

  export type IrrigationInventoryOwnerUsageGroupByOutputType = {
    id: string
    irrigationInventoryUsageId: string
    ownerId: string
    percentage: number
    quantity: number
    cost: number
    createdAt: Date
    _count: IrrigationInventoryOwnerUsageCountAggregateOutputType | null
    _avg: IrrigationInventoryOwnerUsageAvgAggregateOutputType | null
    _sum: IrrigationInventoryOwnerUsageSumAggregateOutputType | null
    _min: IrrigationInventoryOwnerUsageMinAggregateOutputType | null
    _max: IrrigationInventoryOwnerUsageMaxAggregateOutputType | null
  }

  type GetIrrigationInventoryOwnerUsageGroupByPayload<T extends IrrigationInventoryOwnerUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationInventoryOwnerUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationInventoryOwnerUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationInventoryOwnerUsageGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationInventoryOwnerUsageGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationInventoryOwnerUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    irrigationInventoryUsageId?: boolean
    ownerId?: boolean
    percentage?: boolean
    quantity?: boolean
    cost?: boolean
    createdAt?: boolean
    irrigationInventoryUsage?: boolean | IrrigationInventoryUsageDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationInventoryOwnerUsage"]>



  export type IrrigationInventoryOwnerUsageSelectScalar = {
    id?: boolean
    irrigationInventoryUsageId?: boolean
    ownerId?: boolean
    percentage?: boolean
    quantity?: boolean
    cost?: boolean
    createdAt?: boolean
  }

  export type IrrigationInventoryOwnerUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "irrigationInventoryUsageId" | "ownerId" | "percentage" | "quantity" | "cost" | "createdAt", ExtArgs["result"]["irrigationInventoryOwnerUsage"]>
  export type IrrigationInventoryOwnerUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    irrigationInventoryUsage?: boolean | IrrigationInventoryUsageDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IrrigationInventoryOwnerUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationInventoryOwnerUsage"
    objects: {
      irrigationInventoryUsage: Prisma.$IrrigationInventoryUsagePayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      irrigationInventoryUsageId: string
      ownerId: string
      percentage: number
      quantity: number
      cost: number
      createdAt: Date
    }, ExtArgs["result"]["irrigationInventoryOwnerUsage"]>
    composites: {}
  }

  type IrrigationInventoryOwnerUsageGetPayload<S extends boolean | null | undefined | IrrigationInventoryOwnerUsageDefaultArgs> = $Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload, S>

  type IrrigationInventoryOwnerUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationInventoryOwnerUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationInventoryOwnerUsageCountAggregateInputType | true
    }

  export interface IrrigationInventoryOwnerUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationInventoryOwnerUsage'], meta: { name: 'IrrigationInventoryOwnerUsage' } }
    /**
     * Find zero or one IrrigationInventoryOwnerUsage that matches the filter.
     * @param {IrrigationInventoryOwnerUsageFindUniqueArgs} args - Arguments to find a IrrigationInventoryOwnerUsage
     * @example
     * // Get one IrrigationInventoryOwnerUsage
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationInventoryOwnerUsageFindUniqueArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageFindUniqueArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationInventoryOwnerUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationInventoryOwnerUsageFindUniqueOrThrowArgs} args - Arguments to find a IrrigationInventoryOwnerUsage
     * @example
     * // Get one IrrigationInventoryOwnerUsage
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationInventoryOwnerUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationInventoryOwnerUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageFindFirstArgs} args - Arguments to find a IrrigationInventoryOwnerUsage
     * @example
     * // Get one IrrigationInventoryOwnerUsage
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationInventoryOwnerUsageFindFirstArgs>(args?: SelectSubset<T, IrrigationInventoryOwnerUsageFindFirstArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationInventoryOwnerUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageFindFirstOrThrowArgs} args - Arguments to find a IrrigationInventoryOwnerUsage
     * @example
     * // Get one IrrigationInventoryOwnerUsage
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationInventoryOwnerUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationInventoryOwnerUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationInventoryOwnerUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationInventoryOwnerUsages
     * const irrigationInventoryOwnerUsages = await prisma.irrigationInventoryOwnerUsage.findMany()
     * 
     * // Get first 10 IrrigationInventoryOwnerUsages
     * const irrigationInventoryOwnerUsages = await prisma.irrigationInventoryOwnerUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationInventoryOwnerUsageWithIdOnly = await prisma.irrigationInventoryOwnerUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationInventoryOwnerUsageFindManyArgs>(args?: SelectSubset<T, IrrigationInventoryOwnerUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationInventoryOwnerUsage.
     * @param {IrrigationInventoryOwnerUsageCreateArgs} args - Arguments to create a IrrigationInventoryOwnerUsage.
     * @example
     * // Create one IrrigationInventoryOwnerUsage
     * const IrrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.create({
     *   data: {
     *     // ... data to create a IrrigationInventoryOwnerUsage
     *   }
     * })
     * 
     */
    create<T extends IrrigationInventoryOwnerUsageCreateArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageCreateArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationInventoryOwnerUsages.
     * @param {IrrigationInventoryOwnerUsageCreateManyArgs} args - Arguments to create many IrrigationInventoryOwnerUsages.
     * @example
     * // Create many IrrigationInventoryOwnerUsages
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationInventoryOwnerUsageCreateManyArgs>(args?: SelectSubset<T, IrrigationInventoryOwnerUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IrrigationInventoryOwnerUsage.
     * @param {IrrigationInventoryOwnerUsageDeleteArgs} args - Arguments to delete one IrrigationInventoryOwnerUsage.
     * @example
     * // Delete one IrrigationInventoryOwnerUsage
     * const IrrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.delete({
     *   where: {
     *     // ... filter to delete one IrrigationInventoryOwnerUsage
     *   }
     * })
     * 
     */
    delete<T extends IrrigationInventoryOwnerUsageDeleteArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageDeleteArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationInventoryOwnerUsage.
     * @param {IrrigationInventoryOwnerUsageUpdateArgs} args - Arguments to update one IrrigationInventoryOwnerUsage.
     * @example
     * // Update one IrrigationInventoryOwnerUsage
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationInventoryOwnerUsageUpdateArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageUpdateArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationInventoryOwnerUsages.
     * @param {IrrigationInventoryOwnerUsageDeleteManyArgs} args - Arguments to filter IrrigationInventoryOwnerUsages to delete.
     * @example
     * // Delete a few IrrigationInventoryOwnerUsages
     * const { count } = await prisma.irrigationInventoryOwnerUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationInventoryOwnerUsageDeleteManyArgs>(args?: SelectSubset<T, IrrigationInventoryOwnerUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationInventoryOwnerUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationInventoryOwnerUsages
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationInventoryOwnerUsageUpdateManyArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IrrigationInventoryOwnerUsage.
     * @param {IrrigationInventoryOwnerUsageUpsertArgs} args - Arguments to update or create a IrrigationInventoryOwnerUsage.
     * @example
     * // Update or create a IrrigationInventoryOwnerUsage
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.upsert({
     *   create: {
     *     // ... data to create a IrrigationInventoryOwnerUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationInventoryOwnerUsage we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationInventoryOwnerUsageUpsertArgs>(args: SelectSubset<T, IrrigationInventoryOwnerUsageUpsertArgs<ExtArgs>>): Prisma__IrrigationInventoryOwnerUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryOwnerUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationInventoryOwnerUsages that matches the filter.
     * @param {IrrigationInventoryOwnerUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: IrrigationInventoryOwnerUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a IrrigationInventoryOwnerUsage.
     * @param {IrrigationInventoryOwnerUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const irrigationInventoryOwnerUsage = await prisma.irrigationInventoryOwnerUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: IrrigationInventoryOwnerUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of IrrigationInventoryOwnerUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageCountArgs} args - Arguments to filter IrrigationInventoryOwnerUsages to count.
     * @example
     * // Count the number of IrrigationInventoryOwnerUsages
     * const count = await prisma.irrigationInventoryOwnerUsage.count({
     *   where: {
     *     // ... the filter for the IrrigationInventoryOwnerUsages we want to count
     *   }
     * })
    **/
    count<T extends IrrigationInventoryOwnerUsageCountArgs>(
      args?: Subset<T, IrrigationInventoryOwnerUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationInventoryOwnerUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationInventoryOwnerUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationInventoryOwnerUsageAggregateArgs>(args: Subset<T, IrrigationInventoryOwnerUsageAggregateArgs>): Prisma.PrismaPromise<GetIrrigationInventoryOwnerUsageAggregateType<T>>

    /**
     * Group by IrrigationInventoryOwnerUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationInventoryOwnerUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationInventoryOwnerUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationInventoryOwnerUsageGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationInventoryOwnerUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationInventoryOwnerUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationInventoryOwnerUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationInventoryOwnerUsage model
   */
  readonly fields: IrrigationInventoryOwnerUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationInventoryOwnerUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationInventoryOwnerUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    irrigationInventoryUsage<T extends IrrigationInventoryUsageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationInventoryUsageDefaultArgs<ExtArgs>>): Prisma__IrrigationInventoryUsageClient<$Result.GetResult<Prisma.$IrrigationInventoryUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationInventoryOwnerUsage model
   */
  interface IrrigationInventoryOwnerUsageFieldRefs {
    readonly id: FieldRef<"IrrigationInventoryOwnerUsage", 'String'>
    readonly irrigationInventoryUsageId: FieldRef<"IrrigationInventoryOwnerUsage", 'String'>
    readonly ownerId: FieldRef<"IrrigationInventoryOwnerUsage", 'String'>
    readonly percentage: FieldRef<"IrrigationInventoryOwnerUsage", 'Float'>
    readonly quantity: FieldRef<"IrrigationInventoryOwnerUsage", 'Float'>
    readonly cost: FieldRef<"IrrigationInventoryOwnerUsage", 'Float'>
    readonly createdAt: FieldRef<"IrrigationInventoryOwnerUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationInventoryOwnerUsage findUnique
   */
  export type IrrigationInventoryOwnerUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryOwnerUsage to fetch.
     */
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryOwnerUsage findUniqueOrThrow
   */
  export type IrrigationInventoryOwnerUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryOwnerUsage to fetch.
     */
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryOwnerUsage findFirst
   */
  export type IrrigationInventoryOwnerUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryOwnerUsage to fetch.
     */
    where?: IrrigationInventoryOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryOwnerUsages to fetch.
     */
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithRelationInput | IrrigationInventoryOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationInventoryOwnerUsages.
     */
    cursor?: IrrigationInventoryOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryOwnerUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationInventoryOwnerUsages.
     */
    distinct?: IrrigationInventoryOwnerUsageScalarFieldEnum | IrrigationInventoryOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryOwnerUsage findFirstOrThrow
   */
  export type IrrigationInventoryOwnerUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryOwnerUsage to fetch.
     */
    where?: IrrigationInventoryOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryOwnerUsages to fetch.
     */
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithRelationInput | IrrigationInventoryOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationInventoryOwnerUsages.
     */
    cursor?: IrrigationInventoryOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryOwnerUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationInventoryOwnerUsages.
     */
    distinct?: IrrigationInventoryOwnerUsageScalarFieldEnum | IrrigationInventoryOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryOwnerUsage findMany
   */
  export type IrrigationInventoryOwnerUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationInventoryOwnerUsages to fetch.
     */
    where?: IrrigationInventoryOwnerUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationInventoryOwnerUsages to fetch.
     */
    orderBy?: IrrigationInventoryOwnerUsageOrderByWithRelationInput | IrrigationInventoryOwnerUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationInventoryOwnerUsages.
     */
    cursor?: IrrigationInventoryOwnerUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationInventoryOwnerUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationInventoryOwnerUsages.
     */
    skip?: number
    distinct?: IrrigationInventoryOwnerUsageScalarFieldEnum | IrrigationInventoryOwnerUsageScalarFieldEnum[]
  }

  /**
   * IrrigationInventoryOwnerUsage create
   */
  export type IrrigationInventoryOwnerUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationInventoryOwnerUsage.
     */
    data: XOR<IrrigationInventoryOwnerUsageCreateInput, IrrigationInventoryOwnerUsageUncheckedCreateInput>
  }

  /**
   * IrrigationInventoryOwnerUsage createMany
   */
  export type IrrigationInventoryOwnerUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationInventoryOwnerUsages.
     */
    data: IrrigationInventoryOwnerUsageCreateManyInput | IrrigationInventoryOwnerUsageCreateManyInput[]
  }

  /**
   * IrrigationInventoryOwnerUsage update
   */
  export type IrrigationInventoryOwnerUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationInventoryOwnerUsage.
     */
    data: XOR<IrrigationInventoryOwnerUsageUpdateInput, IrrigationInventoryOwnerUsageUncheckedUpdateInput>
    /**
     * Choose, which IrrigationInventoryOwnerUsage to update.
     */
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryOwnerUsage updateMany
   */
  export type IrrigationInventoryOwnerUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationInventoryOwnerUsages.
     */
    data: XOR<IrrigationInventoryOwnerUsageUpdateManyMutationInput, IrrigationInventoryOwnerUsageUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationInventoryOwnerUsages to update
     */
    where?: IrrigationInventoryOwnerUsageWhereInput
    /**
     * Limit how many IrrigationInventoryOwnerUsages to update.
     */
    limit?: number
  }

  /**
   * IrrigationInventoryOwnerUsage upsert
   */
  export type IrrigationInventoryOwnerUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationInventoryOwnerUsage to update in case it exists.
     */
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    /**
     * In case the IrrigationInventoryOwnerUsage found by the `where` argument doesn't exist, create a new IrrigationInventoryOwnerUsage with this data.
     */
    create: XOR<IrrigationInventoryOwnerUsageCreateInput, IrrigationInventoryOwnerUsageUncheckedCreateInput>
    /**
     * In case the IrrigationInventoryOwnerUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationInventoryOwnerUsageUpdateInput, IrrigationInventoryOwnerUsageUncheckedUpdateInput>
  }

  /**
   * IrrigationInventoryOwnerUsage delete
   */
  export type IrrigationInventoryOwnerUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
    /**
     * Filter which IrrigationInventoryOwnerUsage to delete.
     */
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
  }

  /**
   * IrrigationInventoryOwnerUsage deleteMany
   */
  export type IrrigationInventoryOwnerUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationInventoryOwnerUsages to delete
     */
    where?: IrrigationInventoryOwnerUsageWhereInput
    /**
     * Limit how many IrrigationInventoryOwnerUsages to delete.
     */
    limit?: number
  }

  /**
   * IrrigationInventoryOwnerUsage findRaw
   */
  export type IrrigationInventoryOwnerUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationInventoryOwnerUsage aggregateRaw
   */
  export type IrrigationInventoryOwnerUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * IrrigationInventoryOwnerUsage without action
   */
  export type IrrigationInventoryOwnerUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationInventoryOwnerUsage
     */
    select?: IrrigationInventoryOwnerUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationInventoryOwnerUsage
     */
    omit?: IrrigationInventoryOwnerUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationInventoryOwnerUsageInclude<ExtArgs> | null
  }


  /**
   * Model WellBillingPeriod
   */

  export type AggregateWellBillingPeriod = {
    _count: WellBillingPeriodCountAggregateOutputType | null
    _avg: WellBillingPeriodAvgAggregateOutputType | null
    _sum: WellBillingPeriodSumAggregateOutputType | null
    _min: WellBillingPeriodMinAggregateOutputType | null
    _max: WellBillingPeriodMaxAggregateOutputType | null
  }

  export type WellBillingPeriodAvgAggregateOutputType = {
    totalAmount: number | null
    totalUsage: number | null
  }

  export type WellBillingPeriodSumAggregateOutputType = {
    totalAmount: number | null
    totalUsage: number | null
  }

  export type WellBillingPeriodMinAggregateOutputType = {
    id: string | null
    wellId: string | null
    startDate: Date | null
    endDate: Date | null
    totalAmount: number | null
    totalUsage: number | null
    status: string | null
    createdAt: Date | null
  }

  export type WellBillingPeriodMaxAggregateOutputType = {
    id: string | null
    wellId: string | null
    startDate: Date | null
    endDate: Date | null
    totalAmount: number | null
    totalUsage: number | null
    status: string | null
    createdAt: Date | null
  }

  export type WellBillingPeriodCountAggregateOutputType = {
    id: number
    wellId: number
    startDate: number
    endDate: number
    totalAmount: number
    totalUsage: number
    status: number
    createdAt: number
    _all: number
  }


  export type WellBillingPeriodAvgAggregateInputType = {
    totalAmount?: true
    totalUsage?: true
  }

  export type WellBillingPeriodSumAggregateInputType = {
    totalAmount?: true
    totalUsage?: true
  }

  export type WellBillingPeriodMinAggregateInputType = {
    id?: true
    wellId?: true
    startDate?: true
    endDate?: true
    totalAmount?: true
    totalUsage?: true
    status?: true
    createdAt?: true
  }

  export type WellBillingPeriodMaxAggregateInputType = {
    id?: true
    wellId?: true
    startDate?: true
    endDate?: true
    totalAmount?: true
    totalUsage?: true
    status?: true
    createdAt?: true
  }

  export type WellBillingPeriodCountAggregateInputType = {
    id?: true
    wellId?: true
    startDate?: true
    endDate?: true
    totalAmount?: true
    totalUsage?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type WellBillingPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBillingPeriod to aggregate.
     */
    where?: WellBillingPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingPeriods to fetch.
     */
    orderBy?: WellBillingPeriodOrderByWithRelationInput | WellBillingPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellBillingPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellBillingPeriods
    **/
    _count?: true | WellBillingPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellBillingPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellBillingPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellBillingPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellBillingPeriodMaxAggregateInputType
  }

  export type GetWellBillingPeriodAggregateType<T extends WellBillingPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateWellBillingPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellBillingPeriod[P]>
      : GetScalarType<T[P], AggregateWellBillingPeriod[P]>
  }




  export type WellBillingPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillingPeriodWhereInput
    orderBy?: WellBillingPeriodOrderByWithAggregationInput | WellBillingPeriodOrderByWithAggregationInput[]
    by: WellBillingPeriodScalarFieldEnum[] | WellBillingPeriodScalarFieldEnum
    having?: WellBillingPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellBillingPeriodCountAggregateInputType | true
    _avg?: WellBillingPeriodAvgAggregateInputType
    _sum?: WellBillingPeriodSumAggregateInputType
    _min?: WellBillingPeriodMinAggregateInputType
    _max?: WellBillingPeriodMaxAggregateInputType
  }

  export type WellBillingPeriodGroupByOutputType = {
    id: string
    wellId: string
    startDate: Date
    endDate: Date
    totalAmount: number
    totalUsage: number | null
    status: string
    createdAt: Date
    _count: WellBillingPeriodCountAggregateOutputType | null
    _avg: WellBillingPeriodAvgAggregateOutputType | null
    _sum: WellBillingPeriodSumAggregateOutputType | null
    _min: WellBillingPeriodMinAggregateOutputType | null
    _max: WellBillingPeriodMaxAggregateOutputType | null
  }

  type GetWellBillingPeriodGroupByPayload<T extends WellBillingPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellBillingPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellBillingPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellBillingPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], WellBillingPeriodGroupByOutputType[P]>
        }
      >
    >


  export type WellBillingPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wellId?: boolean
    startDate?: boolean
    endDate?: boolean
    totalAmount?: boolean
    totalUsage?: boolean
    status?: boolean
    createdAt?: boolean
    well?: boolean | WellDefaultArgs<ExtArgs>
    irrigationUsages?: boolean | WellBillingPeriod$irrigationUsagesArgs<ExtArgs>
    distributions?: boolean | WellBillingPeriod$distributionsArgs<ExtArgs>
    _count?: boolean | WellBillingPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellBillingPeriod"]>



  export type WellBillingPeriodSelectScalar = {
    id?: boolean
    wellId?: boolean
    startDate?: boolean
    endDate?: boolean
    totalAmount?: boolean
    totalUsage?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type WellBillingPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wellId" | "startDate" | "endDate" | "totalAmount" | "totalUsage" | "status" | "createdAt", ExtArgs["result"]["wellBillingPeriod"]>
  export type WellBillingPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    well?: boolean | WellDefaultArgs<ExtArgs>
    irrigationUsages?: boolean | WellBillingPeriod$irrigationUsagesArgs<ExtArgs>
    distributions?: boolean | WellBillingPeriod$distributionsArgs<ExtArgs>
    _count?: boolean | WellBillingPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WellBillingPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellBillingPeriod"
    objects: {
      well: Prisma.$WellPayload<ExtArgs>
      irrigationUsages: Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>[]
      distributions: Prisma.$WellBillDistributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wellId: string
      startDate: Date
      endDate: Date
      totalAmount: number
      totalUsage: number | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["wellBillingPeriod"]>
    composites: {}
  }

  type WellBillingPeriodGetPayload<S extends boolean | null | undefined | WellBillingPeriodDefaultArgs> = $Result.GetResult<Prisma.$WellBillingPeriodPayload, S>

  type WellBillingPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellBillingPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellBillingPeriodCountAggregateInputType | true
    }

  export interface WellBillingPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellBillingPeriod'], meta: { name: 'WellBillingPeriod' } }
    /**
     * Find zero or one WellBillingPeriod that matches the filter.
     * @param {WellBillingPeriodFindUniqueArgs} args - Arguments to find a WellBillingPeriod
     * @example
     * // Get one WellBillingPeriod
     * const wellBillingPeriod = await prisma.wellBillingPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellBillingPeriodFindUniqueArgs>(args: SelectSubset<T, WellBillingPeriodFindUniqueArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellBillingPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellBillingPeriodFindUniqueOrThrowArgs} args - Arguments to find a WellBillingPeriod
     * @example
     * // Get one WellBillingPeriod
     * const wellBillingPeriod = await prisma.wellBillingPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellBillingPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, WellBillingPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBillingPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodFindFirstArgs} args - Arguments to find a WellBillingPeriod
     * @example
     * // Get one WellBillingPeriod
     * const wellBillingPeriod = await prisma.wellBillingPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellBillingPeriodFindFirstArgs>(args?: SelectSubset<T, WellBillingPeriodFindFirstArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBillingPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodFindFirstOrThrowArgs} args - Arguments to find a WellBillingPeriod
     * @example
     * // Get one WellBillingPeriod
     * const wellBillingPeriod = await prisma.wellBillingPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellBillingPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, WellBillingPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBillingPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellBillingPeriods
     * const wellBillingPeriods = await prisma.wellBillingPeriod.findMany()
     * 
     * // Get first 10 WellBillingPeriods
     * const wellBillingPeriods = await prisma.wellBillingPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellBillingPeriodWithIdOnly = await prisma.wellBillingPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellBillingPeriodFindManyArgs>(args?: SelectSubset<T, WellBillingPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellBillingPeriod.
     * @param {WellBillingPeriodCreateArgs} args - Arguments to create a WellBillingPeriod.
     * @example
     * // Create one WellBillingPeriod
     * const WellBillingPeriod = await prisma.wellBillingPeriod.create({
     *   data: {
     *     // ... data to create a WellBillingPeriod
     *   }
     * })
     * 
     */
    create<T extends WellBillingPeriodCreateArgs>(args: SelectSubset<T, WellBillingPeriodCreateArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellBillingPeriods.
     * @param {WellBillingPeriodCreateManyArgs} args - Arguments to create many WellBillingPeriods.
     * @example
     * // Create many WellBillingPeriods
     * const wellBillingPeriod = await prisma.wellBillingPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellBillingPeriodCreateManyArgs>(args?: SelectSubset<T, WellBillingPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WellBillingPeriod.
     * @param {WellBillingPeriodDeleteArgs} args - Arguments to delete one WellBillingPeriod.
     * @example
     * // Delete one WellBillingPeriod
     * const WellBillingPeriod = await prisma.wellBillingPeriod.delete({
     *   where: {
     *     // ... filter to delete one WellBillingPeriod
     *   }
     * })
     * 
     */
    delete<T extends WellBillingPeriodDeleteArgs>(args: SelectSubset<T, WellBillingPeriodDeleteArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellBillingPeriod.
     * @param {WellBillingPeriodUpdateArgs} args - Arguments to update one WellBillingPeriod.
     * @example
     * // Update one WellBillingPeriod
     * const wellBillingPeriod = await prisma.wellBillingPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellBillingPeriodUpdateArgs>(args: SelectSubset<T, WellBillingPeriodUpdateArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellBillingPeriods.
     * @param {WellBillingPeriodDeleteManyArgs} args - Arguments to filter WellBillingPeriods to delete.
     * @example
     * // Delete a few WellBillingPeriods
     * const { count } = await prisma.wellBillingPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellBillingPeriodDeleteManyArgs>(args?: SelectSubset<T, WellBillingPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellBillingPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellBillingPeriods
     * const wellBillingPeriod = await prisma.wellBillingPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellBillingPeriodUpdateManyArgs>(args: SelectSubset<T, WellBillingPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WellBillingPeriod.
     * @param {WellBillingPeriodUpsertArgs} args - Arguments to update or create a WellBillingPeriod.
     * @example
     * // Update or create a WellBillingPeriod
     * const wellBillingPeriod = await prisma.wellBillingPeriod.upsert({
     *   create: {
     *     // ... data to create a WellBillingPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellBillingPeriod we want to update
     *   }
     * })
     */
    upsert<T extends WellBillingPeriodUpsertArgs>(args: SelectSubset<T, WellBillingPeriodUpsertArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBillingPeriods that matches the filter.
     * @param {WellBillingPeriodFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const wellBillingPeriod = await prisma.wellBillingPeriod.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WellBillingPeriodFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WellBillingPeriod.
     * @param {WellBillingPeriodAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const wellBillingPeriod = await prisma.wellBillingPeriod.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WellBillingPeriodAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WellBillingPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodCountArgs} args - Arguments to filter WellBillingPeriods to count.
     * @example
     * // Count the number of WellBillingPeriods
     * const count = await prisma.wellBillingPeriod.count({
     *   where: {
     *     // ... the filter for the WellBillingPeriods we want to count
     *   }
     * })
    **/
    count<T extends WellBillingPeriodCountArgs>(
      args?: Subset<T, WellBillingPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellBillingPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellBillingPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellBillingPeriodAggregateArgs>(args: Subset<T, WellBillingPeriodAggregateArgs>): Prisma.PrismaPromise<GetWellBillingPeriodAggregateType<T>>

    /**
     * Group by WellBillingPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellBillingPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellBillingPeriodGroupByArgs['orderBy'] }
        : { orderBy?: WellBillingPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellBillingPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellBillingPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellBillingPeriod model
   */
  readonly fields: WellBillingPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellBillingPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellBillingPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    well<T extends WellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellDefaultArgs<ExtArgs>>): Prisma__WellClient<$Result.GetResult<Prisma.$WellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    irrigationUsages<T extends WellBillingPeriod$irrigationUsagesArgs<ExtArgs> = {}>(args?: Subset<T, WellBillingPeriod$irrigationUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    distributions<T extends WellBillingPeriod$distributionsArgs<ExtArgs> = {}>(args?: Subset<T, WellBillingPeriod$distributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellBillingPeriod model
   */
  interface WellBillingPeriodFieldRefs {
    readonly id: FieldRef<"WellBillingPeriod", 'String'>
    readonly wellId: FieldRef<"WellBillingPeriod", 'String'>
    readonly startDate: FieldRef<"WellBillingPeriod", 'DateTime'>
    readonly endDate: FieldRef<"WellBillingPeriod", 'DateTime'>
    readonly totalAmount: FieldRef<"WellBillingPeriod", 'Float'>
    readonly totalUsage: FieldRef<"WellBillingPeriod", 'Float'>
    readonly status: FieldRef<"WellBillingPeriod", 'String'>
    readonly createdAt: FieldRef<"WellBillingPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellBillingPeriod findUnique
   */
  export type WellBillingPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingPeriod to fetch.
     */
    where: WellBillingPeriodWhereUniqueInput
  }

  /**
   * WellBillingPeriod findUniqueOrThrow
   */
  export type WellBillingPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingPeriod to fetch.
     */
    where: WellBillingPeriodWhereUniqueInput
  }

  /**
   * WellBillingPeriod findFirst
   */
  export type WellBillingPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingPeriod to fetch.
     */
    where?: WellBillingPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingPeriods to fetch.
     */
    orderBy?: WellBillingPeriodOrderByWithRelationInput | WellBillingPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBillingPeriods.
     */
    cursor?: WellBillingPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBillingPeriods.
     */
    distinct?: WellBillingPeriodScalarFieldEnum | WellBillingPeriodScalarFieldEnum[]
  }

  /**
   * WellBillingPeriod findFirstOrThrow
   */
  export type WellBillingPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingPeriod to fetch.
     */
    where?: WellBillingPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingPeriods to fetch.
     */
    orderBy?: WellBillingPeriodOrderByWithRelationInput | WellBillingPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBillingPeriods.
     */
    cursor?: WellBillingPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBillingPeriods.
     */
    distinct?: WellBillingPeriodScalarFieldEnum | WellBillingPeriodScalarFieldEnum[]
  }

  /**
   * WellBillingPeriod findMany
   */
  export type WellBillingPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingPeriods to fetch.
     */
    where?: WellBillingPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingPeriods to fetch.
     */
    orderBy?: WellBillingPeriodOrderByWithRelationInput | WellBillingPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellBillingPeriods.
     */
    cursor?: WellBillingPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingPeriods.
     */
    skip?: number
    distinct?: WellBillingPeriodScalarFieldEnum | WellBillingPeriodScalarFieldEnum[]
  }

  /**
   * WellBillingPeriod create
   */
  export type WellBillingPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a WellBillingPeriod.
     */
    data: XOR<WellBillingPeriodCreateInput, WellBillingPeriodUncheckedCreateInput>
  }

  /**
   * WellBillingPeriod createMany
   */
  export type WellBillingPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellBillingPeriods.
     */
    data: WellBillingPeriodCreateManyInput | WellBillingPeriodCreateManyInput[]
  }

  /**
   * WellBillingPeriod update
   */
  export type WellBillingPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a WellBillingPeriod.
     */
    data: XOR<WellBillingPeriodUpdateInput, WellBillingPeriodUncheckedUpdateInput>
    /**
     * Choose, which WellBillingPeriod to update.
     */
    where: WellBillingPeriodWhereUniqueInput
  }

  /**
   * WellBillingPeriod updateMany
   */
  export type WellBillingPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellBillingPeriods.
     */
    data: XOR<WellBillingPeriodUpdateManyMutationInput, WellBillingPeriodUncheckedUpdateManyInput>
    /**
     * Filter which WellBillingPeriods to update
     */
    where?: WellBillingPeriodWhereInput
    /**
     * Limit how many WellBillingPeriods to update.
     */
    limit?: number
  }

  /**
   * WellBillingPeriod upsert
   */
  export type WellBillingPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the WellBillingPeriod to update in case it exists.
     */
    where: WellBillingPeriodWhereUniqueInput
    /**
     * In case the WellBillingPeriod found by the `where` argument doesn't exist, create a new WellBillingPeriod with this data.
     */
    create: XOR<WellBillingPeriodCreateInput, WellBillingPeriodUncheckedCreateInput>
    /**
     * In case the WellBillingPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellBillingPeriodUpdateInput, WellBillingPeriodUncheckedUpdateInput>
  }

  /**
   * WellBillingPeriod delete
   */
  export type WellBillingPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
    /**
     * Filter which WellBillingPeriod to delete.
     */
    where: WellBillingPeriodWhereUniqueInput
  }

  /**
   * WellBillingPeriod deleteMany
   */
  export type WellBillingPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBillingPeriods to delete
     */
    where?: WellBillingPeriodWhereInput
    /**
     * Limit how many WellBillingPeriods to delete.
     */
    limit?: number
  }

  /**
   * WellBillingPeriod findRaw
   */
  export type WellBillingPeriodFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WellBillingPeriod aggregateRaw
   */
  export type WellBillingPeriodAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WellBillingPeriod.irrigationUsages
   */
  export type WellBillingPeriod$irrigationUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    where?: WellBillingIrrigationUsageWhereInput
    orderBy?: WellBillingIrrigationUsageOrderByWithRelationInput | WellBillingIrrigationUsageOrderByWithRelationInput[]
    cursor?: WellBillingIrrigationUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillingIrrigationUsageScalarFieldEnum | WellBillingIrrigationUsageScalarFieldEnum[]
  }

  /**
   * WellBillingPeriod.distributions
   */
  export type WellBillingPeriod$distributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    where?: WellBillDistributionWhereInput
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    cursor?: WellBillDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * WellBillingPeriod without action
   */
  export type WellBillingPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingPeriod
     */
    select?: WellBillingPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingPeriod
     */
    omit?: WellBillingPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingPeriodInclude<ExtArgs> | null
  }


  /**
   * Model WellBillingIrrigationUsage
   */

  export type AggregateWellBillingIrrigationUsage = {
    _count: WellBillingIrrigationUsageCountAggregateOutputType | null
    _avg: WellBillingIrrigationUsageAvgAggregateOutputType | null
    _sum: WellBillingIrrigationUsageSumAggregateOutputType | null
    _min: WellBillingIrrigationUsageMinAggregateOutputType | null
    _max: WellBillingIrrigationUsageMaxAggregateOutputType | null
  }

  export type WellBillingIrrigationUsageAvgAggregateOutputType = {
    duration: number | null
    percentage: number | null
    amount: number | null
  }

  export type WellBillingIrrigationUsageSumAggregateOutputType = {
    duration: number | null
    percentage: number | null
    amount: number | null
  }

  export type WellBillingIrrigationUsageMinAggregateOutputType = {
    id: string | null
    wellBillingPeriodId: string | null
    irrigationLogId: string | null
    duration: number | null
    percentage: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type WellBillingIrrigationUsageMaxAggregateOutputType = {
    id: string | null
    wellBillingPeriodId: string | null
    irrigationLogId: string | null
    duration: number | null
    percentage: number | null
    amount: number | null
    createdAt: Date | null
  }

  export type WellBillingIrrigationUsageCountAggregateOutputType = {
    id: number
    wellBillingPeriodId: number
    irrigationLogId: number
    duration: number
    percentage: number
    amount: number
    createdAt: number
    _all: number
  }


  export type WellBillingIrrigationUsageAvgAggregateInputType = {
    duration?: true
    percentage?: true
    amount?: true
  }

  export type WellBillingIrrigationUsageSumAggregateInputType = {
    duration?: true
    percentage?: true
    amount?: true
  }

  export type WellBillingIrrigationUsageMinAggregateInputType = {
    id?: true
    wellBillingPeriodId?: true
    irrigationLogId?: true
    duration?: true
    percentage?: true
    amount?: true
    createdAt?: true
  }

  export type WellBillingIrrigationUsageMaxAggregateInputType = {
    id?: true
    wellBillingPeriodId?: true
    irrigationLogId?: true
    duration?: true
    percentage?: true
    amount?: true
    createdAt?: true
  }

  export type WellBillingIrrigationUsageCountAggregateInputType = {
    id?: true
    wellBillingPeriodId?: true
    irrigationLogId?: true
    duration?: true
    percentage?: true
    amount?: true
    createdAt?: true
    _all?: true
  }

  export type WellBillingIrrigationUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBillingIrrigationUsage to aggregate.
     */
    where?: WellBillingIrrigationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingIrrigationUsages to fetch.
     */
    orderBy?: WellBillingIrrigationUsageOrderByWithRelationInput | WellBillingIrrigationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellBillingIrrigationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingIrrigationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingIrrigationUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellBillingIrrigationUsages
    **/
    _count?: true | WellBillingIrrigationUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellBillingIrrigationUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellBillingIrrigationUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellBillingIrrigationUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellBillingIrrigationUsageMaxAggregateInputType
  }

  export type GetWellBillingIrrigationUsageAggregateType<T extends WellBillingIrrigationUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateWellBillingIrrigationUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellBillingIrrigationUsage[P]>
      : GetScalarType<T[P], AggregateWellBillingIrrigationUsage[P]>
  }




  export type WellBillingIrrigationUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillingIrrigationUsageWhereInput
    orderBy?: WellBillingIrrigationUsageOrderByWithAggregationInput | WellBillingIrrigationUsageOrderByWithAggregationInput[]
    by: WellBillingIrrigationUsageScalarFieldEnum[] | WellBillingIrrigationUsageScalarFieldEnum
    having?: WellBillingIrrigationUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellBillingIrrigationUsageCountAggregateInputType | true
    _avg?: WellBillingIrrigationUsageAvgAggregateInputType
    _sum?: WellBillingIrrigationUsageSumAggregateInputType
    _min?: WellBillingIrrigationUsageMinAggregateInputType
    _max?: WellBillingIrrigationUsageMaxAggregateInputType
  }

  export type WellBillingIrrigationUsageGroupByOutputType = {
    id: string
    wellBillingPeriodId: string
    irrigationLogId: string
    duration: number
    percentage: number
    amount: number
    createdAt: Date
    _count: WellBillingIrrigationUsageCountAggregateOutputType | null
    _avg: WellBillingIrrigationUsageAvgAggregateOutputType | null
    _sum: WellBillingIrrigationUsageSumAggregateOutputType | null
    _min: WellBillingIrrigationUsageMinAggregateOutputType | null
    _max: WellBillingIrrigationUsageMaxAggregateOutputType | null
  }

  type GetWellBillingIrrigationUsageGroupByPayload<T extends WellBillingIrrigationUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellBillingIrrigationUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellBillingIrrigationUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellBillingIrrigationUsageGroupByOutputType[P]>
            : GetScalarType<T[P], WellBillingIrrigationUsageGroupByOutputType[P]>
        }
      >
    >


  export type WellBillingIrrigationUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wellBillingPeriodId?: boolean
    irrigationLogId?: boolean
    duration?: boolean
    percentage?: boolean
    amount?: boolean
    createdAt?: boolean
    wellBillingPeriod?: boolean | WellBillingPeriodDefaultArgs<ExtArgs>
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellBillingIrrigationUsage"]>



  export type WellBillingIrrigationUsageSelectScalar = {
    id?: boolean
    wellBillingPeriodId?: boolean
    irrigationLogId?: boolean
    duration?: boolean
    percentage?: boolean
    amount?: boolean
    createdAt?: boolean
  }

  export type WellBillingIrrigationUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wellBillingPeriodId" | "irrigationLogId" | "duration" | "percentage" | "amount" | "createdAt", ExtArgs["result"]["wellBillingIrrigationUsage"]>
  export type WellBillingIrrigationUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellBillingPeriod?: boolean | WellBillingPeriodDefaultArgs<ExtArgs>
    irrigationLog?: boolean | IrrigationLogDefaultArgs<ExtArgs>
  }

  export type $WellBillingIrrigationUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellBillingIrrigationUsage"
    objects: {
      wellBillingPeriod: Prisma.$WellBillingPeriodPayload<ExtArgs>
      irrigationLog: Prisma.$IrrigationLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wellBillingPeriodId: string
      irrigationLogId: string
      duration: number
      percentage: number
      amount: number
      createdAt: Date
    }, ExtArgs["result"]["wellBillingIrrigationUsage"]>
    composites: {}
  }

  type WellBillingIrrigationUsageGetPayload<S extends boolean | null | undefined | WellBillingIrrigationUsageDefaultArgs> = $Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload, S>

  type WellBillingIrrigationUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellBillingIrrigationUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellBillingIrrigationUsageCountAggregateInputType | true
    }

  export interface WellBillingIrrigationUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellBillingIrrigationUsage'], meta: { name: 'WellBillingIrrigationUsage' } }
    /**
     * Find zero or one WellBillingIrrigationUsage that matches the filter.
     * @param {WellBillingIrrigationUsageFindUniqueArgs} args - Arguments to find a WellBillingIrrigationUsage
     * @example
     * // Get one WellBillingIrrigationUsage
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellBillingIrrigationUsageFindUniqueArgs>(args: SelectSubset<T, WellBillingIrrigationUsageFindUniqueArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellBillingIrrigationUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellBillingIrrigationUsageFindUniqueOrThrowArgs} args - Arguments to find a WellBillingIrrigationUsage
     * @example
     * // Get one WellBillingIrrigationUsage
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellBillingIrrigationUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, WellBillingIrrigationUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBillingIrrigationUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageFindFirstArgs} args - Arguments to find a WellBillingIrrigationUsage
     * @example
     * // Get one WellBillingIrrigationUsage
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellBillingIrrigationUsageFindFirstArgs>(args?: SelectSubset<T, WellBillingIrrigationUsageFindFirstArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBillingIrrigationUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageFindFirstOrThrowArgs} args - Arguments to find a WellBillingIrrigationUsage
     * @example
     * // Get one WellBillingIrrigationUsage
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellBillingIrrigationUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, WellBillingIrrigationUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBillingIrrigationUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellBillingIrrigationUsages
     * const wellBillingIrrigationUsages = await prisma.wellBillingIrrigationUsage.findMany()
     * 
     * // Get first 10 WellBillingIrrigationUsages
     * const wellBillingIrrigationUsages = await prisma.wellBillingIrrigationUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellBillingIrrigationUsageWithIdOnly = await prisma.wellBillingIrrigationUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellBillingIrrigationUsageFindManyArgs>(args?: SelectSubset<T, WellBillingIrrigationUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellBillingIrrigationUsage.
     * @param {WellBillingIrrigationUsageCreateArgs} args - Arguments to create a WellBillingIrrigationUsage.
     * @example
     * // Create one WellBillingIrrigationUsage
     * const WellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.create({
     *   data: {
     *     // ... data to create a WellBillingIrrigationUsage
     *   }
     * })
     * 
     */
    create<T extends WellBillingIrrigationUsageCreateArgs>(args: SelectSubset<T, WellBillingIrrigationUsageCreateArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellBillingIrrigationUsages.
     * @param {WellBillingIrrigationUsageCreateManyArgs} args - Arguments to create many WellBillingIrrigationUsages.
     * @example
     * // Create many WellBillingIrrigationUsages
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellBillingIrrigationUsageCreateManyArgs>(args?: SelectSubset<T, WellBillingIrrigationUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WellBillingIrrigationUsage.
     * @param {WellBillingIrrigationUsageDeleteArgs} args - Arguments to delete one WellBillingIrrigationUsage.
     * @example
     * // Delete one WellBillingIrrigationUsage
     * const WellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.delete({
     *   where: {
     *     // ... filter to delete one WellBillingIrrigationUsage
     *   }
     * })
     * 
     */
    delete<T extends WellBillingIrrigationUsageDeleteArgs>(args: SelectSubset<T, WellBillingIrrigationUsageDeleteArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellBillingIrrigationUsage.
     * @param {WellBillingIrrigationUsageUpdateArgs} args - Arguments to update one WellBillingIrrigationUsage.
     * @example
     * // Update one WellBillingIrrigationUsage
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellBillingIrrigationUsageUpdateArgs>(args: SelectSubset<T, WellBillingIrrigationUsageUpdateArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellBillingIrrigationUsages.
     * @param {WellBillingIrrigationUsageDeleteManyArgs} args - Arguments to filter WellBillingIrrigationUsages to delete.
     * @example
     * // Delete a few WellBillingIrrigationUsages
     * const { count } = await prisma.wellBillingIrrigationUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellBillingIrrigationUsageDeleteManyArgs>(args?: SelectSubset<T, WellBillingIrrigationUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellBillingIrrigationUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellBillingIrrigationUsages
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellBillingIrrigationUsageUpdateManyArgs>(args: SelectSubset<T, WellBillingIrrigationUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WellBillingIrrigationUsage.
     * @param {WellBillingIrrigationUsageUpsertArgs} args - Arguments to update or create a WellBillingIrrigationUsage.
     * @example
     * // Update or create a WellBillingIrrigationUsage
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.upsert({
     *   create: {
     *     // ... data to create a WellBillingIrrigationUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellBillingIrrigationUsage we want to update
     *   }
     * })
     */
    upsert<T extends WellBillingIrrigationUsageUpsertArgs>(args: SelectSubset<T, WellBillingIrrigationUsageUpsertArgs<ExtArgs>>): Prisma__WellBillingIrrigationUsageClient<$Result.GetResult<Prisma.$WellBillingIrrigationUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBillingIrrigationUsages that matches the filter.
     * @param {WellBillingIrrigationUsageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WellBillingIrrigationUsageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WellBillingIrrigationUsage.
     * @param {WellBillingIrrigationUsageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const wellBillingIrrigationUsage = await prisma.wellBillingIrrigationUsage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WellBillingIrrigationUsageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WellBillingIrrigationUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageCountArgs} args - Arguments to filter WellBillingIrrigationUsages to count.
     * @example
     * // Count the number of WellBillingIrrigationUsages
     * const count = await prisma.wellBillingIrrigationUsage.count({
     *   where: {
     *     // ... the filter for the WellBillingIrrigationUsages we want to count
     *   }
     * })
    **/
    count<T extends WellBillingIrrigationUsageCountArgs>(
      args?: Subset<T, WellBillingIrrigationUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellBillingIrrigationUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellBillingIrrigationUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellBillingIrrigationUsageAggregateArgs>(args: Subset<T, WellBillingIrrigationUsageAggregateArgs>): Prisma.PrismaPromise<GetWellBillingIrrigationUsageAggregateType<T>>

    /**
     * Group by WellBillingIrrigationUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillingIrrigationUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellBillingIrrigationUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellBillingIrrigationUsageGroupByArgs['orderBy'] }
        : { orderBy?: WellBillingIrrigationUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellBillingIrrigationUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellBillingIrrigationUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellBillingIrrigationUsage model
   */
  readonly fields: WellBillingIrrigationUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellBillingIrrigationUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellBillingIrrigationUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wellBillingPeriod<T extends WellBillingPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellBillingPeriodDefaultArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    irrigationLog<T extends IrrigationLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationLogDefaultArgs<ExtArgs>>): Prisma__IrrigationLogClient<$Result.GetResult<Prisma.$IrrigationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellBillingIrrigationUsage model
   */
  interface WellBillingIrrigationUsageFieldRefs {
    readonly id: FieldRef<"WellBillingIrrigationUsage", 'String'>
    readonly wellBillingPeriodId: FieldRef<"WellBillingIrrigationUsage", 'String'>
    readonly irrigationLogId: FieldRef<"WellBillingIrrigationUsage", 'String'>
    readonly duration: FieldRef<"WellBillingIrrigationUsage", 'Float'>
    readonly percentage: FieldRef<"WellBillingIrrigationUsage", 'Float'>
    readonly amount: FieldRef<"WellBillingIrrigationUsage", 'Float'>
    readonly createdAt: FieldRef<"WellBillingIrrigationUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellBillingIrrigationUsage findUnique
   */
  export type WellBillingIrrigationUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingIrrigationUsage to fetch.
     */
    where: WellBillingIrrigationUsageWhereUniqueInput
  }

  /**
   * WellBillingIrrigationUsage findUniqueOrThrow
   */
  export type WellBillingIrrigationUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingIrrigationUsage to fetch.
     */
    where: WellBillingIrrigationUsageWhereUniqueInput
  }

  /**
   * WellBillingIrrigationUsage findFirst
   */
  export type WellBillingIrrigationUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingIrrigationUsage to fetch.
     */
    where?: WellBillingIrrigationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingIrrigationUsages to fetch.
     */
    orderBy?: WellBillingIrrigationUsageOrderByWithRelationInput | WellBillingIrrigationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBillingIrrigationUsages.
     */
    cursor?: WellBillingIrrigationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingIrrigationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingIrrigationUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBillingIrrigationUsages.
     */
    distinct?: WellBillingIrrigationUsageScalarFieldEnum | WellBillingIrrigationUsageScalarFieldEnum[]
  }

  /**
   * WellBillingIrrigationUsage findFirstOrThrow
   */
  export type WellBillingIrrigationUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingIrrigationUsage to fetch.
     */
    where?: WellBillingIrrigationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingIrrigationUsages to fetch.
     */
    orderBy?: WellBillingIrrigationUsageOrderByWithRelationInput | WellBillingIrrigationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBillingIrrigationUsages.
     */
    cursor?: WellBillingIrrigationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingIrrigationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingIrrigationUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBillingIrrigationUsages.
     */
    distinct?: WellBillingIrrigationUsageScalarFieldEnum | WellBillingIrrigationUsageScalarFieldEnum[]
  }

  /**
   * WellBillingIrrigationUsage findMany
   */
  export type WellBillingIrrigationUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * Filter, which WellBillingIrrigationUsages to fetch.
     */
    where?: WellBillingIrrigationUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillingIrrigationUsages to fetch.
     */
    orderBy?: WellBillingIrrigationUsageOrderByWithRelationInput | WellBillingIrrigationUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellBillingIrrigationUsages.
     */
    cursor?: WellBillingIrrigationUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillingIrrigationUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillingIrrigationUsages.
     */
    skip?: number
    distinct?: WellBillingIrrigationUsageScalarFieldEnum | WellBillingIrrigationUsageScalarFieldEnum[]
  }

  /**
   * WellBillingIrrigationUsage create
   */
  export type WellBillingIrrigationUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a WellBillingIrrigationUsage.
     */
    data: XOR<WellBillingIrrigationUsageCreateInput, WellBillingIrrigationUsageUncheckedCreateInput>
  }

  /**
   * WellBillingIrrigationUsage createMany
   */
  export type WellBillingIrrigationUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellBillingIrrigationUsages.
     */
    data: WellBillingIrrigationUsageCreateManyInput | WellBillingIrrigationUsageCreateManyInput[]
  }

  /**
   * WellBillingIrrigationUsage update
   */
  export type WellBillingIrrigationUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a WellBillingIrrigationUsage.
     */
    data: XOR<WellBillingIrrigationUsageUpdateInput, WellBillingIrrigationUsageUncheckedUpdateInput>
    /**
     * Choose, which WellBillingIrrigationUsage to update.
     */
    where: WellBillingIrrigationUsageWhereUniqueInput
  }

  /**
   * WellBillingIrrigationUsage updateMany
   */
  export type WellBillingIrrigationUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellBillingIrrigationUsages.
     */
    data: XOR<WellBillingIrrigationUsageUpdateManyMutationInput, WellBillingIrrigationUsageUncheckedUpdateManyInput>
    /**
     * Filter which WellBillingIrrigationUsages to update
     */
    where?: WellBillingIrrigationUsageWhereInput
    /**
     * Limit how many WellBillingIrrigationUsages to update.
     */
    limit?: number
  }

  /**
   * WellBillingIrrigationUsage upsert
   */
  export type WellBillingIrrigationUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the WellBillingIrrigationUsage to update in case it exists.
     */
    where: WellBillingIrrigationUsageWhereUniqueInput
    /**
     * In case the WellBillingIrrigationUsage found by the `where` argument doesn't exist, create a new WellBillingIrrigationUsage with this data.
     */
    create: XOR<WellBillingIrrigationUsageCreateInput, WellBillingIrrigationUsageUncheckedCreateInput>
    /**
     * In case the WellBillingIrrigationUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellBillingIrrigationUsageUpdateInput, WellBillingIrrigationUsageUncheckedUpdateInput>
  }

  /**
   * WellBillingIrrigationUsage delete
   */
  export type WellBillingIrrigationUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
    /**
     * Filter which WellBillingIrrigationUsage to delete.
     */
    where: WellBillingIrrigationUsageWhereUniqueInput
  }

  /**
   * WellBillingIrrigationUsage deleteMany
   */
  export type WellBillingIrrigationUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBillingIrrigationUsages to delete
     */
    where?: WellBillingIrrigationUsageWhereInput
    /**
     * Limit how many WellBillingIrrigationUsages to delete.
     */
    limit?: number
  }

  /**
   * WellBillingIrrigationUsage findRaw
   */
  export type WellBillingIrrigationUsageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WellBillingIrrigationUsage aggregateRaw
   */
  export type WellBillingIrrigationUsageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WellBillingIrrigationUsage without action
   */
  export type WellBillingIrrigationUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillingIrrigationUsage
     */
    select?: WellBillingIrrigationUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillingIrrigationUsage
     */
    omit?: WellBillingIrrigationUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillingIrrigationUsageInclude<ExtArgs> | null
  }


  /**
   * Model WellBillDistribution
   */

  export type AggregateWellBillDistribution = {
    _count: WellBillDistributionCountAggregateOutputType | null
    _avg: WellBillDistributionAvgAggregateOutputType | null
    _sum: WellBillDistributionSumAggregateOutputType | null
    _min: WellBillDistributionMinAggregateOutputType | null
    _max: WellBillDistributionMaxAggregateOutputType | null
  }

  export type WellBillDistributionAvgAggregateOutputType = {
    basisDuration: number | null
    basisArea: number | null
    basisWeight: number | null
    sharePercentage: number | null
    amount: number | null
  }

  export type WellBillDistributionSumAggregateOutputType = {
    basisDuration: number | null
    basisArea: number | null
    basisWeight: number | null
    sharePercentage: number | null
    amount: number | null
  }

  export type WellBillDistributionMinAggregateOutputType = {
    id: string | null
    wellBillingPeriodId: string | null
    fieldId: string | null
    ownerId: string | null
    basisDuration: number | null
    basisArea: number | null
    basisWeight: number | null
    sharePercentage: number | null
    amount: number | null
    createdAt: Date | null
    debtId: string | null
  }

  export type WellBillDistributionMaxAggregateOutputType = {
    id: string | null
    wellBillingPeriodId: string | null
    fieldId: string | null
    ownerId: string | null
    basisDuration: number | null
    basisArea: number | null
    basisWeight: number | null
    sharePercentage: number | null
    amount: number | null
    createdAt: Date | null
    debtId: string | null
  }

  export type WellBillDistributionCountAggregateOutputType = {
    id: number
    wellBillingPeriodId: number
    fieldId: number
    ownerId: number
    basisDuration: number
    basisArea: number
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt: number
    debtId: number
    _all: number
  }


  export type WellBillDistributionAvgAggregateInputType = {
    basisDuration?: true
    basisArea?: true
    basisWeight?: true
    sharePercentage?: true
    amount?: true
  }

  export type WellBillDistributionSumAggregateInputType = {
    basisDuration?: true
    basisArea?: true
    basisWeight?: true
    sharePercentage?: true
    amount?: true
  }

  export type WellBillDistributionMinAggregateInputType = {
    id?: true
    wellBillingPeriodId?: true
    fieldId?: true
    ownerId?: true
    basisDuration?: true
    basisArea?: true
    basisWeight?: true
    sharePercentage?: true
    amount?: true
    createdAt?: true
    debtId?: true
  }

  export type WellBillDistributionMaxAggregateInputType = {
    id?: true
    wellBillingPeriodId?: true
    fieldId?: true
    ownerId?: true
    basisDuration?: true
    basisArea?: true
    basisWeight?: true
    sharePercentage?: true
    amount?: true
    createdAt?: true
    debtId?: true
  }

  export type WellBillDistributionCountAggregateInputType = {
    id?: true
    wellBillingPeriodId?: true
    fieldId?: true
    ownerId?: true
    basisDuration?: true
    basisArea?: true
    basisWeight?: true
    sharePercentage?: true
    amount?: true
    createdAt?: true
    debtId?: true
    _all?: true
  }

  export type WellBillDistributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBillDistribution to aggregate.
     */
    where?: WellBillDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillDistributions to fetch.
     */
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellBillDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellBillDistributions
    **/
    _count?: true | WellBillDistributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellBillDistributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellBillDistributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellBillDistributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellBillDistributionMaxAggregateInputType
  }

  export type GetWellBillDistributionAggregateType<T extends WellBillDistributionAggregateArgs> = {
        [P in keyof T & keyof AggregateWellBillDistribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellBillDistribution[P]>
      : GetScalarType<T[P], AggregateWellBillDistribution[P]>
  }




  export type WellBillDistributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellBillDistributionWhereInput
    orderBy?: WellBillDistributionOrderByWithAggregationInput | WellBillDistributionOrderByWithAggregationInput[]
    by: WellBillDistributionScalarFieldEnum[] | WellBillDistributionScalarFieldEnum
    having?: WellBillDistributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellBillDistributionCountAggregateInputType | true
    _avg?: WellBillDistributionAvgAggregateInputType
    _sum?: WellBillDistributionSumAggregateInputType
    _min?: WellBillDistributionMinAggregateInputType
    _max?: WellBillDistributionMaxAggregateInputType
  }

  export type WellBillDistributionGroupByOutputType = {
    id: string
    wellBillingPeriodId: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt: Date
    debtId: string | null
    _count: WellBillDistributionCountAggregateOutputType | null
    _avg: WellBillDistributionAvgAggregateOutputType | null
    _sum: WellBillDistributionSumAggregateOutputType | null
    _min: WellBillDistributionMinAggregateOutputType | null
    _max: WellBillDistributionMaxAggregateOutputType | null
  }

  type GetWellBillDistributionGroupByPayload<T extends WellBillDistributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellBillDistributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellBillDistributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellBillDistributionGroupByOutputType[P]>
            : GetScalarType<T[P], WellBillDistributionGroupByOutputType[P]>
        }
      >
    >


  export type WellBillDistributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wellBillingPeriodId?: boolean
    fieldId?: boolean
    ownerId?: boolean
    basisDuration?: boolean
    basisArea?: boolean
    basisWeight?: boolean
    sharePercentage?: boolean
    amount?: boolean
    createdAt?: boolean
    debtId?: boolean
    wellBillingPeriod?: boolean | WellBillingPeriodDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    debt?: boolean | WellBillDistribution$debtArgs<ExtArgs>
  }, ExtArgs["result"]["wellBillDistribution"]>



  export type WellBillDistributionSelectScalar = {
    id?: boolean
    wellBillingPeriodId?: boolean
    fieldId?: boolean
    ownerId?: boolean
    basisDuration?: boolean
    basisArea?: boolean
    basisWeight?: boolean
    sharePercentage?: boolean
    amount?: boolean
    createdAt?: boolean
    debtId?: boolean
  }

  export type WellBillDistributionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wellBillingPeriodId" | "fieldId" | "ownerId" | "basisDuration" | "basisArea" | "basisWeight" | "sharePercentage" | "amount" | "createdAt" | "debtId", ExtArgs["result"]["wellBillDistribution"]>
  export type WellBillDistributionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wellBillingPeriod?: boolean | WellBillingPeriodDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    debt?: boolean | WellBillDistribution$debtArgs<ExtArgs>
  }

  export type $WellBillDistributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellBillDistribution"
    objects: {
      wellBillingPeriod: Prisma.$WellBillingPeriodPayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      debt: Prisma.$DebtPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wellBillingPeriodId: string
      fieldId: string
      ownerId: string
      basisDuration: number
      basisArea: number | null
      basisWeight: number
      sharePercentage: number
      amount: number
      createdAt: Date
      debtId: string | null
    }, ExtArgs["result"]["wellBillDistribution"]>
    composites: {}
  }

  type WellBillDistributionGetPayload<S extends boolean | null | undefined | WellBillDistributionDefaultArgs> = $Result.GetResult<Prisma.$WellBillDistributionPayload, S>

  type WellBillDistributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellBillDistributionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellBillDistributionCountAggregateInputType | true
    }

  export interface WellBillDistributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellBillDistribution'], meta: { name: 'WellBillDistribution' } }
    /**
     * Find zero or one WellBillDistribution that matches the filter.
     * @param {WellBillDistributionFindUniqueArgs} args - Arguments to find a WellBillDistribution
     * @example
     * // Get one WellBillDistribution
     * const wellBillDistribution = await prisma.wellBillDistribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellBillDistributionFindUniqueArgs>(args: SelectSubset<T, WellBillDistributionFindUniqueArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellBillDistribution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellBillDistributionFindUniqueOrThrowArgs} args - Arguments to find a WellBillDistribution
     * @example
     * // Get one WellBillDistribution
     * const wellBillDistribution = await prisma.wellBillDistribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellBillDistributionFindUniqueOrThrowArgs>(args: SelectSubset<T, WellBillDistributionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBillDistribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionFindFirstArgs} args - Arguments to find a WellBillDistribution
     * @example
     * // Get one WellBillDistribution
     * const wellBillDistribution = await prisma.wellBillDistribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellBillDistributionFindFirstArgs>(args?: SelectSubset<T, WellBillDistributionFindFirstArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellBillDistribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionFindFirstOrThrowArgs} args - Arguments to find a WellBillDistribution
     * @example
     * // Get one WellBillDistribution
     * const wellBillDistribution = await prisma.wellBillDistribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellBillDistributionFindFirstOrThrowArgs>(args?: SelectSubset<T, WellBillDistributionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBillDistributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellBillDistributions
     * const wellBillDistributions = await prisma.wellBillDistribution.findMany()
     * 
     * // Get first 10 WellBillDistributions
     * const wellBillDistributions = await prisma.wellBillDistribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellBillDistributionWithIdOnly = await prisma.wellBillDistribution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellBillDistributionFindManyArgs>(args?: SelectSubset<T, WellBillDistributionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellBillDistribution.
     * @param {WellBillDistributionCreateArgs} args - Arguments to create a WellBillDistribution.
     * @example
     * // Create one WellBillDistribution
     * const WellBillDistribution = await prisma.wellBillDistribution.create({
     *   data: {
     *     // ... data to create a WellBillDistribution
     *   }
     * })
     * 
     */
    create<T extends WellBillDistributionCreateArgs>(args: SelectSubset<T, WellBillDistributionCreateArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellBillDistributions.
     * @param {WellBillDistributionCreateManyArgs} args - Arguments to create many WellBillDistributions.
     * @example
     * // Create many WellBillDistributions
     * const wellBillDistribution = await prisma.wellBillDistribution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellBillDistributionCreateManyArgs>(args?: SelectSubset<T, WellBillDistributionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WellBillDistribution.
     * @param {WellBillDistributionDeleteArgs} args - Arguments to delete one WellBillDistribution.
     * @example
     * // Delete one WellBillDistribution
     * const WellBillDistribution = await prisma.wellBillDistribution.delete({
     *   where: {
     *     // ... filter to delete one WellBillDistribution
     *   }
     * })
     * 
     */
    delete<T extends WellBillDistributionDeleteArgs>(args: SelectSubset<T, WellBillDistributionDeleteArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellBillDistribution.
     * @param {WellBillDistributionUpdateArgs} args - Arguments to update one WellBillDistribution.
     * @example
     * // Update one WellBillDistribution
     * const wellBillDistribution = await prisma.wellBillDistribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellBillDistributionUpdateArgs>(args: SelectSubset<T, WellBillDistributionUpdateArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellBillDistributions.
     * @param {WellBillDistributionDeleteManyArgs} args - Arguments to filter WellBillDistributions to delete.
     * @example
     * // Delete a few WellBillDistributions
     * const { count } = await prisma.wellBillDistribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellBillDistributionDeleteManyArgs>(args?: SelectSubset<T, WellBillDistributionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellBillDistributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellBillDistributions
     * const wellBillDistribution = await prisma.wellBillDistribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellBillDistributionUpdateManyArgs>(args: SelectSubset<T, WellBillDistributionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WellBillDistribution.
     * @param {WellBillDistributionUpsertArgs} args - Arguments to update or create a WellBillDistribution.
     * @example
     * // Update or create a WellBillDistribution
     * const wellBillDistribution = await prisma.wellBillDistribution.upsert({
     *   create: {
     *     // ... data to create a WellBillDistribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellBillDistribution we want to update
     *   }
     * })
     */
    upsert<T extends WellBillDistributionUpsertArgs>(args: SelectSubset<T, WellBillDistributionUpsertArgs<ExtArgs>>): Prisma__WellBillDistributionClient<$Result.GetResult<Prisma.$WellBillDistributionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellBillDistributions that matches the filter.
     * @param {WellBillDistributionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const wellBillDistribution = await prisma.wellBillDistribution.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: WellBillDistributionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WellBillDistribution.
     * @param {WellBillDistributionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const wellBillDistribution = await prisma.wellBillDistribution.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WellBillDistributionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WellBillDistributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionCountArgs} args - Arguments to filter WellBillDistributions to count.
     * @example
     * // Count the number of WellBillDistributions
     * const count = await prisma.wellBillDistribution.count({
     *   where: {
     *     // ... the filter for the WellBillDistributions we want to count
     *   }
     * })
    **/
    count<T extends WellBillDistributionCountArgs>(
      args?: Subset<T, WellBillDistributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellBillDistributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellBillDistribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellBillDistributionAggregateArgs>(args: Subset<T, WellBillDistributionAggregateArgs>): Prisma.PrismaPromise<GetWellBillDistributionAggregateType<T>>

    /**
     * Group by WellBillDistribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellBillDistributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellBillDistributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellBillDistributionGroupByArgs['orderBy'] }
        : { orderBy?: WellBillDistributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellBillDistributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellBillDistributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellBillDistribution model
   */
  readonly fields: WellBillDistributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellBillDistribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellBillDistributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wellBillingPeriod<T extends WellBillingPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellBillingPeriodDefaultArgs<ExtArgs>>): Prisma__WellBillingPeriodClient<$Result.GetResult<Prisma.$WellBillingPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    debt<T extends WellBillDistribution$debtArgs<ExtArgs> = {}>(args?: Subset<T, WellBillDistribution$debtArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellBillDistribution model
   */
  interface WellBillDistributionFieldRefs {
    readonly id: FieldRef<"WellBillDistribution", 'String'>
    readonly wellBillingPeriodId: FieldRef<"WellBillDistribution", 'String'>
    readonly fieldId: FieldRef<"WellBillDistribution", 'String'>
    readonly ownerId: FieldRef<"WellBillDistribution", 'String'>
    readonly basisDuration: FieldRef<"WellBillDistribution", 'Float'>
    readonly basisArea: FieldRef<"WellBillDistribution", 'Float'>
    readonly basisWeight: FieldRef<"WellBillDistribution", 'Float'>
    readonly sharePercentage: FieldRef<"WellBillDistribution", 'Float'>
    readonly amount: FieldRef<"WellBillDistribution", 'Float'>
    readonly createdAt: FieldRef<"WellBillDistribution", 'DateTime'>
    readonly debtId: FieldRef<"WellBillDistribution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WellBillDistribution findUnique
   */
  export type WellBillDistributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * Filter, which WellBillDistribution to fetch.
     */
    where: WellBillDistributionWhereUniqueInput
  }

  /**
   * WellBillDistribution findUniqueOrThrow
   */
  export type WellBillDistributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * Filter, which WellBillDistribution to fetch.
     */
    where: WellBillDistributionWhereUniqueInput
  }

  /**
   * WellBillDistribution findFirst
   */
  export type WellBillDistributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * Filter, which WellBillDistribution to fetch.
     */
    where?: WellBillDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillDistributions to fetch.
     */
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBillDistributions.
     */
    cursor?: WellBillDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBillDistributions.
     */
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * WellBillDistribution findFirstOrThrow
   */
  export type WellBillDistributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * Filter, which WellBillDistribution to fetch.
     */
    where?: WellBillDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillDistributions to fetch.
     */
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellBillDistributions.
     */
    cursor?: WellBillDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellBillDistributions.
     */
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * WellBillDistribution findMany
   */
  export type WellBillDistributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * Filter, which WellBillDistributions to fetch.
     */
    where?: WellBillDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellBillDistributions to fetch.
     */
    orderBy?: WellBillDistributionOrderByWithRelationInput | WellBillDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellBillDistributions.
     */
    cursor?: WellBillDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellBillDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellBillDistributions.
     */
    skip?: number
    distinct?: WellBillDistributionScalarFieldEnum | WellBillDistributionScalarFieldEnum[]
  }

  /**
   * WellBillDistribution create
   */
  export type WellBillDistributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * The data needed to create a WellBillDistribution.
     */
    data: XOR<WellBillDistributionCreateInput, WellBillDistributionUncheckedCreateInput>
  }

  /**
   * WellBillDistribution createMany
   */
  export type WellBillDistributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellBillDistributions.
     */
    data: WellBillDistributionCreateManyInput | WellBillDistributionCreateManyInput[]
  }

  /**
   * WellBillDistribution update
   */
  export type WellBillDistributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * The data needed to update a WellBillDistribution.
     */
    data: XOR<WellBillDistributionUpdateInput, WellBillDistributionUncheckedUpdateInput>
    /**
     * Choose, which WellBillDistribution to update.
     */
    where: WellBillDistributionWhereUniqueInput
  }

  /**
   * WellBillDistribution updateMany
   */
  export type WellBillDistributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellBillDistributions.
     */
    data: XOR<WellBillDistributionUpdateManyMutationInput, WellBillDistributionUncheckedUpdateManyInput>
    /**
     * Filter which WellBillDistributions to update
     */
    where?: WellBillDistributionWhereInput
    /**
     * Limit how many WellBillDistributions to update.
     */
    limit?: number
  }

  /**
   * WellBillDistribution upsert
   */
  export type WellBillDistributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * The filter to search for the WellBillDistribution to update in case it exists.
     */
    where: WellBillDistributionWhereUniqueInput
    /**
     * In case the WellBillDistribution found by the `where` argument doesn't exist, create a new WellBillDistribution with this data.
     */
    create: XOR<WellBillDistributionCreateInput, WellBillDistributionUncheckedCreateInput>
    /**
     * In case the WellBillDistribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellBillDistributionUpdateInput, WellBillDistributionUncheckedUpdateInput>
  }

  /**
   * WellBillDistribution delete
   */
  export type WellBillDistributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
    /**
     * Filter which WellBillDistribution to delete.
     */
    where: WellBillDistributionWhereUniqueInput
  }

  /**
   * WellBillDistribution deleteMany
   */
  export type WellBillDistributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellBillDistributions to delete
     */
    where?: WellBillDistributionWhereInput
    /**
     * Limit how many WellBillDistributions to delete.
     */
    limit?: number
  }

  /**
   * WellBillDistribution findRaw
   */
  export type WellBillDistributionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WellBillDistribution aggregateRaw
   */
  export type WellBillDistributionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WellBillDistribution.debt
   */
  export type WellBillDistribution$debtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
  }

  /**
   * WellBillDistribution without action
   */
  export type WellBillDistributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellBillDistribution
     */
    select?: WellBillDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellBillDistribution
     */
    omit?: WellBillDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellBillDistributionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const FieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    size: 'size',
    coordinates: 'coordinates',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    seasonId: 'seasonId'
  };

  export type FieldScalarFieldEnum = (typeof FieldScalarFieldEnum)[keyof typeof FieldScalarFieldEnum]


  export const FieldOwnershipScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    percentage: 'percentage',
    fieldId: 'fieldId',
    userId: 'userId'
  };

  export type FieldOwnershipScalarFieldEnum = (typeof FieldOwnershipScalarFieldEnum)[keyof typeof FieldOwnershipScalarFieldEnum]


  export const FieldWorkerAssignmentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fieldId: 'fieldId',
    userId: 'userId'
  };

  export type FieldWorkerAssignmentScalarFieldEnum = (typeof FieldWorkerAssignmentScalarFieldEnum)[keyof typeof FieldWorkerAssignmentScalarFieldEnum]


  export const FieldWellScalarFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    wellId: 'wellId',
    createdAt: 'createdAt'
  };

  export type FieldWellScalarFieldEnum = (typeof FieldWellScalarFieldEnum)[keyof typeof FieldWellScalarFieldEnum]


  export const WorkerWellAssignmentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workerId: 'workerId',
    wellId: 'wellId'
  };

  export type WorkerWellAssignmentScalarFieldEnum = (typeof WorkerWellAssignmentScalarFieldEnum)[keyof typeof WorkerWellAssignmentScalarFieldEnum]


  export const WellScalarFieldEnum: {
    id: 'id',
    name: 'name',
    depth: 'depth',
    capacity: 'capacity',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellScalarFieldEnum = (typeof WellScalarFieldEnum)[keyof typeof WellScalarFieldEnum]


  export const CropScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plantedDate: 'plantedDate',
    harvestDate: 'harvestDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    seasonId: 'seasonId',
    fieldId: 'fieldId'
  };

  export type CropScalarFieldEnum = (typeof CropScalarFieldEnum)[keyof typeof CropScalarFieldEnum]


  export const ProcessingLogScalarFieldEnum: {
    id: 'id',
    date: 'date',
    processType: 'processType',
    equipment: 'equipment',
    duration: 'duration',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fieldId: 'fieldId'
  };

  export type ProcessingLogScalarFieldEnum = (typeof ProcessingLogScalarFieldEnum)[keyof typeof ProcessingLogScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    totalQuantity: 'totalQuantity',
    unit: 'unit',
    totalStock: 'totalStock',
    purchaseDate: 'purchaseDate',
    expiryDate: 'expiryDate',
    status: 'status',
    costPrice: 'costPrice',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryOwnershipScalarFieldEnum: {
    id: 'id',
    inventoryId: 'inventoryId',
    userId: 'userId',
    shareQuantity: 'shareQuantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryOwnershipScalarFieldEnum = (typeof InventoryOwnershipScalarFieldEnum)[keyof typeof InventoryOwnershipScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    product: 'product',
    category: 'category',
    quantity: 'quantity',
    unit: 'unit',
    unitPrice: 'unitPrice',
    totalCost: 'totalCost',
    paymentMethod: 'paymentMethod',
    creditorPaymentDueDate: 'creditorPaymentDueDate',
    dueDate: 'dueDate',
    description: 'description',
    createdAt: 'createdAt',
    isTemplate: 'isTemplate',
    templateName: 'templateName',
    approvalStatus: 'approvalStatus',
    approvalRequired: 'approvalRequired',
    approvalThreshold: 'approvalThreshold',
    seasonId: 'seasonId'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseApprovalScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    approverId: 'approverId',
    status: 'status',
    comment: 'comment',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseApprovalScalarFieldEnum = (typeof PurchaseApprovalScalarFieldEnum)[keyof typeof PurchaseApprovalScalarFieldEnum]


  export const PurchaseContributorScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    userId: 'userId',
    sharePercentage: 'sharePercentage',
    contribution: 'contribution',
    expectedContribution: 'expectedContribution',
    actualContribution: 'actualContribution',
    remainingAmount: 'remainingAmount',
    hasPaid: 'hasPaid',
    paymentDate: 'paymentDate',
    isCreditor: 'isCreditor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseContributorScalarFieldEnum = (typeof PurchaseContributorScalarFieldEnum)[keyof typeof PurchaseContributorScalarFieldEnum]


  export const PaymentHistoryScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    notes: 'notes',
    createdAt: 'createdAt',
    debtId: 'debtId',
    contributorId: 'contributorId',
    payerId: 'payerId',
    receiverId: 'receiverId'
  };

  export type PaymentHistoryScalarFieldEnum = (typeof PaymentHistoryScalarFieldEnum)[keyof typeof PaymentHistoryScalarFieldEnum]


  export const InventoryTransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    quantity: 'quantity',
    date: 'date',
    notes: 'notes',
    createdAt: 'createdAt',
    seasonId: 'seasonId',
    inventoryId: 'inventoryId',
    purchaseId: 'purchaseId',
    userId: 'userId'
  };

  export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


  export const DebtScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    description: 'description',
    createdAt: 'createdAt',
    paymentDate: 'paymentDate',
    reminderSent: 'reminderSent',
    lastReminderDate: 'lastReminderDate',
    reason: 'reason',
    creditorId: 'creditorId',
    debtorId: 'debtorId',
    invoiceId: 'invoiceId',
    purchaseId: 'purchaseId'
  };

  export type DebtScalarFieldEnum = (typeof DebtScalarFieldEnum)[keyof typeof DebtScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    number: 'number',
    amount: 'amount',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    status: 'status',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    purchaserId: 'purchaserId',
    purchaseId: 'purchaseId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InventoryUsageScalarFieldEnum: {
    id: 'id',
    inventoryId: 'inventoryId',
    usedQuantity: 'usedQuantity',
    usageType: 'usageType',
    usedById: 'usedById',
    fieldId: 'fieldId',
    processId: 'processId',
    createdAt: 'createdAt'
  };

  export type InventoryUsageScalarFieldEnum = (typeof InventoryUsageScalarFieldEnum)[keyof typeof InventoryUsageScalarFieldEnum]


  export const ProcessScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    fieldId: 'fieldId',
    workerId: 'workerId',
    date: 'date',
    description: 'description',
    totalArea: 'totalArea',
    processedArea: 'processedArea',
    processedPercentage: 'processedPercentage',
    seasonId: 'seasonId',
    inventoryDistribution: 'inventoryDistribution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    priority: 'priority',
    isRead: 'isRead',
    isArchived: 'isArchived',
    link: 'link',
    expiresAt: 'expiresAt',
    targetRoles: 'targetRoles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    receiverId: 'receiverId',
    senderId: 'senderId',
    processId: 'processId',
    debtId: 'debtId',
    purchaseId: 'purchaseId',
    inventoryId: 'inventoryId',
    irrigationId: 'irrigationId',
    fieldId: 'fieldId',
    seasonId: 'seasonId',
    cropId: 'cropId',
    wellId: 'wellId',
    processingLogId: 'processingLogId',
    invoiceId: 'invoiceId',
    inventoryUsageId: 'inventoryUsageId',
    transactionId: 'transactionId',
    paymentId: 'paymentId',
    contributorId: 'contributorId',
    approvalId: 'approvalId',
    equipmentId: 'equipmentId',
    equipmentUsageId: 'equipmentUsageId',
    processCostId: 'processCostId',
    fieldExpenseId: 'fieldExpenseId',
    ownerExpenseId: 'ownerExpenseId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailNotifications: 'emailNotifications',
    pushNotifications: 'pushNotifications',
    inAppNotifications: 'inAppNotifications',
    dailyDigest: 'dailyDigest',
    notifyOnDebtReminders: 'notifyOnDebtReminders',
    notifyOnPayments: 'notifyOnPayments',
    notifyOnProcessUpdates: 'notifyOnProcessUpdates',
    notifyOnInventoryAlerts: 'notifyOnInventoryAlerts',
    notifyOnApprovals: 'notifyOnApprovals',
    notifyOnIrrigation: 'notifyOnIrrigation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    fuelConsumptionPerDecare: 'fuelConsumptionPerDecare',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const EquipmentOwnershipScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    userId: 'userId',
    ownershipPercentage: 'ownershipPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentOwnershipScalarFieldEnum = (typeof EquipmentOwnershipScalarFieldEnum)[keyof typeof EquipmentOwnershipScalarFieldEnum]


  export const EquipmentCapabilityScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    inventoryCategory: 'inventoryCategory',
    canUse: 'canUse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentCapabilityScalarFieldEnum = (typeof EquipmentCapabilityScalarFieldEnum)[keyof typeof EquipmentCapabilityScalarFieldEnum]


  export const EquipmentUsageScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    equipmentId: 'equipmentId',
    userId: 'userId',
    areaProcessed: 'areaProcessed',
    processedPercentage: 'processedPercentage',
    fuelConsumed: 'fuelConsumed',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentUsageScalarFieldEnum = (typeof EquipmentUsageScalarFieldEnum)[keyof typeof EquipmentUsageScalarFieldEnum]


  export const ProcessCostScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    laborCost: 'laborCost',
    equipmentCost: 'equipmentCost',
    inventoryCost: 'inventoryCost',
    fuelCost: 'fuelCost',
    totalCost: 'totalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fieldId: 'fieldId'
  };

  export type ProcessCostScalarFieldEnum = (typeof ProcessCostScalarFieldEnum)[keyof typeof ProcessCostScalarFieldEnum]


  export const FieldExpenseScalarFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    seasonId: 'seasonId',
    totalCost: 'totalCost',
    description: 'description',
    expenseDate: 'expenseDate',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FieldExpenseScalarFieldEnum = (typeof FieldExpenseScalarFieldEnum)[keyof typeof FieldExpenseScalarFieldEnum]


  export const FieldOwnerExpenseScalarFieldEnum: {
    id: 'id',
    fieldOwnershipId: 'fieldOwnershipId',
    processCostId: 'processCostId',
    userId: 'userId',
    amount: 'amount',
    percentage: 'percentage',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FieldOwnerExpenseScalarFieldEnum = (typeof FieldOwnerExpenseScalarFieldEnum)[keyof typeof FieldOwnerExpenseScalarFieldEnum]


  export const IrrigationLogScalarFieldEnum: {
    id: 'id',
    startDateTime: 'startDateTime',
    duration: 'duration',
    wellId: 'wellId',
    notes: 'notes',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    seasonId: 'seasonId'
  };

  export type IrrigationLogScalarFieldEnum = (typeof IrrigationLogScalarFieldEnum)[keyof typeof IrrigationLogScalarFieldEnum]


  export const IrrigationFieldUsageScalarFieldEnum: {
    id: 'id',
    irrigationLogId: 'irrigationLogId',
    fieldId: 'fieldId',
    percentage: 'percentage',
    actualIrrigatedArea: 'actualIrrigatedArea',
    createdAt: 'createdAt'
  };

  export type IrrigationFieldUsageScalarFieldEnum = (typeof IrrigationFieldUsageScalarFieldEnum)[keyof typeof IrrigationFieldUsageScalarFieldEnum]


  export const IrrigationOwnerUsageScalarFieldEnum: {
    id: 'id',
    irrigationFieldUsageId: 'irrigationFieldUsageId',
    ownerId: 'ownerId',
    ownershipPercentage: 'ownershipPercentage',
    usagePercentage: 'usagePercentage',
    createdAt: 'createdAt'
  };

  export type IrrigationOwnerUsageScalarFieldEnum = (typeof IrrigationOwnerUsageScalarFieldEnum)[keyof typeof IrrigationOwnerUsageScalarFieldEnum]


  export const IrrigationOwnerSummaryScalarFieldEnum: {
    id: 'id',
    irrigationLogId: 'irrigationLogId',
    ownerId: 'ownerId',
    totalIrrigatedArea: 'totalIrrigatedArea',
    totalAllocatedDuration: 'totalAllocatedDuration',
    createdAt: 'createdAt'
  };

  export type IrrigationOwnerSummaryScalarFieldEnum = (typeof IrrigationOwnerSummaryScalarFieldEnum)[keyof typeof IrrigationOwnerSummaryScalarFieldEnum]


  export const IrrigationInventoryUsageScalarFieldEnum: {
    id: 'id',
    irrigationLogId: 'irrigationLogId',
    inventoryId: 'inventoryId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalCost: 'totalCost',
    createdAt: 'createdAt'
  };

  export type IrrigationInventoryUsageScalarFieldEnum = (typeof IrrigationInventoryUsageScalarFieldEnum)[keyof typeof IrrigationInventoryUsageScalarFieldEnum]


  export const IrrigationInventoryOwnerUsageScalarFieldEnum: {
    id: 'id',
    irrigationInventoryUsageId: 'irrigationInventoryUsageId',
    ownerId: 'ownerId',
    percentage: 'percentage',
    quantity: 'quantity',
    cost: 'cost',
    createdAt: 'createdAt'
  };

  export type IrrigationInventoryOwnerUsageScalarFieldEnum = (typeof IrrigationInventoryOwnerUsageScalarFieldEnum)[keyof typeof IrrigationInventoryOwnerUsageScalarFieldEnum]


  export const WellBillingPeriodScalarFieldEnum: {
    id: 'id',
    wellId: 'wellId',
    startDate: 'startDate',
    endDate: 'endDate',
    totalAmount: 'totalAmount',
    totalUsage: 'totalUsage',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type WellBillingPeriodScalarFieldEnum = (typeof WellBillingPeriodScalarFieldEnum)[keyof typeof WellBillingPeriodScalarFieldEnum]


  export const WellBillingIrrigationUsageScalarFieldEnum: {
    id: 'id',
    wellBillingPeriodId: 'wellBillingPeriodId',
    irrigationLogId: 'irrigationLogId',
    duration: 'duration',
    percentage: 'percentage',
    amount: 'amount',
    createdAt: 'createdAt'
  };

  export type WellBillingIrrigationUsageScalarFieldEnum = (typeof WellBillingIrrigationUsageScalarFieldEnum)[keyof typeof WellBillingIrrigationUsageScalarFieldEnum]


  export const WellBillDistributionScalarFieldEnum: {
    id: 'id',
    wellBillingPeriodId: 'wellBillingPeriodId',
    fieldId: 'fieldId',
    ownerId: 'ownerId',
    basisDuration: 'basisDuration',
    basisArea: 'basisArea',
    basisWeight: 'basisWeight',
    sharePercentage: 'sharePercentage',
    amount: 'amount',
    createdAt: 'createdAt',
    debtId: 'debtId'
  };

  export type WellBillDistributionScalarFieldEnum = (typeof WellBillDistributionScalarFieldEnum)[keyof typeof WellBillDistributionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CropStatus'
   */
  export type EnumCropStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CropStatus'>
    


  /**
   * Reference to a field of type 'CropStatus[]'
   */
  export type ListEnumCropStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CropStatus[]'>
    


  /**
   * Reference to a field of type 'ProcessType'
   */
  export type EnumProcessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessType'>
    


  /**
   * Reference to a field of type 'ProcessType[]'
   */
  export type ListEnumProcessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessType[]'>
    


  /**
   * Reference to a field of type 'InventoryCategory'
   */
  export type EnumInventoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryCategory'>
    


  /**
   * Reference to a field of type 'InventoryCategory[]'
   */
  export type ListEnumInventoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryCategory[]'>
    


  /**
   * Reference to a field of type 'Unit'
   */
  export type EnumUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Unit'>
    


  /**
   * Reference to a field of type 'Unit[]'
   */
  export type ListEnumUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Unit[]'>
    


  /**
   * Reference to a field of type 'InventoryStatus'
   */
  export type EnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus'>
    


  /**
   * Reference to a field of type 'InventoryStatus[]'
   */
  export type ListEnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus[]'>
    


  /**
   * Reference to a field of type 'ProductCategory'
   */
  export type EnumProductCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCategory'>
    


  /**
   * Reference to a field of type 'ProductCategory[]'
   */
  export type ListEnumProductCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCategory[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'DebtStatus'
   */
  export type EnumDebtStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebtStatus'>
    


  /**
   * Reference to a field of type 'DebtStatus[]'
   */
  export type ListEnumDebtStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebtStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'UsageType'
   */
  export type EnumUsageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsageType'>
    


  /**
   * Reference to a field of type 'UsageType[]'
   */
  export type ListEnumUsageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsageType[]'>
    


  /**
   * Reference to a field of type 'ProcessStatus'
   */
  export type EnumProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessStatus'>
    


  /**
   * Reference to a field of type 'ProcessStatus[]'
   */
  export type ListEnumProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'EquipmentType'
   */
  export type EnumEquipmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentType'>
    


  /**
   * Reference to a field of type 'EquipmentType[]'
   */
  export type ListEnumEquipmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentType[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    irrigationLogs?: IrrigationLogListRelationFilter
    ownedFields?: FieldOwnershipListRelationFilter
    assignedFields?: FieldWorkerAssignmentListRelationFilter
    inventoryOwnership?: InventoryOwnershipListRelationFilter
    debtsAsCreditor?: DebtListRelationFilter
    debtsAsDebtor?: DebtListRelationFilter
    purchaseContributions?: PurchaseContributorListRelationFilter
    receivedNotifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    inventoryUsages?: InventoryUsageListRelationFilter
    processes?: ProcessListRelationFilter
    invoicesPurchased?: InvoiceListRelationFilter
    paymentsMade?: PaymentHistoryListRelationFilter
    paymentsReceived?: PaymentHistoryListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    seasons?: SeasonListRelationFilter
    purchaseApprovals?: PurchaseApprovalListRelationFilter
    equipmentOwnerships?: EquipmentOwnershipListRelationFilter
    equipmentUsages?: EquipmentUsageListRelationFilter
    fieldOwnerExpenses?: FieldOwnerExpenseListRelationFilter
    wellAssignments?: WorkerWellAssignmentListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    irrigationOwnerUsages?: IrrigationOwnerUsageListRelationFilter
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageListRelationFilter
    irrigationOwnerSummaries?: IrrigationOwnerSummaryListRelationFilter
    wellBillDistributions?: WellBillDistributionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    irrigationLogs?: IrrigationLogOrderByRelationAggregateInput
    ownedFields?: FieldOwnershipOrderByRelationAggregateInput
    assignedFields?: FieldWorkerAssignmentOrderByRelationAggregateInput
    inventoryOwnership?: InventoryOwnershipOrderByRelationAggregateInput
    debtsAsCreditor?: DebtOrderByRelationAggregateInput
    debtsAsDebtor?: DebtOrderByRelationAggregateInput
    purchaseContributions?: PurchaseContributorOrderByRelationAggregateInput
    receivedNotifications?: NotificationOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    inventoryUsages?: InventoryUsageOrderByRelationAggregateInput
    processes?: ProcessOrderByRelationAggregateInput
    invoicesPurchased?: InvoiceOrderByRelationAggregateInput
    paymentsMade?: PaymentHistoryOrderByRelationAggregateInput
    paymentsReceived?: PaymentHistoryOrderByRelationAggregateInput
    inventoryTransactions?: InventoryTransactionOrderByRelationAggregateInput
    seasons?: SeasonOrderByRelationAggregateInput
    purchaseApprovals?: PurchaseApprovalOrderByRelationAggregateInput
    equipmentOwnerships?: EquipmentOwnershipOrderByRelationAggregateInput
    equipmentUsages?: EquipmentUsageOrderByRelationAggregateInput
    fieldOwnerExpenses?: FieldOwnerExpenseOrderByRelationAggregateInput
    wellAssignments?: WorkerWellAssignmentOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByWithRelationInput
    irrigationOwnerUsages?: IrrigationOwnerUsageOrderByRelationAggregateInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageOrderByRelationAggregateInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryOrderByRelationAggregateInput
    wellBillDistributions?: WellBillDistributionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    irrigationLogs?: IrrigationLogListRelationFilter
    ownedFields?: FieldOwnershipListRelationFilter
    assignedFields?: FieldWorkerAssignmentListRelationFilter
    inventoryOwnership?: InventoryOwnershipListRelationFilter
    debtsAsCreditor?: DebtListRelationFilter
    debtsAsDebtor?: DebtListRelationFilter
    purchaseContributions?: PurchaseContributorListRelationFilter
    receivedNotifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    inventoryUsages?: InventoryUsageListRelationFilter
    processes?: ProcessListRelationFilter
    invoicesPurchased?: InvoiceListRelationFilter
    paymentsMade?: PaymentHistoryListRelationFilter
    paymentsReceived?: PaymentHistoryListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    seasons?: SeasonListRelationFilter
    purchaseApprovals?: PurchaseApprovalListRelationFilter
    equipmentOwnerships?: EquipmentOwnershipListRelationFilter
    equipmentUsages?: EquipmentUsageListRelationFilter
    fieldOwnerExpenses?: FieldOwnerExpenseListRelationFilter
    wellAssignments?: WorkerWellAssignmentListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    irrigationOwnerUsages?: IrrigationOwnerUsageListRelationFilter
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageListRelationFilter
    irrigationOwnerSummaries?: IrrigationOwnerSummaryListRelationFilter
    wellBillDistributions?: WellBillDistributionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: StringFilter<"Season"> | string
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    description?: StringNullableFilter<"Season"> | string | null
    isActive?: BoolFilter<"Season"> | boolean
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    creatorId?: StringFilter<"Season"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    fields?: FieldListRelationFilter
    crops?: CropListRelationFilter
    purchases?: PurchaseListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    processes?: ProcessListRelationFilter
    irrigationLogs?: IrrigationLogListRelationFilter
    fieldExpenses?: FieldExpenseListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    creator?: UserOrderByWithRelationInput
    fields?: FieldOrderByRelationAggregateInput
    crops?: CropOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    inventoryTransactions?: InventoryTransactionOrderByRelationAggregateInput
    processes?: ProcessOrderByRelationAggregateInput
    irrigationLogs?: IrrigationLogOrderByRelationAggregateInput
    fieldExpenses?: FieldExpenseOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    description?: StringNullableFilter<"Season"> | string | null
    isActive?: BoolFilter<"Season"> | boolean
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    creatorId?: StringFilter<"Season"> | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    fields?: FieldListRelationFilter
    crops?: CropListRelationFilter
    purchases?: PurchaseListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    processes?: ProcessListRelationFilter
    irrigationLogs?: IrrigationLogListRelationFilter
    fieldExpenses?: FieldExpenseListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Season"> | string
    name?: StringWithAggregatesFilter<"Season"> | string
    startDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Season"> | string | null
    isActive?: BoolWithAggregatesFilter<"Season"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Season"> | string
  }

  export type FieldWhereInput = {
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    id?: StringFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    location?: StringFilter<"Field"> | string
    size?: FloatFilter<"Field"> | number
    coordinates?: StringNullableFilter<"Field"> | string | null
    status?: StringFilter<"Field"> | string
    createdAt?: DateTimeFilter<"Field"> | Date | string
    updatedAt?: DateTimeFilter<"Field"> | Date | string
    seasonId?: StringNullableFilter<"Field"> | string | null
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    owners?: FieldOwnershipListRelationFilter
    workerAssignments?: FieldWorkerAssignmentListRelationFilter
    crops?: CropListRelationFilter
    fieldWells?: FieldWellListRelationFilter
    processingLogs?: ProcessingLogListRelationFilter
    processCosts?: ProcessCostListRelationFilter
    inventoryUsages?: InventoryUsageListRelationFilter
    processes?: ProcessListRelationFilter
    fieldExpenses?: FieldExpenseListRelationFilter
    notifications?: NotificationListRelationFilter
    irrigationFieldUsages?: IrrigationFieldUsageListRelationFilter
    wellBillDistributions?: WellBillDistributionListRelationFilter
  }

  export type FieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    size?: SortOrder
    coordinates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    season?: SeasonOrderByWithRelationInput
    owners?: FieldOwnershipOrderByRelationAggregateInput
    workerAssignments?: FieldWorkerAssignmentOrderByRelationAggregateInput
    crops?: CropOrderByRelationAggregateInput
    fieldWells?: FieldWellOrderByRelationAggregateInput
    processingLogs?: ProcessingLogOrderByRelationAggregateInput
    processCosts?: ProcessCostOrderByRelationAggregateInput
    inventoryUsages?: InventoryUsageOrderByRelationAggregateInput
    processes?: ProcessOrderByRelationAggregateInput
    fieldExpenses?: FieldExpenseOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    irrigationFieldUsages?: IrrigationFieldUsageOrderByRelationAggregateInput
    wellBillDistributions?: WellBillDistributionOrderByRelationAggregateInput
  }

  export type FieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    name?: StringFilter<"Field"> | string
    location?: StringFilter<"Field"> | string
    size?: FloatFilter<"Field"> | number
    coordinates?: StringNullableFilter<"Field"> | string | null
    status?: StringFilter<"Field"> | string
    createdAt?: DateTimeFilter<"Field"> | Date | string
    updatedAt?: DateTimeFilter<"Field"> | Date | string
    seasonId?: StringNullableFilter<"Field"> | string | null
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    owners?: FieldOwnershipListRelationFilter
    workerAssignments?: FieldWorkerAssignmentListRelationFilter
    crops?: CropListRelationFilter
    fieldWells?: FieldWellListRelationFilter
    processingLogs?: ProcessingLogListRelationFilter
    processCosts?: ProcessCostListRelationFilter
    inventoryUsages?: InventoryUsageListRelationFilter
    processes?: ProcessListRelationFilter
    fieldExpenses?: FieldExpenseListRelationFilter
    notifications?: NotificationListRelationFilter
    irrigationFieldUsages?: IrrigationFieldUsageListRelationFilter
    wellBillDistributions?: WellBillDistributionListRelationFilter
  }, "id">

  export type FieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    size?: SortOrder
    coordinates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    _count?: FieldCountOrderByAggregateInput
    _avg?: FieldAvgOrderByAggregateInput
    _max?: FieldMaxOrderByAggregateInput
    _min?: FieldMinOrderByAggregateInput
    _sum?: FieldSumOrderByAggregateInput
  }

  export type FieldScalarWhereWithAggregatesInput = {
    AND?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    OR?: FieldScalarWhereWithAggregatesInput[]
    NOT?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Field"> | string
    name?: StringWithAggregatesFilter<"Field"> | string
    location?: StringWithAggregatesFilter<"Field"> | string
    size?: FloatWithAggregatesFilter<"Field"> | number
    coordinates?: StringNullableWithAggregatesFilter<"Field"> | string | null
    status?: StringWithAggregatesFilter<"Field"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    seasonId?: StringNullableWithAggregatesFilter<"Field"> | string | null
  }

  export type FieldOwnershipWhereInput = {
    AND?: FieldOwnershipWhereInput | FieldOwnershipWhereInput[]
    OR?: FieldOwnershipWhereInput[]
    NOT?: FieldOwnershipWhereInput | FieldOwnershipWhereInput[]
    id?: StringFilter<"FieldOwnership"> | string
    createdAt?: DateTimeFilter<"FieldOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"FieldOwnership"> | Date | string
    percentage?: FloatFilter<"FieldOwnership"> | number
    fieldId?: StringFilter<"FieldOwnership"> | string
    userId?: StringFilter<"FieldOwnership"> | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ownerExpenses?: FieldOwnerExpenseListRelationFilter
  }

  export type FieldOwnershipOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    percentage?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
    field?: FieldOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    ownerExpenses?: FieldOwnerExpenseOrderByRelationAggregateInput
  }

  export type FieldOwnershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fieldId_userId?: FieldOwnershipFieldIdUserIdCompoundUniqueInput
    AND?: FieldOwnershipWhereInput | FieldOwnershipWhereInput[]
    OR?: FieldOwnershipWhereInput[]
    NOT?: FieldOwnershipWhereInput | FieldOwnershipWhereInput[]
    createdAt?: DateTimeFilter<"FieldOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"FieldOwnership"> | Date | string
    percentage?: FloatFilter<"FieldOwnership"> | number
    fieldId?: StringFilter<"FieldOwnership"> | string
    userId?: StringFilter<"FieldOwnership"> | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ownerExpenses?: FieldOwnerExpenseListRelationFilter
  }, "id" | "fieldId_userId">

  export type FieldOwnershipOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    percentage?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
    _count?: FieldOwnershipCountOrderByAggregateInput
    _avg?: FieldOwnershipAvgOrderByAggregateInput
    _max?: FieldOwnershipMaxOrderByAggregateInput
    _min?: FieldOwnershipMinOrderByAggregateInput
    _sum?: FieldOwnershipSumOrderByAggregateInput
  }

  export type FieldOwnershipScalarWhereWithAggregatesInput = {
    AND?: FieldOwnershipScalarWhereWithAggregatesInput | FieldOwnershipScalarWhereWithAggregatesInput[]
    OR?: FieldOwnershipScalarWhereWithAggregatesInput[]
    NOT?: FieldOwnershipScalarWhereWithAggregatesInput | FieldOwnershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldOwnership"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FieldOwnership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FieldOwnership"> | Date | string
    percentage?: FloatWithAggregatesFilter<"FieldOwnership"> | number
    fieldId?: StringWithAggregatesFilter<"FieldOwnership"> | string
    userId?: StringWithAggregatesFilter<"FieldOwnership"> | string
  }

  export type FieldWorkerAssignmentWhereInput = {
    AND?: FieldWorkerAssignmentWhereInput | FieldWorkerAssignmentWhereInput[]
    OR?: FieldWorkerAssignmentWhereInput[]
    NOT?: FieldWorkerAssignmentWhereInput | FieldWorkerAssignmentWhereInput[]
    id?: StringFilter<"FieldWorkerAssignment"> | string
    createdAt?: DateTimeFilter<"FieldWorkerAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"FieldWorkerAssignment"> | Date | string
    fieldId?: StringFilter<"FieldWorkerAssignment"> | string
    userId?: StringFilter<"FieldWorkerAssignment"> | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FieldWorkerAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
    field?: FieldOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FieldWorkerAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fieldId_userId?: FieldWorkerAssignmentFieldIdUserIdCompoundUniqueInput
    AND?: FieldWorkerAssignmentWhereInput | FieldWorkerAssignmentWhereInput[]
    OR?: FieldWorkerAssignmentWhereInput[]
    NOT?: FieldWorkerAssignmentWhereInput | FieldWorkerAssignmentWhereInput[]
    createdAt?: DateTimeFilter<"FieldWorkerAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"FieldWorkerAssignment"> | Date | string
    fieldId?: StringFilter<"FieldWorkerAssignment"> | string
    userId?: StringFilter<"FieldWorkerAssignment"> | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "fieldId_userId">

  export type FieldWorkerAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
    _count?: FieldWorkerAssignmentCountOrderByAggregateInput
    _max?: FieldWorkerAssignmentMaxOrderByAggregateInput
    _min?: FieldWorkerAssignmentMinOrderByAggregateInput
  }

  export type FieldWorkerAssignmentScalarWhereWithAggregatesInput = {
    AND?: FieldWorkerAssignmentScalarWhereWithAggregatesInput | FieldWorkerAssignmentScalarWhereWithAggregatesInput[]
    OR?: FieldWorkerAssignmentScalarWhereWithAggregatesInput[]
    NOT?: FieldWorkerAssignmentScalarWhereWithAggregatesInput | FieldWorkerAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldWorkerAssignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FieldWorkerAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FieldWorkerAssignment"> | Date | string
    fieldId?: StringWithAggregatesFilter<"FieldWorkerAssignment"> | string
    userId?: StringWithAggregatesFilter<"FieldWorkerAssignment"> | string
  }

  export type FieldWellWhereInput = {
    AND?: FieldWellWhereInput | FieldWellWhereInput[]
    OR?: FieldWellWhereInput[]
    NOT?: FieldWellWhereInput | FieldWellWhereInput[]
    id?: StringFilter<"FieldWell"> | string
    fieldId?: StringFilter<"FieldWell"> | string
    wellId?: StringFilter<"FieldWell"> | string
    createdAt?: DateTimeFilter<"FieldWell"> | Date | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
  }

  export type FieldWellOrderByWithRelationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    wellId?: SortOrder
    createdAt?: SortOrder
    field?: FieldOrderByWithRelationInput
    well?: WellOrderByWithRelationInput
  }

  export type FieldWellWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fieldId_wellId?: FieldWellFieldIdWellIdCompoundUniqueInput
    AND?: FieldWellWhereInput | FieldWellWhereInput[]
    OR?: FieldWellWhereInput[]
    NOT?: FieldWellWhereInput | FieldWellWhereInput[]
    fieldId?: StringFilter<"FieldWell"> | string
    wellId?: StringFilter<"FieldWell"> | string
    createdAt?: DateTimeFilter<"FieldWell"> | Date | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
  }, "id" | "fieldId_wellId">

  export type FieldWellOrderByWithAggregationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    wellId?: SortOrder
    createdAt?: SortOrder
    _count?: FieldWellCountOrderByAggregateInput
    _max?: FieldWellMaxOrderByAggregateInput
    _min?: FieldWellMinOrderByAggregateInput
  }

  export type FieldWellScalarWhereWithAggregatesInput = {
    AND?: FieldWellScalarWhereWithAggregatesInput | FieldWellScalarWhereWithAggregatesInput[]
    OR?: FieldWellScalarWhereWithAggregatesInput[]
    NOT?: FieldWellScalarWhereWithAggregatesInput | FieldWellScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldWell"> | string
    fieldId?: StringWithAggregatesFilter<"FieldWell"> | string
    wellId?: StringWithAggregatesFilter<"FieldWell"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FieldWell"> | Date | string
  }

  export type WorkerWellAssignmentWhereInput = {
    AND?: WorkerWellAssignmentWhereInput | WorkerWellAssignmentWhereInput[]
    OR?: WorkerWellAssignmentWhereInput[]
    NOT?: WorkerWellAssignmentWhereInput | WorkerWellAssignmentWhereInput[]
    id?: StringFilter<"WorkerWellAssignment"> | string
    createdAt?: DateTimeFilter<"WorkerWellAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"WorkerWellAssignment"> | Date | string
    workerId?: StringFilter<"WorkerWellAssignment"> | string
    wellId?: StringFilter<"WorkerWellAssignment"> | string
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
  }

  export type WorkerWellAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workerId?: SortOrder
    wellId?: SortOrder
    worker?: UserOrderByWithRelationInput
    well?: WellOrderByWithRelationInput
  }

  export type WorkerWellAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workerId_wellId?: WorkerWellAssignmentWorkerIdWellIdCompoundUniqueInput
    AND?: WorkerWellAssignmentWhereInput | WorkerWellAssignmentWhereInput[]
    OR?: WorkerWellAssignmentWhereInput[]
    NOT?: WorkerWellAssignmentWhereInput | WorkerWellAssignmentWhereInput[]
    createdAt?: DateTimeFilter<"WorkerWellAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"WorkerWellAssignment"> | Date | string
    workerId?: StringFilter<"WorkerWellAssignment"> | string
    wellId?: StringFilter<"WorkerWellAssignment"> | string
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
  }, "id" | "workerId_wellId">

  export type WorkerWellAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workerId?: SortOrder
    wellId?: SortOrder
    _count?: WorkerWellAssignmentCountOrderByAggregateInput
    _max?: WorkerWellAssignmentMaxOrderByAggregateInput
    _min?: WorkerWellAssignmentMinOrderByAggregateInput
  }

  export type WorkerWellAssignmentScalarWhereWithAggregatesInput = {
    AND?: WorkerWellAssignmentScalarWhereWithAggregatesInput | WorkerWellAssignmentScalarWhereWithAggregatesInput[]
    OR?: WorkerWellAssignmentScalarWhereWithAggregatesInput[]
    NOT?: WorkerWellAssignmentScalarWhereWithAggregatesInput | WorkerWellAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkerWellAssignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkerWellAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkerWellAssignment"> | Date | string
    workerId?: StringWithAggregatesFilter<"WorkerWellAssignment"> | string
    wellId?: StringWithAggregatesFilter<"WorkerWellAssignment"> | string
  }

  export type WellWhereInput = {
    AND?: WellWhereInput | WellWhereInput[]
    OR?: WellWhereInput[]
    NOT?: WellWhereInput | WellWhereInput[]
    id?: StringFilter<"Well"> | string
    name?: StringFilter<"Well"> | string
    depth?: FloatFilter<"Well"> | number
    capacity?: FloatFilter<"Well"> | number
    status?: StringFilter<"Well"> | string
    createdAt?: DateTimeFilter<"Well"> | Date | string
    updatedAt?: DateTimeFilter<"Well"> | Date | string
    fieldWells?: FieldWellListRelationFilter
    notifications?: NotificationListRelationFilter
    irrigationLogs?: IrrigationLogListRelationFilter
    wellBillingPeriods?: WellBillingPeriodListRelationFilter
    workerAssignments?: WorkerWellAssignmentListRelationFilter
  }

  export type WellOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldWells?: FieldWellOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    irrigationLogs?: IrrigationLogOrderByRelationAggregateInput
    wellBillingPeriods?: WellBillingPeriodOrderByRelationAggregateInput
    workerAssignments?: WorkerWellAssignmentOrderByRelationAggregateInput
  }

  export type WellWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WellWhereInput | WellWhereInput[]
    OR?: WellWhereInput[]
    NOT?: WellWhereInput | WellWhereInput[]
    name?: StringFilter<"Well"> | string
    depth?: FloatFilter<"Well"> | number
    capacity?: FloatFilter<"Well"> | number
    status?: StringFilter<"Well"> | string
    createdAt?: DateTimeFilter<"Well"> | Date | string
    updatedAt?: DateTimeFilter<"Well"> | Date | string
    fieldWells?: FieldWellListRelationFilter
    notifications?: NotificationListRelationFilter
    irrigationLogs?: IrrigationLogListRelationFilter
    wellBillingPeriods?: WellBillingPeriodListRelationFilter
    workerAssignments?: WorkerWellAssignmentListRelationFilter
  }, "id">

  export type WellOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WellCountOrderByAggregateInput
    _avg?: WellAvgOrderByAggregateInput
    _max?: WellMaxOrderByAggregateInput
    _min?: WellMinOrderByAggregateInput
    _sum?: WellSumOrderByAggregateInput
  }

  export type WellScalarWhereWithAggregatesInput = {
    AND?: WellScalarWhereWithAggregatesInput | WellScalarWhereWithAggregatesInput[]
    OR?: WellScalarWhereWithAggregatesInput[]
    NOT?: WellScalarWhereWithAggregatesInput | WellScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Well"> | string
    name?: StringWithAggregatesFilter<"Well"> | string
    depth?: FloatWithAggregatesFilter<"Well"> | number
    capacity?: FloatWithAggregatesFilter<"Well"> | number
    status?: StringWithAggregatesFilter<"Well"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Well"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Well"> | Date | string
  }

  export type CropWhereInput = {
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    id?: StringFilter<"Crop"> | string
    name?: StringFilter<"Crop"> | string
    plantedDate?: DateTimeFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableFilter<"Crop"> | Date | string | null
    status?: EnumCropStatusFilter<"Crop"> | $Enums.CropStatus
    notes?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    seasonId?: StringNullableFilter<"Crop"> | string | null
    fieldId?: StringFilter<"Crop"> | string
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type CropOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plantedDate?: SortOrder
    harvestDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    fieldId?: SortOrder
    season?: SeasonOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CropWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CropWhereInput | CropWhereInput[]
    OR?: CropWhereInput[]
    NOT?: CropWhereInput | CropWhereInput[]
    name?: StringFilter<"Crop"> | string
    plantedDate?: DateTimeFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableFilter<"Crop"> | Date | string | null
    status?: EnumCropStatusFilter<"Crop"> | $Enums.CropStatus
    notes?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    seasonId?: StringNullableFilter<"Crop"> | string | null
    fieldId?: StringFilter<"Crop"> | string
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type CropOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plantedDate?: SortOrder
    harvestDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    fieldId?: SortOrder
    _count?: CropCountOrderByAggregateInput
    _max?: CropMaxOrderByAggregateInput
    _min?: CropMinOrderByAggregateInput
  }

  export type CropScalarWhereWithAggregatesInput = {
    AND?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    OR?: CropScalarWhereWithAggregatesInput[]
    NOT?: CropScalarWhereWithAggregatesInput | CropScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crop"> | string
    name?: StringWithAggregatesFilter<"Crop"> | string
    plantedDate?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableWithAggregatesFilter<"Crop"> | Date | string | null
    status?: EnumCropStatusWithAggregatesFilter<"Crop"> | $Enums.CropStatus
    notes?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Crop"> | Date | string
    seasonId?: StringNullableWithAggregatesFilter<"Crop"> | string | null
    fieldId?: StringWithAggregatesFilter<"Crop"> | string
  }

  export type ProcessingLogWhereInput = {
    AND?: ProcessingLogWhereInput | ProcessingLogWhereInput[]
    OR?: ProcessingLogWhereInput[]
    NOT?: ProcessingLogWhereInput | ProcessingLogWhereInput[]
    id?: StringFilter<"ProcessingLog"> | string
    date?: DateTimeFilter<"ProcessingLog"> | Date | string
    processType?: EnumProcessTypeFilter<"ProcessingLog"> | $Enums.ProcessType
    equipment?: StringNullableFilter<"ProcessingLog"> | string | null
    duration?: FloatFilter<"ProcessingLog"> | number
    notes?: StringNullableFilter<"ProcessingLog"> | string | null
    createdAt?: DateTimeFilter<"ProcessingLog"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingLog"> | Date | string
    fieldId?: StringFilter<"ProcessingLog"> | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type ProcessingLogOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    processType?: SortOrder
    equipment?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    field?: FieldOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type ProcessingLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessingLogWhereInput | ProcessingLogWhereInput[]
    OR?: ProcessingLogWhereInput[]
    NOT?: ProcessingLogWhereInput | ProcessingLogWhereInput[]
    date?: DateTimeFilter<"ProcessingLog"> | Date | string
    processType?: EnumProcessTypeFilter<"ProcessingLog"> | $Enums.ProcessType
    equipment?: StringNullableFilter<"ProcessingLog"> | string | null
    duration?: FloatFilter<"ProcessingLog"> | number
    notes?: StringNullableFilter<"ProcessingLog"> | string | null
    createdAt?: DateTimeFilter<"ProcessingLog"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingLog"> | Date | string
    fieldId?: StringFilter<"ProcessingLog"> | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type ProcessingLogOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    processType?: SortOrder
    equipment?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    _count?: ProcessingLogCountOrderByAggregateInput
    _avg?: ProcessingLogAvgOrderByAggregateInput
    _max?: ProcessingLogMaxOrderByAggregateInput
    _min?: ProcessingLogMinOrderByAggregateInput
    _sum?: ProcessingLogSumOrderByAggregateInput
  }

  export type ProcessingLogScalarWhereWithAggregatesInput = {
    AND?: ProcessingLogScalarWhereWithAggregatesInput | ProcessingLogScalarWhereWithAggregatesInput[]
    OR?: ProcessingLogScalarWhereWithAggregatesInput[]
    NOT?: ProcessingLogScalarWhereWithAggregatesInput | ProcessingLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessingLog"> | string
    date?: DateTimeWithAggregatesFilter<"ProcessingLog"> | Date | string
    processType?: EnumProcessTypeWithAggregatesFilter<"ProcessingLog"> | $Enums.ProcessType
    equipment?: StringNullableWithAggregatesFilter<"ProcessingLog"> | string | null
    duration?: FloatWithAggregatesFilter<"ProcessingLog"> | number
    notes?: StringNullableWithAggregatesFilter<"ProcessingLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProcessingLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessingLog"> | Date | string
    fieldId?: StringWithAggregatesFilter<"ProcessingLog"> | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    category?: EnumInventoryCategoryFilter<"Inventory"> | $Enums.InventoryCategory
    totalQuantity?: FloatFilter<"Inventory"> | number
    unit?: EnumUnitFilter<"Inventory"> | $Enums.Unit
    totalStock?: FloatNullableFilter<"Inventory"> | number | null
    purchaseDate?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    status?: EnumInventoryStatusFilter<"Inventory"> | $Enums.InventoryStatus
    costPrice?: FloatNullableFilter<"Inventory"> | number | null
    notes?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    ownerships?: InventoryOwnershipListRelationFilter
    usages?: InventoryUsageListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    notifications?: NotificationListRelationFilter
    irrigationInventoryUsages?: IrrigationInventoryUsageListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    totalQuantity?: SortOrder
    unit?: SortOrder
    totalStock?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    costPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerships?: InventoryOwnershipOrderByRelationAggregateInput
    usages?: InventoryUsageOrderByRelationAggregateInput
    inventoryTransactions?: InventoryTransactionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    irrigationInventoryUsages?: IrrigationInventoryUsageOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    name?: StringFilter<"Inventory"> | string
    category?: EnumInventoryCategoryFilter<"Inventory"> | $Enums.InventoryCategory
    totalQuantity?: FloatFilter<"Inventory"> | number
    unit?: EnumUnitFilter<"Inventory"> | $Enums.Unit
    totalStock?: FloatNullableFilter<"Inventory"> | number | null
    purchaseDate?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    status?: EnumInventoryStatusFilter<"Inventory"> | $Enums.InventoryStatus
    costPrice?: FloatNullableFilter<"Inventory"> | number | null
    notes?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    ownerships?: InventoryOwnershipListRelationFilter
    usages?: InventoryUsageListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    notifications?: NotificationListRelationFilter
    irrigationInventoryUsages?: IrrigationInventoryUsageListRelationFilter
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    totalQuantity?: SortOrder
    unit?: SortOrder
    totalStock?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    costPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    category?: EnumInventoryCategoryWithAggregatesFilter<"Inventory"> | $Enums.InventoryCategory
    totalQuantity?: FloatWithAggregatesFilter<"Inventory"> | number
    unit?: EnumUnitWithAggregatesFilter<"Inventory"> | $Enums.Unit
    totalStock?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    status?: EnumInventoryStatusWithAggregatesFilter<"Inventory"> | $Enums.InventoryStatus
    costPrice?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type InventoryOwnershipWhereInput = {
    AND?: InventoryOwnershipWhereInput | InventoryOwnershipWhereInput[]
    OR?: InventoryOwnershipWhereInput[]
    NOT?: InventoryOwnershipWhereInput | InventoryOwnershipWhereInput[]
    id?: StringFilter<"InventoryOwnership"> | string
    inventoryId?: StringFilter<"InventoryOwnership"> | string
    userId?: StringFilter<"InventoryOwnership"> | string
    shareQuantity?: FloatFilter<"InventoryOwnership"> | number
    createdAt?: DateTimeFilter<"InventoryOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryOwnership"> | Date | string
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventoryOwnershipOrderByWithRelationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    userId?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventory?: InventoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InventoryOwnershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryOwnershipWhereInput | InventoryOwnershipWhereInput[]
    OR?: InventoryOwnershipWhereInput[]
    NOT?: InventoryOwnershipWhereInput | InventoryOwnershipWhereInput[]
    inventoryId?: StringFilter<"InventoryOwnership"> | string
    userId?: StringFilter<"InventoryOwnership"> | string
    shareQuantity?: FloatFilter<"InventoryOwnership"> | number
    createdAt?: DateTimeFilter<"InventoryOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryOwnership"> | Date | string
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryOwnershipOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    userId?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryOwnershipCountOrderByAggregateInput
    _avg?: InventoryOwnershipAvgOrderByAggregateInput
    _max?: InventoryOwnershipMaxOrderByAggregateInput
    _min?: InventoryOwnershipMinOrderByAggregateInput
    _sum?: InventoryOwnershipSumOrderByAggregateInput
  }

  export type InventoryOwnershipScalarWhereWithAggregatesInput = {
    AND?: InventoryOwnershipScalarWhereWithAggregatesInput | InventoryOwnershipScalarWhereWithAggregatesInput[]
    OR?: InventoryOwnershipScalarWhereWithAggregatesInput[]
    NOT?: InventoryOwnershipScalarWhereWithAggregatesInput | InventoryOwnershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryOwnership"> | string
    inventoryId?: StringWithAggregatesFilter<"InventoryOwnership"> | string
    userId?: StringWithAggregatesFilter<"InventoryOwnership"> | string
    shareQuantity?: FloatWithAggregatesFilter<"InventoryOwnership"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InventoryOwnership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryOwnership"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    product?: StringFilter<"Purchase"> | string
    category?: EnumProductCategoryFilter<"Purchase"> | $Enums.ProductCategory
    quantity?: FloatFilter<"Purchase"> | number
    unit?: EnumUnitFilter<"Purchase"> | $Enums.Unit
    unitPrice?: FloatFilter<"Purchase"> | number
    totalCost?: FloatFilter<"Purchase"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Purchase"> | $Enums.PaymentMethod
    creditorPaymentDueDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    description?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    isTemplate?: BoolFilter<"Purchase"> | boolean
    templateName?: StringNullableFilter<"Purchase"> | string | null
    approvalStatus?: EnumApprovalStatusFilter<"Purchase"> | $Enums.ApprovalStatus
    approvalRequired?: BoolFilter<"Purchase"> | boolean
    approvalThreshold?: FloatFilter<"Purchase"> | number
    seasonId?: StringNullableFilter<"Purchase"> | string | null
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    contributors?: PurchaseContributorListRelationFilter
    debts?: DebtListRelationFilter
    invoices?: InvoiceListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    approvals?: PurchaseApprovalListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    paymentMethod?: SortOrder
    creditorPaymentDueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    isTemplate?: SortOrder
    templateName?: SortOrder
    approvalStatus?: SortOrder
    approvalRequired?: SortOrder
    approvalThreshold?: SortOrder
    seasonId?: SortOrder
    season?: SeasonOrderByWithRelationInput
    contributors?: PurchaseContributorOrderByRelationAggregateInput
    debts?: DebtOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    inventoryTransactions?: InventoryTransactionOrderByRelationAggregateInput
    approvals?: PurchaseApprovalOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    product?: StringFilter<"Purchase"> | string
    category?: EnumProductCategoryFilter<"Purchase"> | $Enums.ProductCategory
    quantity?: FloatFilter<"Purchase"> | number
    unit?: EnumUnitFilter<"Purchase"> | $Enums.Unit
    unitPrice?: FloatFilter<"Purchase"> | number
    totalCost?: FloatFilter<"Purchase"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Purchase"> | $Enums.PaymentMethod
    creditorPaymentDueDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    description?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    isTemplate?: BoolFilter<"Purchase"> | boolean
    templateName?: StringNullableFilter<"Purchase"> | string | null
    approvalStatus?: EnumApprovalStatusFilter<"Purchase"> | $Enums.ApprovalStatus
    approvalRequired?: BoolFilter<"Purchase"> | boolean
    approvalThreshold?: FloatFilter<"Purchase"> | number
    seasonId?: StringNullableFilter<"Purchase"> | string | null
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    contributors?: PurchaseContributorListRelationFilter
    debts?: DebtListRelationFilter
    invoices?: InvoiceListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    approvals?: PurchaseApprovalListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    paymentMethod?: SortOrder
    creditorPaymentDueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    isTemplate?: SortOrder
    templateName?: SortOrder
    approvalStatus?: SortOrder
    approvalRequired?: SortOrder
    approvalThreshold?: SortOrder
    seasonId?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    product?: StringWithAggregatesFilter<"Purchase"> | string
    category?: EnumProductCategoryWithAggregatesFilter<"Purchase"> | $Enums.ProductCategory
    quantity?: FloatWithAggregatesFilter<"Purchase"> | number
    unit?: EnumUnitWithAggregatesFilter<"Purchase"> | $Enums.Unit
    unitPrice?: FloatWithAggregatesFilter<"Purchase"> | number
    totalCost?: FloatWithAggregatesFilter<"Purchase"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Purchase"> | $Enums.PaymentMethod
    creditorPaymentDueDate?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Purchase"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    isTemplate?: BoolWithAggregatesFilter<"Purchase"> | boolean
    templateName?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    approvalStatus?: EnumApprovalStatusWithAggregatesFilter<"Purchase"> | $Enums.ApprovalStatus
    approvalRequired?: BoolWithAggregatesFilter<"Purchase"> | boolean
    approvalThreshold?: FloatWithAggregatesFilter<"Purchase"> | number
    seasonId?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
  }

  export type PurchaseApprovalWhereInput = {
    AND?: PurchaseApprovalWhereInput | PurchaseApprovalWhereInput[]
    OR?: PurchaseApprovalWhereInput[]
    NOT?: PurchaseApprovalWhereInput | PurchaseApprovalWhereInput[]
    id?: StringFilter<"PurchaseApproval"> | string
    purchaseId?: StringFilter<"PurchaseApproval"> | string
    approverId?: StringFilter<"PurchaseApproval"> | string
    status?: EnumApprovalStatusFilter<"PurchaseApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"PurchaseApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"PurchaseApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"PurchaseApproval"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseApproval"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    approver?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type PurchaseApprovalOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PurchaseApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseApprovalWhereInput | PurchaseApprovalWhereInput[]
    OR?: PurchaseApprovalWhereInput[]
    NOT?: PurchaseApprovalWhereInput | PurchaseApprovalWhereInput[]
    purchaseId?: StringFilter<"PurchaseApproval"> | string
    approverId?: StringFilter<"PurchaseApproval"> | string
    status?: EnumApprovalStatusFilter<"PurchaseApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"PurchaseApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"PurchaseApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"PurchaseApproval"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseApproval"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    approver?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PurchaseApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseApprovalCountOrderByAggregateInput
    _max?: PurchaseApprovalMaxOrderByAggregateInput
    _min?: PurchaseApprovalMinOrderByAggregateInput
  }

  export type PurchaseApprovalScalarWhereWithAggregatesInput = {
    AND?: PurchaseApprovalScalarWhereWithAggregatesInput | PurchaseApprovalScalarWhereWithAggregatesInput[]
    OR?: PurchaseApprovalScalarWhereWithAggregatesInput[]
    NOT?: PurchaseApprovalScalarWhereWithAggregatesInput | PurchaseApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseApproval"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchaseApproval"> | string
    approverId?: StringWithAggregatesFilter<"PurchaseApproval"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"PurchaseApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableWithAggregatesFilter<"PurchaseApproval"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseApproval"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseApproval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseApproval"> | Date | string
  }

  export type PurchaseContributorWhereInput = {
    AND?: PurchaseContributorWhereInput | PurchaseContributorWhereInput[]
    OR?: PurchaseContributorWhereInput[]
    NOT?: PurchaseContributorWhereInput | PurchaseContributorWhereInput[]
    id?: StringFilter<"PurchaseContributor"> | string
    purchaseId?: StringFilter<"PurchaseContributor"> | string
    userId?: StringFilter<"PurchaseContributor"> | string
    sharePercentage?: FloatFilter<"PurchaseContributor"> | number
    contribution?: FloatFilter<"PurchaseContributor"> | number
    expectedContribution?: FloatFilter<"PurchaseContributor"> | number
    actualContribution?: FloatFilter<"PurchaseContributor"> | number
    remainingAmount?: FloatNullableFilter<"PurchaseContributor"> | number | null
    hasPaid?: BoolFilter<"PurchaseContributor"> | boolean
    paymentDate?: DateTimeNullableFilter<"PurchaseContributor"> | Date | string | null
    isCreditor?: BoolFilter<"PurchaseContributor"> | boolean
    createdAt?: DateTimeFilter<"PurchaseContributor"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseContributor"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentHistory?: PaymentHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type PurchaseContributorOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
    hasPaid?: SortOrder
    paymentDate?: SortOrder
    isCreditor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    paymentHistory?: PaymentHistoryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PurchaseContributorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseContributorWhereInput | PurchaseContributorWhereInput[]
    OR?: PurchaseContributorWhereInput[]
    NOT?: PurchaseContributorWhereInput | PurchaseContributorWhereInput[]
    purchaseId?: StringFilter<"PurchaseContributor"> | string
    userId?: StringFilter<"PurchaseContributor"> | string
    sharePercentage?: FloatFilter<"PurchaseContributor"> | number
    contribution?: FloatFilter<"PurchaseContributor"> | number
    expectedContribution?: FloatFilter<"PurchaseContributor"> | number
    actualContribution?: FloatFilter<"PurchaseContributor"> | number
    remainingAmount?: FloatNullableFilter<"PurchaseContributor"> | number | null
    hasPaid?: BoolFilter<"PurchaseContributor"> | boolean
    paymentDate?: DateTimeNullableFilter<"PurchaseContributor"> | Date | string | null
    isCreditor?: BoolFilter<"PurchaseContributor"> | boolean
    createdAt?: DateTimeFilter<"PurchaseContributor"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseContributor"> | Date | string
    purchase?: XOR<PurchaseScalarRelationFilter, PurchaseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentHistory?: PaymentHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PurchaseContributorOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
    hasPaid?: SortOrder
    paymentDate?: SortOrder
    isCreditor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseContributorCountOrderByAggregateInput
    _avg?: PurchaseContributorAvgOrderByAggregateInput
    _max?: PurchaseContributorMaxOrderByAggregateInput
    _min?: PurchaseContributorMinOrderByAggregateInput
    _sum?: PurchaseContributorSumOrderByAggregateInput
  }

  export type PurchaseContributorScalarWhereWithAggregatesInput = {
    AND?: PurchaseContributorScalarWhereWithAggregatesInput | PurchaseContributorScalarWhereWithAggregatesInput[]
    OR?: PurchaseContributorScalarWhereWithAggregatesInput[]
    NOT?: PurchaseContributorScalarWhereWithAggregatesInput | PurchaseContributorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseContributor"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchaseContributor"> | string
    userId?: StringWithAggregatesFilter<"PurchaseContributor"> | string
    sharePercentage?: FloatWithAggregatesFilter<"PurchaseContributor"> | number
    contribution?: FloatWithAggregatesFilter<"PurchaseContributor"> | number
    expectedContribution?: FloatWithAggregatesFilter<"PurchaseContributor"> | number
    actualContribution?: FloatWithAggregatesFilter<"PurchaseContributor"> | number
    remainingAmount?: FloatNullableWithAggregatesFilter<"PurchaseContributor"> | number | null
    hasPaid?: BoolWithAggregatesFilter<"PurchaseContributor"> | boolean
    paymentDate?: DateTimeNullableWithAggregatesFilter<"PurchaseContributor"> | Date | string | null
    isCreditor?: BoolWithAggregatesFilter<"PurchaseContributor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseContributor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseContributor"> | Date | string
  }

  export type PaymentHistoryWhereInput = {
    AND?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    OR?: PaymentHistoryWhereInput[]
    NOT?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    id?: StringFilter<"PaymentHistory"> | string
    amount?: FloatFilter<"PaymentHistory"> | number
    paymentDate?: DateTimeFilter<"PaymentHistory"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"PaymentHistory"> | $Enums.PaymentMethod
    notes?: StringNullableFilter<"PaymentHistory"> | string | null
    createdAt?: DateTimeFilter<"PaymentHistory"> | Date | string
    debtId?: StringNullableFilter<"PaymentHistory"> | string | null
    contributorId?: StringNullableFilter<"PaymentHistory"> | string | null
    payerId?: StringFilter<"PaymentHistory"> | string
    receiverId?: StringFilter<"PaymentHistory"> | string
    debt?: XOR<DebtNullableScalarRelationFilter, DebtWhereInput> | null
    contributor?: XOR<PurchaseContributorNullableScalarRelationFilter, PurchaseContributorWhereInput> | null
    payer?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type PaymentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    contributorId?: SortOrder
    payerId?: SortOrder
    receiverId?: SortOrder
    debt?: DebtOrderByWithRelationInput
    contributor?: PurchaseContributorOrderByWithRelationInput
    payer?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PaymentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    OR?: PaymentHistoryWhereInput[]
    NOT?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    amount?: FloatFilter<"PaymentHistory"> | number
    paymentDate?: DateTimeFilter<"PaymentHistory"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"PaymentHistory"> | $Enums.PaymentMethod
    notes?: StringNullableFilter<"PaymentHistory"> | string | null
    createdAt?: DateTimeFilter<"PaymentHistory"> | Date | string
    debtId?: StringNullableFilter<"PaymentHistory"> | string | null
    contributorId?: StringNullableFilter<"PaymentHistory"> | string | null
    payerId?: StringFilter<"PaymentHistory"> | string
    receiverId?: StringFilter<"PaymentHistory"> | string
    debt?: XOR<DebtNullableScalarRelationFilter, DebtWhereInput> | null
    contributor?: XOR<PurchaseContributorNullableScalarRelationFilter, PurchaseContributorWhereInput> | null
    payer?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PaymentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    contributorId?: SortOrder
    payerId?: SortOrder
    receiverId?: SortOrder
    _count?: PaymentHistoryCountOrderByAggregateInput
    _avg?: PaymentHistoryAvgOrderByAggregateInput
    _max?: PaymentHistoryMaxOrderByAggregateInput
    _min?: PaymentHistoryMinOrderByAggregateInput
    _sum?: PaymentHistorySumOrderByAggregateInput
  }

  export type PaymentHistoryScalarWhereWithAggregatesInput = {
    AND?: PaymentHistoryScalarWhereWithAggregatesInput | PaymentHistoryScalarWhereWithAggregatesInput[]
    OR?: PaymentHistoryScalarWhereWithAggregatesInput[]
    NOT?: PaymentHistoryScalarWhereWithAggregatesInput | PaymentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentHistory"> | string
    amount?: FloatWithAggregatesFilter<"PaymentHistory"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"PaymentHistory"> | Date | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"PaymentHistory"> | $Enums.PaymentMethod
    notes?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentHistory"> | Date | string
    debtId?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    contributorId?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    payerId?: StringWithAggregatesFilter<"PaymentHistory"> | string
    receiverId?: StringWithAggregatesFilter<"PaymentHistory"> | string
  }

  export type InventoryTransactionWhereInput = {
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    type?: EnumTransactionTypeFilter<"InventoryTransaction"> | $Enums.TransactionType
    quantity?: FloatFilter<"InventoryTransaction"> | number
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    createdAt?: DateTimeFilter<"InventoryTransaction"> | Date | string
    seasonId?: StringNullableFilter<"InventoryTransaction"> | string | null
    inventoryId?: StringFilter<"InventoryTransaction"> | string
    purchaseId?: StringNullableFilter<"InventoryTransaction"> | string | null
    userId?: StringFilter<"InventoryTransaction"> | string
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type InventoryTransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    seasonId?: SortOrder
    inventoryId?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    season?: SeasonOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type InventoryTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"InventoryTransaction"> | $Enums.TransactionType
    quantity?: FloatFilter<"InventoryTransaction"> | number
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    createdAt?: DateTimeFilter<"InventoryTransaction"> | Date | string
    seasonId?: StringNullableFilter<"InventoryTransaction"> | string | null
    inventoryId?: StringFilter<"InventoryTransaction"> | string
    purchaseId?: StringNullableFilter<"InventoryTransaction"> | string | null
    userId?: StringFilter<"InventoryTransaction"> | string
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type InventoryTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    seasonId?: SortOrder
    inventoryId?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    _count?: InventoryTransactionCountOrderByAggregateInput
    _avg?: InventoryTransactionAvgOrderByAggregateInput
    _max?: InventoryTransactionMaxOrderByAggregateInput
    _min?: InventoryTransactionMinOrderByAggregateInput
    _sum?: InventoryTransactionSumOrderByAggregateInput
  }

  export type InventoryTransactionScalarWhereWithAggregatesInput = {
    AND?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    OR?: InventoryTransactionScalarWhereWithAggregatesInput[]
    NOT?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"InventoryTransaction"> | $Enums.TransactionType
    quantity?: FloatWithAggregatesFilter<"InventoryTransaction"> | number
    date?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
    seasonId?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    inventoryId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    purchaseId?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    userId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
  }

  export type DebtWhereInput = {
    AND?: DebtWhereInput | DebtWhereInput[]
    OR?: DebtWhereInput[]
    NOT?: DebtWhereInput | DebtWhereInput[]
    id?: StringFilter<"Debt"> | string
    amount?: FloatFilter<"Debt"> | number
    dueDate?: DateTimeFilter<"Debt"> | Date | string
    status?: EnumDebtStatusFilter<"Debt"> | $Enums.DebtStatus
    description?: StringNullableFilter<"Debt"> | string | null
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    paymentDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    reminderSent?: BoolFilter<"Debt"> | boolean
    lastReminderDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    reason?: StringNullableFilter<"Debt"> | string | null
    creditorId?: StringFilter<"Debt"> | string
    debtorId?: StringFilter<"Debt"> | string
    invoiceId?: StringNullableFilter<"Debt"> | string | null
    purchaseId?: StringNullableFilter<"Debt"> | string | null
    creditor?: XOR<UserScalarRelationFilter, UserWhereInput>
    debtor?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    paymentHistory?: PaymentHistoryListRelationFilter
    wellBillDistributions?: WellBillDistributionListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type DebtOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    paymentDate?: SortOrder
    reminderSent?: SortOrder
    lastReminderDate?: SortOrder
    reason?: SortOrder
    creditorId?: SortOrder
    debtorId?: SortOrder
    invoiceId?: SortOrder
    purchaseId?: SortOrder
    creditor?: UserOrderByWithRelationInput
    debtor?: UserOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    paymentHistory?: PaymentHistoryOrderByRelationAggregateInput
    wellBillDistributions?: WellBillDistributionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type DebtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtWhereInput | DebtWhereInput[]
    OR?: DebtWhereInput[]
    NOT?: DebtWhereInput | DebtWhereInput[]
    amount?: FloatFilter<"Debt"> | number
    dueDate?: DateTimeFilter<"Debt"> | Date | string
    status?: EnumDebtStatusFilter<"Debt"> | $Enums.DebtStatus
    description?: StringNullableFilter<"Debt"> | string | null
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    paymentDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    reminderSent?: BoolFilter<"Debt"> | boolean
    lastReminderDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    reason?: StringNullableFilter<"Debt"> | string | null
    creditorId?: StringFilter<"Debt"> | string
    debtorId?: StringFilter<"Debt"> | string
    invoiceId?: StringNullableFilter<"Debt"> | string | null
    purchaseId?: StringNullableFilter<"Debt"> | string | null
    creditor?: XOR<UserScalarRelationFilter, UserWhereInput>
    debtor?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    paymentHistory?: PaymentHistoryListRelationFilter
    wellBillDistributions?: WellBillDistributionListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type DebtOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    paymentDate?: SortOrder
    reminderSent?: SortOrder
    lastReminderDate?: SortOrder
    reason?: SortOrder
    creditorId?: SortOrder
    debtorId?: SortOrder
    invoiceId?: SortOrder
    purchaseId?: SortOrder
    _count?: DebtCountOrderByAggregateInput
    _avg?: DebtAvgOrderByAggregateInput
    _max?: DebtMaxOrderByAggregateInput
    _min?: DebtMinOrderByAggregateInput
    _sum?: DebtSumOrderByAggregateInput
  }

  export type DebtScalarWhereWithAggregatesInput = {
    AND?: DebtScalarWhereWithAggregatesInput | DebtScalarWhereWithAggregatesInput[]
    OR?: DebtScalarWhereWithAggregatesInput[]
    NOT?: DebtScalarWhereWithAggregatesInput | DebtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Debt"> | string
    amount?: FloatWithAggregatesFilter<"Debt"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Debt"> | Date | string
    status?: EnumDebtStatusWithAggregatesFilter<"Debt"> | $Enums.DebtStatus
    description?: StringNullableWithAggregatesFilter<"Debt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Debt"> | Date | string
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Debt"> | Date | string | null
    reminderSent?: BoolWithAggregatesFilter<"Debt"> | boolean
    lastReminderDate?: DateTimeNullableWithAggregatesFilter<"Debt"> | Date | string | null
    reason?: StringNullableWithAggregatesFilter<"Debt"> | string | null
    creditorId?: StringWithAggregatesFilter<"Debt"> | string
    debtorId?: StringWithAggregatesFilter<"Debt"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"Debt"> | string | null
    purchaseId?: StringNullableWithAggregatesFilter<"Debt"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    purchaserId?: StringFilter<"Invoice"> | string
    purchaseId?: StringNullableFilter<"Invoice"> | string | null
    purchaser?: XOR<UserScalarRelationFilter, UserWhereInput>
    debts?: DebtListRelationFilter
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaserId?: SortOrder
    purchaseId?: SortOrder
    purchaser?: UserOrderByWithRelationInput
    debts?: DebtOrderByRelationAggregateInput
    purchase?: PurchaseOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    amount?: FloatFilter<"Invoice"> | number
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    purchaserId?: StringFilter<"Invoice"> | string
    purchaseId?: StringNullableFilter<"Invoice"> | string | null
    purchaser?: XOR<UserScalarRelationFilter, UserWhereInput>
    debts?: DebtListRelationFilter
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id" | "number">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaserId?: SortOrder
    purchaseId?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    number?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    description?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    purchaserId?: StringWithAggregatesFilter<"Invoice"> | string
    purchaseId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type InventoryUsageWhereInput = {
    AND?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    OR?: InventoryUsageWhereInput[]
    NOT?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    id?: StringFilter<"InventoryUsage"> | string
    inventoryId?: StringFilter<"InventoryUsage"> | string
    usedQuantity?: FloatFilter<"InventoryUsage"> | number
    usageType?: EnumUsageTypeFilter<"InventoryUsage"> | $Enums.UsageType
    usedById?: StringFilter<"InventoryUsage"> | string
    fieldId?: StringNullableFilter<"InventoryUsage"> | string | null
    processId?: StringNullableFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeFilter<"InventoryUsage"> | Date | string
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    usedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    process?: XOR<ProcessNullableScalarRelationFilter, ProcessWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type InventoryUsageOrderByWithRelationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    usedQuantity?: SortOrder
    usageType?: SortOrder
    usedById?: SortOrder
    fieldId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    inventory?: InventoryOrderByWithRelationInput
    usedBy?: UserOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type InventoryUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    OR?: InventoryUsageWhereInput[]
    NOT?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    inventoryId?: StringFilter<"InventoryUsage"> | string
    usedQuantity?: FloatFilter<"InventoryUsage"> | number
    usageType?: EnumUsageTypeFilter<"InventoryUsage"> | $Enums.UsageType
    usedById?: StringFilter<"InventoryUsage"> | string
    fieldId?: StringNullableFilter<"InventoryUsage"> | string | null
    processId?: StringNullableFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeFilter<"InventoryUsage"> | Date | string
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    usedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    process?: XOR<ProcessNullableScalarRelationFilter, ProcessWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id">

  export type InventoryUsageOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    usedQuantity?: SortOrder
    usageType?: SortOrder
    usedById?: SortOrder
    fieldId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
    _count?: InventoryUsageCountOrderByAggregateInput
    _avg?: InventoryUsageAvgOrderByAggregateInput
    _max?: InventoryUsageMaxOrderByAggregateInput
    _min?: InventoryUsageMinOrderByAggregateInput
    _sum?: InventoryUsageSumOrderByAggregateInput
  }

  export type InventoryUsageScalarWhereWithAggregatesInput = {
    AND?: InventoryUsageScalarWhereWithAggregatesInput | InventoryUsageScalarWhereWithAggregatesInput[]
    OR?: InventoryUsageScalarWhereWithAggregatesInput[]
    NOT?: InventoryUsageScalarWhereWithAggregatesInput | InventoryUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryUsage"> | string
    inventoryId?: StringWithAggregatesFilter<"InventoryUsage"> | string
    usedQuantity?: FloatWithAggregatesFilter<"InventoryUsage"> | number
    usageType?: EnumUsageTypeWithAggregatesFilter<"InventoryUsage"> | $Enums.UsageType
    usedById?: StringWithAggregatesFilter<"InventoryUsage"> | string
    fieldId?: StringNullableWithAggregatesFilter<"InventoryUsage"> | string | null
    processId?: StringNullableWithAggregatesFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryUsage"> | Date | string
  }

  export type ProcessWhereInput = {
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    id?: StringFilter<"Process"> | string
    type?: EnumProcessTypeFilter<"Process"> | $Enums.ProcessType
    status?: EnumProcessStatusFilter<"Process"> | $Enums.ProcessStatus
    fieldId?: StringNullableFilter<"Process"> | string | null
    workerId?: StringFilter<"Process"> | string
    date?: DateTimeFilter<"Process"> | Date | string
    description?: StringNullableFilter<"Process"> | string | null
    totalArea?: FloatFilter<"Process"> | number
    processedArea?: FloatFilter<"Process"> | number
    processedPercentage?: FloatFilter<"Process"> | number
    seasonId?: StringNullableFilter<"Process"> | string | null
    inventoryDistribution?: JsonNullableFilter<"Process">
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    inventoryUsages?: InventoryUsageListRelationFilter
    equipmentUsages?: EquipmentUsageListRelationFilter
    processCosts?: ProcessCostListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type ProcessOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    fieldId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
    seasonId?: SortOrder
    inventoryDistribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    field?: FieldOrderByWithRelationInput
    worker?: UserOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    inventoryUsages?: InventoryUsageOrderByRelationAggregateInput
    equipmentUsages?: EquipmentUsageOrderByRelationAggregateInput
    processCosts?: ProcessCostOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type ProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    type?: EnumProcessTypeFilter<"Process"> | $Enums.ProcessType
    status?: EnumProcessStatusFilter<"Process"> | $Enums.ProcessStatus
    fieldId?: StringNullableFilter<"Process"> | string | null
    workerId?: StringFilter<"Process"> | string
    date?: DateTimeFilter<"Process"> | Date | string
    description?: StringNullableFilter<"Process"> | string | null
    totalArea?: FloatFilter<"Process"> | number
    processedArea?: FloatFilter<"Process"> | number
    processedPercentage?: FloatFilter<"Process"> | number
    seasonId?: StringNullableFilter<"Process"> | string | null
    inventoryDistribution?: JsonNullableFilter<"Process">
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    inventoryUsages?: InventoryUsageListRelationFilter
    equipmentUsages?: EquipmentUsageListRelationFilter
    processCosts?: ProcessCostListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type ProcessOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    fieldId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
    seasonId?: SortOrder
    inventoryDistribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessCountOrderByAggregateInput
    _avg?: ProcessAvgOrderByAggregateInput
    _max?: ProcessMaxOrderByAggregateInput
    _min?: ProcessMinOrderByAggregateInput
    _sum?: ProcessSumOrderByAggregateInput
  }

  export type ProcessScalarWhereWithAggregatesInput = {
    AND?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    OR?: ProcessScalarWhereWithAggregatesInput[]
    NOT?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Process"> | string
    type?: EnumProcessTypeWithAggregatesFilter<"Process"> | $Enums.ProcessType
    status?: EnumProcessStatusWithAggregatesFilter<"Process"> | $Enums.ProcessStatus
    fieldId?: StringNullableWithAggregatesFilter<"Process"> | string | null
    workerId?: StringWithAggregatesFilter<"Process"> | string
    date?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Process"> | string | null
    totalArea?: FloatWithAggregatesFilter<"Process"> | number
    processedArea?: FloatWithAggregatesFilter<"Process"> | number
    processedPercentage?: FloatWithAggregatesFilter<"Process"> | number
    seasonId?: StringNullableWithAggregatesFilter<"Process"> | string | null
    inventoryDistribution?: JsonNullableWithAggregatesFilter<"Process">
    createdAt?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Process"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    isRead?: BoolFilter<"Notification"> | boolean
    isArchived?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    targetRoles?: EnumRoleNullableListFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    receiverId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    processId?: StringNullableFilter<"Notification"> | string | null
    debtId?: StringNullableFilter<"Notification"> | string | null
    purchaseId?: StringNullableFilter<"Notification"> | string | null
    inventoryId?: StringNullableFilter<"Notification"> | string | null
    irrigationId?: StringNullableFilter<"Notification"> | string | null
    fieldId?: StringNullableFilter<"Notification"> | string | null
    seasonId?: StringNullableFilter<"Notification"> | string | null
    cropId?: StringNullableFilter<"Notification"> | string | null
    wellId?: StringNullableFilter<"Notification"> | string | null
    processingLogId?: StringNullableFilter<"Notification"> | string | null
    invoiceId?: StringNullableFilter<"Notification"> | string | null
    inventoryUsageId?: StringNullableFilter<"Notification"> | string | null
    transactionId?: StringNullableFilter<"Notification"> | string | null
    paymentId?: StringNullableFilter<"Notification"> | string | null
    contributorId?: StringNullableFilter<"Notification"> | string | null
    approvalId?: StringNullableFilter<"Notification"> | string | null
    equipmentId?: StringNullableFilter<"Notification"> | string | null
    equipmentUsageId?: StringNullableFilter<"Notification"> | string | null
    processCostId?: StringNullableFilter<"Notification"> | string | null
    fieldExpenseId?: StringNullableFilter<"Notification"> | string | null
    ownerExpenseId?: StringNullableFilter<"Notification"> | string | null
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    process?: XOR<ProcessNullableScalarRelationFilter, ProcessWhereInput> | null
    debt?: XOR<DebtNullableScalarRelationFilter, DebtWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    inventory?: XOR<InventoryNullableScalarRelationFilter, InventoryWhereInput> | null
    irrigation?: XOR<IrrigationLogNullableScalarRelationFilter, IrrigationLogWhereInput> | null
    field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    crop?: XOR<CropNullableScalarRelationFilter, CropWhereInput> | null
    well?: XOR<WellNullableScalarRelationFilter, WellWhereInput> | null
    processingLog?: XOR<ProcessingLogNullableScalarRelationFilter, ProcessingLogWhereInput> | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    inventoryUsage?: XOR<InventoryUsageNullableScalarRelationFilter, InventoryUsageWhereInput> | null
    transaction?: XOR<InventoryTransactionNullableScalarRelationFilter, InventoryTransactionWhereInput> | null
    payment?: XOR<PaymentHistoryNullableScalarRelationFilter, PaymentHistoryWhereInput> | null
    contributor?: XOR<PurchaseContributorNullableScalarRelationFilter, PurchaseContributorWhereInput> | null
    approval?: XOR<PurchaseApprovalNullableScalarRelationFilter, PurchaseApprovalWhereInput> | null
    equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    equipmentUsage?: XOR<EquipmentUsageNullableScalarRelationFilter, EquipmentUsageWhereInput> | null
    processCost?: XOR<ProcessCostNullableScalarRelationFilter, ProcessCostWhereInput> | null
    fieldExpense?: XOR<FieldExpenseNullableScalarRelationFilter, FieldExpenseWhereInput> | null
    ownerExpense?: XOR<FieldOwnerExpenseNullableScalarRelationFilter, FieldOwnerExpenseWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    link?: SortOrder
    expiresAt?: SortOrder
    targetRoles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiverId?: SortOrder
    senderId?: SortOrder
    processId?: SortOrder
    debtId?: SortOrder
    purchaseId?: SortOrder
    inventoryId?: SortOrder
    irrigationId?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    cropId?: SortOrder
    wellId?: SortOrder
    processingLogId?: SortOrder
    invoiceId?: SortOrder
    inventoryUsageId?: SortOrder
    transactionId?: SortOrder
    paymentId?: SortOrder
    contributorId?: SortOrder
    approvalId?: SortOrder
    equipmentId?: SortOrder
    equipmentUsageId?: SortOrder
    processCostId?: SortOrder
    fieldExpenseId?: SortOrder
    ownerExpenseId?: SortOrder
    receiver?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    debt?: DebtOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    irrigation?: IrrigationLogOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    crop?: CropOrderByWithRelationInput
    well?: WellOrderByWithRelationInput
    processingLog?: ProcessingLogOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    inventoryUsage?: InventoryUsageOrderByWithRelationInput
    transaction?: InventoryTransactionOrderByWithRelationInput
    payment?: PaymentHistoryOrderByWithRelationInput
    contributor?: PurchaseContributorOrderByWithRelationInput
    approval?: PurchaseApprovalOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
    equipmentUsage?: EquipmentUsageOrderByWithRelationInput
    processCost?: ProcessCostOrderByWithRelationInput
    fieldExpense?: FieldExpenseOrderByWithRelationInput
    ownerExpense?: FieldOwnerExpenseOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    isRead?: BoolFilter<"Notification"> | boolean
    isArchived?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    targetRoles?: EnumRoleNullableListFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    receiverId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    processId?: StringNullableFilter<"Notification"> | string | null
    debtId?: StringNullableFilter<"Notification"> | string | null
    purchaseId?: StringNullableFilter<"Notification"> | string | null
    inventoryId?: StringNullableFilter<"Notification"> | string | null
    irrigationId?: StringNullableFilter<"Notification"> | string | null
    fieldId?: StringNullableFilter<"Notification"> | string | null
    seasonId?: StringNullableFilter<"Notification"> | string | null
    cropId?: StringNullableFilter<"Notification"> | string | null
    wellId?: StringNullableFilter<"Notification"> | string | null
    processingLogId?: StringNullableFilter<"Notification"> | string | null
    invoiceId?: StringNullableFilter<"Notification"> | string | null
    inventoryUsageId?: StringNullableFilter<"Notification"> | string | null
    transactionId?: StringNullableFilter<"Notification"> | string | null
    paymentId?: StringNullableFilter<"Notification"> | string | null
    contributorId?: StringNullableFilter<"Notification"> | string | null
    approvalId?: StringNullableFilter<"Notification"> | string | null
    equipmentId?: StringNullableFilter<"Notification"> | string | null
    equipmentUsageId?: StringNullableFilter<"Notification"> | string | null
    processCostId?: StringNullableFilter<"Notification"> | string | null
    fieldExpenseId?: StringNullableFilter<"Notification"> | string | null
    ownerExpenseId?: StringNullableFilter<"Notification"> | string | null
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    process?: XOR<ProcessNullableScalarRelationFilter, ProcessWhereInput> | null
    debt?: XOR<DebtNullableScalarRelationFilter, DebtWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    inventory?: XOR<InventoryNullableScalarRelationFilter, InventoryWhereInput> | null
    irrigation?: XOR<IrrigationLogNullableScalarRelationFilter, IrrigationLogWhereInput> | null
    field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    crop?: XOR<CropNullableScalarRelationFilter, CropWhereInput> | null
    well?: XOR<WellNullableScalarRelationFilter, WellWhereInput> | null
    processingLog?: XOR<ProcessingLogNullableScalarRelationFilter, ProcessingLogWhereInput> | null
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    inventoryUsage?: XOR<InventoryUsageNullableScalarRelationFilter, InventoryUsageWhereInput> | null
    transaction?: XOR<InventoryTransactionNullableScalarRelationFilter, InventoryTransactionWhereInput> | null
    payment?: XOR<PaymentHistoryNullableScalarRelationFilter, PaymentHistoryWhereInput> | null
    contributor?: XOR<PurchaseContributorNullableScalarRelationFilter, PurchaseContributorWhereInput> | null
    approval?: XOR<PurchaseApprovalNullableScalarRelationFilter, PurchaseApprovalWhereInput> | null
    equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    equipmentUsage?: XOR<EquipmentUsageNullableScalarRelationFilter, EquipmentUsageWhereInput> | null
    processCost?: XOR<ProcessCostNullableScalarRelationFilter, ProcessCostWhereInput> | null
    fieldExpense?: XOR<FieldExpenseNullableScalarRelationFilter, FieldExpenseWhereInput> | null
    ownerExpense?: XOR<FieldOwnerExpenseNullableScalarRelationFilter, FieldOwnerExpenseWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    link?: SortOrder
    expiresAt?: SortOrder
    targetRoles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiverId?: SortOrder
    senderId?: SortOrder
    processId?: SortOrder
    debtId?: SortOrder
    purchaseId?: SortOrder
    inventoryId?: SortOrder
    irrigationId?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    cropId?: SortOrder
    wellId?: SortOrder
    processingLogId?: SortOrder
    invoiceId?: SortOrder
    inventoryUsageId?: SortOrder
    transactionId?: SortOrder
    paymentId?: SortOrder
    contributorId?: SortOrder
    approvalId?: SortOrder
    equipmentId?: SortOrder
    equipmentUsageId?: SortOrder
    processCostId?: SortOrder
    fieldExpenseId?: SortOrder
    ownerExpenseId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    isArchived?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    targetRoles?: EnumRoleNullableListFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    receiverId?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    processId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    debtId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    purchaseId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    inventoryId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    irrigationId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    fieldId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    seasonId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    cropId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    wellId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    processingLogId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    inventoryUsageId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    contributorId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    approvalId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    equipmentId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    equipmentUsageId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    processCostId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    fieldExpenseId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    ownerExpenseId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    emailNotifications?: BoolFilter<"NotificationPreference"> | boolean
    pushNotifications?: BoolFilter<"NotificationPreference"> | boolean
    inAppNotifications?: BoolFilter<"NotificationPreference"> | boolean
    dailyDigest?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnDebtReminders?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnPayments?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnProcessUpdates?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnInventoryAlerts?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnApprovals?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnIrrigation?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    inAppNotifications?: SortOrder
    dailyDigest?: SortOrder
    notifyOnDebtReminders?: SortOrder
    notifyOnPayments?: SortOrder
    notifyOnProcessUpdates?: SortOrder
    notifyOnInventoryAlerts?: SortOrder
    notifyOnApprovals?: SortOrder
    notifyOnIrrigation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    emailNotifications?: BoolFilter<"NotificationPreference"> | boolean
    pushNotifications?: BoolFilter<"NotificationPreference"> | boolean
    inAppNotifications?: BoolFilter<"NotificationPreference"> | boolean
    dailyDigest?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnDebtReminders?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnPayments?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnProcessUpdates?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnInventoryAlerts?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnApprovals?: BoolFilter<"NotificationPreference"> | boolean
    notifyOnIrrigation?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    inAppNotifications?: SortOrder
    dailyDigest?: SortOrder
    notifyOnDebtReminders?: SortOrder
    notifyOnPayments?: SortOrder
    notifyOnProcessUpdates?: SortOrder
    notifyOnInventoryAlerts?: SortOrder
    notifyOnApprovals?: SortOrder
    notifyOnIrrigation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    emailNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    pushNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inAppNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    dailyDigest?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    notifyOnDebtReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    notifyOnPayments?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    notifyOnProcessUpdates?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    notifyOnInventoryAlerts?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    notifyOnApprovals?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    notifyOnIrrigation?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: EnumEquipmentTypeFilter<"Equipment"> | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFilter<"Equipment"> | number
    description?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    ownerships?: EquipmentOwnershipListRelationFilter
    capabilities?: EquipmentCapabilityListRelationFilter
    usages?: EquipmentUsageListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fuelConsumptionPerDecare?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerships?: EquipmentOwnershipOrderByRelationAggregateInput
    capabilities?: EquipmentCapabilityOrderByRelationAggregateInput
    usages?: EquipmentUsageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    name?: StringFilter<"Equipment"> | string
    type?: EnumEquipmentTypeFilter<"Equipment"> | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFilter<"Equipment"> | number
    description?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    ownerships?: EquipmentOwnershipListRelationFilter
    capabilities?: EquipmentCapabilityListRelationFilter
    usages?: EquipmentUsageListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fuelConsumptionPerDecare?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    type?: EnumEquipmentTypeWithAggregatesFilter<"Equipment"> | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatWithAggregatesFilter<"Equipment"> | number
    description?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusWithAggregatesFilter<"Equipment"> | $Enums.EquipmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
  }

  export type EquipmentOwnershipWhereInput = {
    AND?: EquipmentOwnershipWhereInput | EquipmentOwnershipWhereInput[]
    OR?: EquipmentOwnershipWhereInput[]
    NOT?: EquipmentOwnershipWhereInput | EquipmentOwnershipWhereInput[]
    id?: StringFilter<"EquipmentOwnership"> | string
    equipmentId?: StringFilter<"EquipmentOwnership"> | string
    userId?: StringFilter<"EquipmentOwnership"> | string
    ownershipPercentage?: FloatFilter<"EquipmentOwnership"> | number
    createdAt?: DateTimeFilter<"EquipmentOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentOwnership"> | Date | string
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EquipmentOwnershipOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    ownershipPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EquipmentOwnershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    equipmentId_userId?: EquipmentOwnershipEquipmentIdUserIdCompoundUniqueInput
    AND?: EquipmentOwnershipWhereInput | EquipmentOwnershipWhereInput[]
    OR?: EquipmentOwnershipWhereInput[]
    NOT?: EquipmentOwnershipWhereInput | EquipmentOwnershipWhereInput[]
    equipmentId?: StringFilter<"EquipmentOwnership"> | string
    userId?: StringFilter<"EquipmentOwnership"> | string
    ownershipPercentage?: FloatFilter<"EquipmentOwnership"> | number
    createdAt?: DateTimeFilter<"EquipmentOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentOwnership"> | Date | string
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "equipmentId_userId">

  export type EquipmentOwnershipOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    ownershipPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentOwnershipCountOrderByAggregateInput
    _avg?: EquipmentOwnershipAvgOrderByAggregateInput
    _max?: EquipmentOwnershipMaxOrderByAggregateInput
    _min?: EquipmentOwnershipMinOrderByAggregateInput
    _sum?: EquipmentOwnershipSumOrderByAggregateInput
  }

  export type EquipmentOwnershipScalarWhereWithAggregatesInput = {
    AND?: EquipmentOwnershipScalarWhereWithAggregatesInput | EquipmentOwnershipScalarWhereWithAggregatesInput[]
    OR?: EquipmentOwnershipScalarWhereWithAggregatesInput[]
    NOT?: EquipmentOwnershipScalarWhereWithAggregatesInput | EquipmentOwnershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentOwnership"> | string
    equipmentId?: StringWithAggregatesFilter<"EquipmentOwnership"> | string
    userId?: StringWithAggregatesFilter<"EquipmentOwnership"> | string
    ownershipPercentage?: FloatWithAggregatesFilter<"EquipmentOwnership"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentOwnership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentOwnership"> | Date | string
  }

  export type EquipmentCapabilityWhereInput = {
    AND?: EquipmentCapabilityWhereInput | EquipmentCapabilityWhereInput[]
    OR?: EquipmentCapabilityWhereInput[]
    NOT?: EquipmentCapabilityWhereInput | EquipmentCapabilityWhereInput[]
    id?: StringFilter<"EquipmentCapability"> | string
    equipmentId?: StringFilter<"EquipmentCapability"> | string
    inventoryCategory?: EnumInventoryCategoryFilter<"EquipmentCapability"> | $Enums.InventoryCategory
    canUse?: BoolFilter<"EquipmentCapability"> | boolean
    createdAt?: DateTimeFilter<"EquipmentCapability"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentCapability"> | Date | string
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type EquipmentCapabilityOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    inventoryCategory?: SortOrder
    canUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type EquipmentCapabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    equipmentId_inventoryCategory?: EquipmentCapabilityEquipmentIdInventoryCategoryCompoundUniqueInput
    AND?: EquipmentCapabilityWhereInput | EquipmentCapabilityWhereInput[]
    OR?: EquipmentCapabilityWhereInput[]
    NOT?: EquipmentCapabilityWhereInput | EquipmentCapabilityWhereInput[]
    equipmentId?: StringFilter<"EquipmentCapability"> | string
    inventoryCategory?: EnumInventoryCategoryFilter<"EquipmentCapability"> | $Enums.InventoryCategory
    canUse?: BoolFilter<"EquipmentCapability"> | boolean
    createdAt?: DateTimeFilter<"EquipmentCapability"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentCapability"> | Date | string
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id" | "equipmentId_inventoryCategory">

  export type EquipmentCapabilityOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    inventoryCategory?: SortOrder
    canUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCapabilityCountOrderByAggregateInput
    _max?: EquipmentCapabilityMaxOrderByAggregateInput
    _min?: EquipmentCapabilityMinOrderByAggregateInput
  }

  export type EquipmentCapabilityScalarWhereWithAggregatesInput = {
    AND?: EquipmentCapabilityScalarWhereWithAggregatesInput | EquipmentCapabilityScalarWhereWithAggregatesInput[]
    OR?: EquipmentCapabilityScalarWhereWithAggregatesInput[]
    NOT?: EquipmentCapabilityScalarWhereWithAggregatesInput | EquipmentCapabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentCapability"> | string
    equipmentId?: StringWithAggregatesFilter<"EquipmentCapability"> | string
    inventoryCategory?: EnumInventoryCategoryWithAggregatesFilter<"EquipmentCapability"> | $Enums.InventoryCategory
    canUse?: BoolWithAggregatesFilter<"EquipmentCapability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentCapability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentCapability"> | Date | string
  }

  export type EquipmentUsageWhereInput = {
    AND?: EquipmentUsageWhereInput | EquipmentUsageWhereInput[]
    OR?: EquipmentUsageWhereInput[]
    NOT?: EquipmentUsageWhereInput | EquipmentUsageWhereInput[]
    id?: StringFilter<"EquipmentUsage"> | string
    processId?: StringFilter<"EquipmentUsage"> | string
    equipmentId?: StringFilter<"EquipmentUsage"> | string
    userId?: StringFilter<"EquipmentUsage"> | string
    areaProcessed?: FloatFilter<"EquipmentUsage"> | number
    processedPercentage?: FloatFilter<"EquipmentUsage"> | number
    fuelConsumed?: FloatFilter<"EquipmentUsage"> | number
    unit?: EnumUnitFilter<"EquipmentUsage"> | $Enums.Unit
    createdAt?: DateTimeFilter<"EquipmentUsage"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentUsage"> | Date | string
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type EquipmentUsageOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    process?: ProcessOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type EquipmentUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentUsageWhereInput | EquipmentUsageWhereInput[]
    OR?: EquipmentUsageWhereInput[]
    NOT?: EquipmentUsageWhereInput | EquipmentUsageWhereInput[]
    processId?: StringFilter<"EquipmentUsage"> | string
    equipmentId?: StringFilter<"EquipmentUsage"> | string
    userId?: StringFilter<"EquipmentUsage"> | string
    areaProcessed?: FloatFilter<"EquipmentUsage"> | number
    processedPercentage?: FloatFilter<"EquipmentUsage"> | number
    fuelConsumed?: FloatFilter<"EquipmentUsage"> | number
    unit?: EnumUnitFilter<"EquipmentUsage"> | $Enums.Unit
    createdAt?: DateTimeFilter<"EquipmentUsage"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentUsage"> | Date | string
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type EquipmentUsageOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentUsageCountOrderByAggregateInput
    _avg?: EquipmentUsageAvgOrderByAggregateInput
    _max?: EquipmentUsageMaxOrderByAggregateInput
    _min?: EquipmentUsageMinOrderByAggregateInput
    _sum?: EquipmentUsageSumOrderByAggregateInput
  }

  export type EquipmentUsageScalarWhereWithAggregatesInput = {
    AND?: EquipmentUsageScalarWhereWithAggregatesInput | EquipmentUsageScalarWhereWithAggregatesInput[]
    OR?: EquipmentUsageScalarWhereWithAggregatesInput[]
    NOT?: EquipmentUsageScalarWhereWithAggregatesInput | EquipmentUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentUsage"> | string
    processId?: StringWithAggregatesFilter<"EquipmentUsage"> | string
    equipmentId?: StringWithAggregatesFilter<"EquipmentUsage"> | string
    userId?: StringWithAggregatesFilter<"EquipmentUsage"> | string
    areaProcessed?: FloatWithAggregatesFilter<"EquipmentUsage"> | number
    processedPercentage?: FloatWithAggregatesFilter<"EquipmentUsage"> | number
    fuelConsumed?: FloatWithAggregatesFilter<"EquipmentUsage"> | number
    unit?: EnumUnitWithAggregatesFilter<"EquipmentUsage"> | $Enums.Unit
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentUsage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentUsage"> | Date | string
  }

  export type ProcessCostWhereInput = {
    AND?: ProcessCostWhereInput | ProcessCostWhereInput[]
    OR?: ProcessCostWhereInput[]
    NOT?: ProcessCostWhereInput | ProcessCostWhereInput[]
    id?: StringFilter<"ProcessCost"> | string
    processId?: StringFilter<"ProcessCost"> | string
    laborCost?: FloatFilter<"ProcessCost"> | number
    equipmentCost?: FloatFilter<"ProcessCost"> | number
    inventoryCost?: FloatFilter<"ProcessCost"> | number
    fuelCost?: FloatFilter<"ProcessCost"> | number
    totalCost?: FloatFilter<"ProcessCost"> | number
    createdAt?: DateTimeFilter<"ProcessCost"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessCost"> | Date | string
    fieldId?: StringFilter<"ProcessCost"> | string
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    ownerExpenses?: FieldOwnerExpenseListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type ProcessCostOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    process?: ProcessOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    ownerExpenses?: FieldOwnerExpenseOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type ProcessCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessCostWhereInput | ProcessCostWhereInput[]
    OR?: ProcessCostWhereInput[]
    NOT?: ProcessCostWhereInput | ProcessCostWhereInput[]
    processId?: StringFilter<"ProcessCost"> | string
    laborCost?: FloatFilter<"ProcessCost"> | number
    equipmentCost?: FloatFilter<"ProcessCost"> | number
    inventoryCost?: FloatFilter<"ProcessCost"> | number
    fuelCost?: FloatFilter<"ProcessCost"> | number
    totalCost?: FloatFilter<"ProcessCost"> | number
    createdAt?: DateTimeFilter<"ProcessCost"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessCost"> | Date | string
    fieldId?: StringFilter<"ProcessCost"> | string
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    ownerExpenses?: FieldOwnerExpenseListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type ProcessCostOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    _count?: ProcessCostCountOrderByAggregateInput
    _avg?: ProcessCostAvgOrderByAggregateInput
    _max?: ProcessCostMaxOrderByAggregateInput
    _min?: ProcessCostMinOrderByAggregateInput
    _sum?: ProcessCostSumOrderByAggregateInput
  }

  export type ProcessCostScalarWhereWithAggregatesInput = {
    AND?: ProcessCostScalarWhereWithAggregatesInput | ProcessCostScalarWhereWithAggregatesInput[]
    OR?: ProcessCostScalarWhereWithAggregatesInput[]
    NOT?: ProcessCostScalarWhereWithAggregatesInput | ProcessCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcessCost"> | string
    processId?: StringWithAggregatesFilter<"ProcessCost"> | string
    laborCost?: FloatWithAggregatesFilter<"ProcessCost"> | number
    equipmentCost?: FloatWithAggregatesFilter<"ProcessCost"> | number
    inventoryCost?: FloatWithAggregatesFilter<"ProcessCost"> | number
    fuelCost?: FloatWithAggregatesFilter<"ProcessCost"> | number
    totalCost?: FloatWithAggregatesFilter<"ProcessCost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProcessCost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessCost"> | Date | string
    fieldId?: StringWithAggregatesFilter<"ProcessCost"> | string
  }

  export type FieldExpenseWhereInput = {
    AND?: FieldExpenseWhereInput | FieldExpenseWhereInput[]
    OR?: FieldExpenseWhereInput[]
    NOT?: FieldExpenseWhereInput | FieldExpenseWhereInput[]
    id?: StringFilter<"FieldExpense"> | string
    fieldId?: StringFilter<"FieldExpense"> | string
    seasonId?: StringFilter<"FieldExpense"> | string
    totalCost?: FloatFilter<"FieldExpense"> | number
    description?: StringFilter<"FieldExpense"> | string
    expenseDate?: DateTimeFilter<"FieldExpense"> | Date | string
    sourceType?: StringFilter<"FieldExpense"> | string
    sourceId?: StringFilter<"FieldExpense"> | string
    createdAt?: DateTimeFilter<"FieldExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FieldExpense"> | Date | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type FieldExpenseOrderByWithRelationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    totalCost?: SortOrder
    description?: SortOrder
    expenseDate?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    field?: FieldOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type FieldExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FieldExpenseWhereInput | FieldExpenseWhereInput[]
    OR?: FieldExpenseWhereInput[]
    NOT?: FieldExpenseWhereInput | FieldExpenseWhereInput[]
    fieldId?: StringFilter<"FieldExpense"> | string
    seasonId?: StringFilter<"FieldExpense"> | string
    totalCost?: FloatFilter<"FieldExpense"> | number
    description?: StringFilter<"FieldExpense"> | string
    expenseDate?: DateTimeFilter<"FieldExpense"> | Date | string
    sourceType?: StringFilter<"FieldExpense"> | string
    sourceId?: StringFilter<"FieldExpense"> | string
    createdAt?: DateTimeFilter<"FieldExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FieldExpense"> | Date | string
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    season?: XOR<SeasonScalarRelationFilter, SeasonWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type FieldExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    totalCost?: SortOrder
    description?: SortOrder
    expenseDate?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FieldExpenseCountOrderByAggregateInput
    _avg?: FieldExpenseAvgOrderByAggregateInput
    _max?: FieldExpenseMaxOrderByAggregateInput
    _min?: FieldExpenseMinOrderByAggregateInput
    _sum?: FieldExpenseSumOrderByAggregateInput
  }

  export type FieldExpenseScalarWhereWithAggregatesInput = {
    AND?: FieldExpenseScalarWhereWithAggregatesInput | FieldExpenseScalarWhereWithAggregatesInput[]
    OR?: FieldExpenseScalarWhereWithAggregatesInput[]
    NOT?: FieldExpenseScalarWhereWithAggregatesInput | FieldExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldExpense"> | string
    fieldId?: StringWithAggregatesFilter<"FieldExpense"> | string
    seasonId?: StringWithAggregatesFilter<"FieldExpense"> | string
    totalCost?: FloatWithAggregatesFilter<"FieldExpense"> | number
    description?: StringWithAggregatesFilter<"FieldExpense"> | string
    expenseDate?: DateTimeWithAggregatesFilter<"FieldExpense"> | Date | string
    sourceType?: StringWithAggregatesFilter<"FieldExpense"> | string
    sourceId?: StringWithAggregatesFilter<"FieldExpense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FieldExpense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FieldExpense"> | Date | string
  }

  export type FieldOwnerExpenseWhereInput = {
    AND?: FieldOwnerExpenseWhereInput | FieldOwnerExpenseWhereInput[]
    OR?: FieldOwnerExpenseWhereInput[]
    NOT?: FieldOwnerExpenseWhereInput | FieldOwnerExpenseWhereInput[]
    id?: StringFilter<"FieldOwnerExpense"> | string
    fieldOwnershipId?: StringFilter<"FieldOwnerExpense"> | string
    processCostId?: StringFilter<"FieldOwnerExpense"> | string
    userId?: StringFilter<"FieldOwnerExpense"> | string
    amount?: FloatFilter<"FieldOwnerExpense"> | number
    percentage?: FloatFilter<"FieldOwnerExpense"> | number
    periodStart?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    periodEnd?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    createdAt?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    fieldOwnership?: XOR<FieldOwnershipScalarRelationFilter, FieldOwnershipWhereInput>
    processCost?: XOR<ProcessCostScalarRelationFilter, ProcessCostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type FieldOwnerExpenseOrderByWithRelationInput = {
    id?: SortOrder
    fieldOwnershipId?: SortOrder
    processCostId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldOwnership?: FieldOwnershipOrderByWithRelationInput
    processCost?: ProcessCostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type FieldOwnerExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FieldOwnerExpenseWhereInput | FieldOwnerExpenseWhereInput[]
    OR?: FieldOwnerExpenseWhereInput[]
    NOT?: FieldOwnerExpenseWhereInput | FieldOwnerExpenseWhereInput[]
    fieldOwnershipId?: StringFilter<"FieldOwnerExpense"> | string
    processCostId?: StringFilter<"FieldOwnerExpense"> | string
    userId?: StringFilter<"FieldOwnerExpense"> | string
    amount?: FloatFilter<"FieldOwnerExpense"> | number
    percentage?: FloatFilter<"FieldOwnerExpense"> | number
    periodStart?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    periodEnd?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    createdAt?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    fieldOwnership?: XOR<FieldOwnershipScalarRelationFilter, FieldOwnershipWhereInput>
    processCost?: XOR<ProcessCostScalarRelationFilter, ProcessCostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type FieldOwnerExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    fieldOwnershipId?: SortOrder
    processCostId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FieldOwnerExpenseCountOrderByAggregateInput
    _avg?: FieldOwnerExpenseAvgOrderByAggregateInput
    _max?: FieldOwnerExpenseMaxOrderByAggregateInput
    _min?: FieldOwnerExpenseMinOrderByAggregateInput
    _sum?: FieldOwnerExpenseSumOrderByAggregateInput
  }

  export type FieldOwnerExpenseScalarWhereWithAggregatesInput = {
    AND?: FieldOwnerExpenseScalarWhereWithAggregatesInput | FieldOwnerExpenseScalarWhereWithAggregatesInput[]
    OR?: FieldOwnerExpenseScalarWhereWithAggregatesInput[]
    NOT?: FieldOwnerExpenseScalarWhereWithAggregatesInput | FieldOwnerExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldOwnerExpense"> | string
    fieldOwnershipId?: StringWithAggregatesFilter<"FieldOwnerExpense"> | string
    processCostId?: StringWithAggregatesFilter<"FieldOwnerExpense"> | string
    userId?: StringWithAggregatesFilter<"FieldOwnerExpense"> | string
    amount?: FloatWithAggregatesFilter<"FieldOwnerExpense"> | number
    percentage?: FloatWithAggregatesFilter<"FieldOwnerExpense"> | number
    periodStart?: DateTimeWithAggregatesFilter<"FieldOwnerExpense"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"FieldOwnerExpense"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"FieldOwnerExpense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FieldOwnerExpense"> | Date | string
  }

  export type IrrigationLogWhereInput = {
    AND?: IrrigationLogWhereInput | IrrigationLogWhereInput[]
    OR?: IrrigationLogWhereInput[]
    NOT?: IrrigationLogWhereInput | IrrigationLogWhereInput[]
    id?: StringFilter<"IrrigationLog"> | string
    startDateTime?: DateTimeFilter<"IrrigationLog"> | Date | string
    duration?: FloatFilter<"IrrigationLog"> | number
    wellId?: StringFilter<"IrrigationLog"> | string
    notes?: StringNullableFilter<"IrrigationLog"> | string | null
    status?: StringFilter<"IrrigationLog"> | string
    createdBy?: StringFilter<"IrrigationLog"> | string
    createdAt?: DateTimeFilter<"IrrigationLog"> | Date | string
    updatedAt?: DateTimeFilter<"IrrigationLog"> | Date | string
    seasonId?: StringNullableFilter<"IrrigationLog"> | string | null
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    fieldUsages?: IrrigationFieldUsageListRelationFilter
    inventoryUsages?: IrrigationInventoryUsageListRelationFilter
    billingUsages?: WellBillingIrrigationUsageListRelationFilter
    ownerSummaries?: IrrigationOwnerSummaryListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type IrrigationLogOrderByWithRelationInput = {
    id?: SortOrder
    startDateTime?: SortOrder
    duration?: SortOrder
    wellId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    well?: WellOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    fieldUsages?: IrrigationFieldUsageOrderByRelationAggregateInput
    inventoryUsages?: IrrigationInventoryUsageOrderByRelationAggregateInput
    billingUsages?: WellBillingIrrigationUsageOrderByRelationAggregateInput
    ownerSummaries?: IrrigationOwnerSummaryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type IrrigationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IrrigationLogWhereInput | IrrigationLogWhereInput[]
    OR?: IrrigationLogWhereInput[]
    NOT?: IrrigationLogWhereInput | IrrigationLogWhereInput[]
    startDateTime?: DateTimeFilter<"IrrigationLog"> | Date | string
    duration?: FloatFilter<"IrrigationLog"> | number
    wellId?: StringFilter<"IrrigationLog"> | string
    notes?: StringNullableFilter<"IrrigationLog"> | string | null
    status?: StringFilter<"IrrigationLog"> | string
    createdBy?: StringFilter<"IrrigationLog"> | string
    createdAt?: DateTimeFilter<"IrrigationLog"> | Date | string
    updatedAt?: DateTimeFilter<"IrrigationLog"> | Date | string
    seasonId?: StringNullableFilter<"IrrigationLog"> | string | null
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    fieldUsages?: IrrigationFieldUsageListRelationFilter
    inventoryUsages?: IrrigationInventoryUsageListRelationFilter
    billingUsages?: WellBillingIrrigationUsageListRelationFilter
    ownerSummaries?: IrrigationOwnerSummaryListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type IrrigationLogOrderByWithAggregationInput = {
    id?: SortOrder
    startDateTime?: SortOrder
    duration?: SortOrder
    wellId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    _count?: IrrigationLogCountOrderByAggregateInput
    _avg?: IrrigationLogAvgOrderByAggregateInput
    _max?: IrrigationLogMaxOrderByAggregateInput
    _min?: IrrigationLogMinOrderByAggregateInput
    _sum?: IrrigationLogSumOrderByAggregateInput
  }

  export type IrrigationLogScalarWhereWithAggregatesInput = {
    AND?: IrrigationLogScalarWhereWithAggregatesInput | IrrigationLogScalarWhereWithAggregatesInput[]
    OR?: IrrigationLogScalarWhereWithAggregatesInput[]
    NOT?: IrrigationLogScalarWhereWithAggregatesInput | IrrigationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationLog"> | string
    startDateTime?: DateTimeWithAggregatesFilter<"IrrigationLog"> | Date | string
    duration?: FloatWithAggregatesFilter<"IrrigationLog"> | number
    wellId?: StringWithAggregatesFilter<"IrrigationLog"> | string
    notes?: StringNullableWithAggregatesFilter<"IrrigationLog"> | string | null
    status?: StringWithAggregatesFilter<"IrrigationLog"> | string
    createdBy?: StringWithAggregatesFilter<"IrrigationLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IrrigationLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IrrigationLog"> | Date | string
    seasonId?: StringNullableWithAggregatesFilter<"IrrigationLog"> | string | null
  }

  export type IrrigationFieldUsageWhereInput = {
    AND?: IrrigationFieldUsageWhereInput | IrrigationFieldUsageWhereInput[]
    OR?: IrrigationFieldUsageWhereInput[]
    NOT?: IrrigationFieldUsageWhereInput | IrrigationFieldUsageWhereInput[]
    id?: StringFilter<"IrrigationFieldUsage"> | string
    irrigationLogId?: StringFilter<"IrrigationFieldUsage"> | string
    fieldId?: StringFilter<"IrrigationFieldUsage"> | string
    percentage?: FloatFilter<"IrrigationFieldUsage"> | number
    actualIrrigatedArea?: FloatNullableFilter<"IrrigationFieldUsage"> | number | null
    createdAt?: DateTimeFilter<"IrrigationFieldUsage"> | Date | string
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    ownerUsages?: IrrigationOwnerUsageListRelationFilter
  }

  export type IrrigationFieldUsageOrderByWithRelationInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    fieldId?: SortOrder
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
    createdAt?: SortOrder
    irrigationLog?: IrrigationLogOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    ownerUsages?: IrrigationOwnerUsageOrderByRelationAggregateInput
  }

  export type IrrigationFieldUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IrrigationFieldUsageWhereInput | IrrigationFieldUsageWhereInput[]
    OR?: IrrigationFieldUsageWhereInput[]
    NOT?: IrrigationFieldUsageWhereInput | IrrigationFieldUsageWhereInput[]
    irrigationLogId?: StringFilter<"IrrigationFieldUsage"> | string
    fieldId?: StringFilter<"IrrigationFieldUsage"> | string
    percentage?: FloatFilter<"IrrigationFieldUsage"> | number
    actualIrrigatedArea?: FloatNullableFilter<"IrrigationFieldUsage"> | number | null
    createdAt?: DateTimeFilter<"IrrigationFieldUsage"> | Date | string
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    ownerUsages?: IrrigationOwnerUsageListRelationFilter
  }, "id">

  export type IrrigationFieldUsageOrderByWithAggregationInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    fieldId?: SortOrder
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
    createdAt?: SortOrder
    _count?: IrrigationFieldUsageCountOrderByAggregateInput
    _avg?: IrrigationFieldUsageAvgOrderByAggregateInput
    _max?: IrrigationFieldUsageMaxOrderByAggregateInput
    _min?: IrrigationFieldUsageMinOrderByAggregateInput
    _sum?: IrrigationFieldUsageSumOrderByAggregateInput
  }

  export type IrrigationFieldUsageScalarWhereWithAggregatesInput = {
    AND?: IrrigationFieldUsageScalarWhereWithAggregatesInput | IrrigationFieldUsageScalarWhereWithAggregatesInput[]
    OR?: IrrigationFieldUsageScalarWhereWithAggregatesInput[]
    NOT?: IrrigationFieldUsageScalarWhereWithAggregatesInput | IrrigationFieldUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationFieldUsage"> | string
    irrigationLogId?: StringWithAggregatesFilter<"IrrigationFieldUsage"> | string
    fieldId?: StringWithAggregatesFilter<"IrrigationFieldUsage"> | string
    percentage?: FloatWithAggregatesFilter<"IrrigationFieldUsage"> | number
    actualIrrigatedArea?: FloatNullableWithAggregatesFilter<"IrrigationFieldUsage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"IrrigationFieldUsage"> | Date | string
  }

  export type IrrigationOwnerUsageWhereInput = {
    AND?: IrrigationOwnerUsageWhereInput | IrrigationOwnerUsageWhereInput[]
    OR?: IrrigationOwnerUsageWhereInput[]
    NOT?: IrrigationOwnerUsageWhereInput | IrrigationOwnerUsageWhereInput[]
    id?: StringFilter<"IrrigationOwnerUsage"> | string
    irrigationFieldUsageId?: StringFilter<"IrrigationOwnerUsage"> | string
    ownerId?: StringFilter<"IrrigationOwnerUsage"> | string
    ownershipPercentage?: FloatFilter<"IrrigationOwnerUsage"> | number
    usagePercentage?: FloatFilter<"IrrigationOwnerUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationOwnerUsage"> | Date | string
    irrigationFieldUsage?: XOR<IrrigationFieldUsageScalarRelationFilter, IrrigationFieldUsageWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IrrigationOwnerUsageOrderByWithRelationInput = {
    id?: SortOrder
    irrigationFieldUsageId?: SortOrder
    ownerId?: SortOrder
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
    createdAt?: SortOrder
    irrigationFieldUsage?: IrrigationFieldUsageOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type IrrigationOwnerUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IrrigationOwnerUsageWhereInput | IrrigationOwnerUsageWhereInput[]
    OR?: IrrigationOwnerUsageWhereInput[]
    NOT?: IrrigationOwnerUsageWhereInput | IrrigationOwnerUsageWhereInput[]
    irrigationFieldUsageId?: StringFilter<"IrrigationOwnerUsage"> | string
    ownerId?: StringFilter<"IrrigationOwnerUsage"> | string
    ownershipPercentage?: FloatFilter<"IrrigationOwnerUsage"> | number
    usagePercentage?: FloatFilter<"IrrigationOwnerUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationOwnerUsage"> | Date | string
    irrigationFieldUsage?: XOR<IrrigationFieldUsageScalarRelationFilter, IrrigationFieldUsageWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type IrrigationOwnerUsageOrderByWithAggregationInput = {
    id?: SortOrder
    irrigationFieldUsageId?: SortOrder
    ownerId?: SortOrder
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
    createdAt?: SortOrder
    _count?: IrrigationOwnerUsageCountOrderByAggregateInput
    _avg?: IrrigationOwnerUsageAvgOrderByAggregateInput
    _max?: IrrigationOwnerUsageMaxOrderByAggregateInput
    _min?: IrrigationOwnerUsageMinOrderByAggregateInput
    _sum?: IrrigationOwnerUsageSumOrderByAggregateInput
  }

  export type IrrigationOwnerUsageScalarWhereWithAggregatesInput = {
    AND?: IrrigationOwnerUsageScalarWhereWithAggregatesInput | IrrigationOwnerUsageScalarWhereWithAggregatesInput[]
    OR?: IrrigationOwnerUsageScalarWhereWithAggregatesInput[]
    NOT?: IrrigationOwnerUsageScalarWhereWithAggregatesInput | IrrigationOwnerUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationOwnerUsage"> | string
    irrigationFieldUsageId?: StringWithAggregatesFilter<"IrrigationOwnerUsage"> | string
    ownerId?: StringWithAggregatesFilter<"IrrigationOwnerUsage"> | string
    ownershipPercentage?: FloatWithAggregatesFilter<"IrrigationOwnerUsage"> | number
    usagePercentage?: FloatWithAggregatesFilter<"IrrigationOwnerUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IrrigationOwnerUsage"> | Date | string
  }

  export type IrrigationOwnerSummaryWhereInput = {
    AND?: IrrigationOwnerSummaryWhereInput | IrrigationOwnerSummaryWhereInput[]
    OR?: IrrigationOwnerSummaryWhereInput[]
    NOT?: IrrigationOwnerSummaryWhereInput | IrrigationOwnerSummaryWhereInput[]
    id?: StringFilter<"IrrigationOwnerSummary"> | string
    irrigationLogId?: StringFilter<"IrrigationOwnerSummary"> | string
    ownerId?: StringFilter<"IrrigationOwnerSummary"> | string
    totalIrrigatedArea?: FloatFilter<"IrrigationOwnerSummary"> | number
    totalAllocatedDuration?: FloatFilter<"IrrigationOwnerSummary"> | number
    createdAt?: DateTimeFilter<"IrrigationOwnerSummary"> | Date | string
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IrrigationOwnerSummaryOrderByWithRelationInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    ownerId?: SortOrder
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
    createdAt?: SortOrder
    irrigationLog?: IrrigationLogOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type IrrigationOwnerSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    irrigationLogId_ownerId?: IrrigationOwnerSummaryIrrigationLogIdOwnerIdCompoundUniqueInput
    AND?: IrrigationOwnerSummaryWhereInput | IrrigationOwnerSummaryWhereInput[]
    OR?: IrrigationOwnerSummaryWhereInput[]
    NOT?: IrrigationOwnerSummaryWhereInput | IrrigationOwnerSummaryWhereInput[]
    irrigationLogId?: StringFilter<"IrrigationOwnerSummary"> | string
    ownerId?: StringFilter<"IrrigationOwnerSummary"> | string
    totalIrrigatedArea?: FloatFilter<"IrrigationOwnerSummary"> | number
    totalAllocatedDuration?: FloatFilter<"IrrigationOwnerSummary"> | number
    createdAt?: DateTimeFilter<"IrrigationOwnerSummary"> | Date | string
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "irrigationLogId_ownerId">

  export type IrrigationOwnerSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    ownerId?: SortOrder
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
    createdAt?: SortOrder
    _count?: IrrigationOwnerSummaryCountOrderByAggregateInput
    _avg?: IrrigationOwnerSummaryAvgOrderByAggregateInput
    _max?: IrrigationOwnerSummaryMaxOrderByAggregateInput
    _min?: IrrigationOwnerSummaryMinOrderByAggregateInput
    _sum?: IrrigationOwnerSummarySumOrderByAggregateInput
  }

  export type IrrigationOwnerSummaryScalarWhereWithAggregatesInput = {
    AND?: IrrigationOwnerSummaryScalarWhereWithAggregatesInput | IrrigationOwnerSummaryScalarWhereWithAggregatesInput[]
    OR?: IrrigationOwnerSummaryScalarWhereWithAggregatesInput[]
    NOT?: IrrigationOwnerSummaryScalarWhereWithAggregatesInput | IrrigationOwnerSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationOwnerSummary"> | string
    irrigationLogId?: StringWithAggregatesFilter<"IrrigationOwnerSummary"> | string
    ownerId?: StringWithAggregatesFilter<"IrrigationOwnerSummary"> | string
    totalIrrigatedArea?: FloatWithAggregatesFilter<"IrrigationOwnerSummary"> | number
    totalAllocatedDuration?: FloatWithAggregatesFilter<"IrrigationOwnerSummary"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IrrigationOwnerSummary"> | Date | string
  }

  export type IrrigationInventoryUsageWhereInput = {
    AND?: IrrigationInventoryUsageWhereInput | IrrigationInventoryUsageWhereInput[]
    OR?: IrrigationInventoryUsageWhereInput[]
    NOT?: IrrigationInventoryUsageWhereInput | IrrigationInventoryUsageWhereInput[]
    id?: StringFilter<"IrrigationInventoryUsage"> | string
    irrigationLogId?: StringFilter<"IrrigationInventoryUsage"> | string
    inventoryId?: StringFilter<"IrrigationInventoryUsage"> | string
    quantity?: FloatFilter<"IrrigationInventoryUsage"> | number
    unitPrice?: FloatFilter<"IrrigationInventoryUsage"> | number
    totalCost?: FloatFilter<"IrrigationInventoryUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationInventoryUsage"> | Date | string
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    ownerUsages?: IrrigationInventoryOwnerUsageListRelationFilter
  }

  export type IrrigationInventoryUsageOrderByWithRelationInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    irrigationLog?: IrrigationLogOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    ownerUsages?: IrrigationInventoryOwnerUsageOrderByRelationAggregateInput
  }

  export type IrrigationInventoryUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IrrigationInventoryUsageWhereInput | IrrigationInventoryUsageWhereInput[]
    OR?: IrrigationInventoryUsageWhereInput[]
    NOT?: IrrigationInventoryUsageWhereInput | IrrigationInventoryUsageWhereInput[]
    irrigationLogId?: StringFilter<"IrrigationInventoryUsage"> | string
    inventoryId?: StringFilter<"IrrigationInventoryUsage"> | string
    quantity?: FloatFilter<"IrrigationInventoryUsage"> | number
    unitPrice?: FloatFilter<"IrrigationInventoryUsage"> | number
    totalCost?: FloatFilter<"IrrigationInventoryUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationInventoryUsage"> | Date | string
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    ownerUsages?: IrrigationInventoryOwnerUsageListRelationFilter
  }, "id">

  export type IrrigationInventoryUsageOrderByWithAggregationInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    _count?: IrrigationInventoryUsageCountOrderByAggregateInput
    _avg?: IrrigationInventoryUsageAvgOrderByAggregateInput
    _max?: IrrigationInventoryUsageMaxOrderByAggregateInput
    _min?: IrrigationInventoryUsageMinOrderByAggregateInput
    _sum?: IrrigationInventoryUsageSumOrderByAggregateInput
  }

  export type IrrigationInventoryUsageScalarWhereWithAggregatesInput = {
    AND?: IrrigationInventoryUsageScalarWhereWithAggregatesInput | IrrigationInventoryUsageScalarWhereWithAggregatesInput[]
    OR?: IrrigationInventoryUsageScalarWhereWithAggregatesInput[]
    NOT?: IrrigationInventoryUsageScalarWhereWithAggregatesInput | IrrigationInventoryUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationInventoryUsage"> | string
    irrigationLogId?: StringWithAggregatesFilter<"IrrigationInventoryUsage"> | string
    inventoryId?: StringWithAggregatesFilter<"IrrigationInventoryUsage"> | string
    quantity?: FloatWithAggregatesFilter<"IrrigationInventoryUsage"> | number
    unitPrice?: FloatWithAggregatesFilter<"IrrigationInventoryUsage"> | number
    totalCost?: FloatWithAggregatesFilter<"IrrigationInventoryUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IrrigationInventoryUsage"> | Date | string
  }

  export type IrrigationInventoryOwnerUsageWhereInput = {
    AND?: IrrigationInventoryOwnerUsageWhereInput | IrrigationInventoryOwnerUsageWhereInput[]
    OR?: IrrigationInventoryOwnerUsageWhereInput[]
    NOT?: IrrigationInventoryOwnerUsageWhereInput | IrrigationInventoryOwnerUsageWhereInput[]
    id?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    irrigationInventoryUsageId?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    ownerId?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    percentage?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    quantity?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    cost?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationInventoryOwnerUsage"> | Date | string
    irrigationInventoryUsage?: XOR<IrrigationInventoryUsageScalarRelationFilter, IrrigationInventoryUsageWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IrrigationInventoryOwnerUsageOrderByWithRelationInput = {
    id?: SortOrder
    irrigationInventoryUsageId?: SortOrder
    ownerId?: SortOrder
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    irrigationInventoryUsage?: IrrigationInventoryUsageOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type IrrigationInventoryOwnerUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IrrigationInventoryOwnerUsageWhereInput | IrrigationInventoryOwnerUsageWhereInput[]
    OR?: IrrigationInventoryOwnerUsageWhereInput[]
    NOT?: IrrigationInventoryOwnerUsageWhereInput | IrrigationInventoryOwnerUsageWhereInput[]
    irrigationInventoryUsageId?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    ownerId?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    percentage?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    quantity?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    cost?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationInventoryOwnerUsage"> | Date | string
    irrigationInventoryUsage?: XOR<IrrigationInventoryUsageScalarRelationFilter, IrrigationInventoryUsageWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type IrrigationInventoryOwnerUsageOrderByWithAggregationInput = {
    id?: SortOrder
    irrigationInventoryUsageId?: SortOrder
    ownerId?: SortOrder
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    _count?: IrrigationInventoryOwnerUsageCountOrderByAggregateInput
    _avg?: IrrigationInventoryOwnerUsageAvgOrderByAggregateInput
    _max?: IrrigationInventoryOwnerUsageMaxOrderByAggregateInput
    _min?: IrrigationInventoryOwnerUsageMinOrderByAggregateInput
    _sum?: IrrigationInventoryOwnerUsageSumOrderByAggregateInput
  }

  export type IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput = {
    AND?: IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput | IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput[]
    OR?: IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput[]
    NOT?: IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput | IrrigationInventoryOwnerUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | string
    irrigationInventoryUsageId?: StringWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | string
    ownerId?: StringWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | string
    percentage?: FloatWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | number
    quantity?: FloatWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | number
    cost?: FloatWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IrrigationInventoryOwnerUsage"> | Date | string
  }

  export type WellBillingPeriodWhereInput = {
    AND?: WellBillingPeriodWhereInput | WellBillingPeriodWhereInput[]
    OR?: WellBillingPeriodWhereInput[]
    NOT?: WellBillingPeriodWhereInput | WellBillingPeriodWhereInput[]
    id?: StringFilter<"WellBillingPeriod"> | string
    wellId?: StringFilter<"WellBillingPeriod"> | string
    startDate?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    endDate?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    totalAmount?: FloatFilter<"WellBillingPeriod"> | number
    totalUsage?: FloatNullableFilter<"WellBillingPeriod"> | number | null
    status?: StringFilter<"WellBillingPeriod"> | string
    createdAt?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
    irrigationUsages?: WellBillingIrrigationUsageListRelationFilter
    distributions?: WellBillDistributionListRelationFilter
  }

  export type WellBillingPeriodOrderByWithRelationInput = {
    id?: SortOrder
    wellId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalAmount?: SortOrder
    totalUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    well?: WellOrderByWithRelationInput
    irrigationUsages?: WellBillingIrrigationUsageOrderByRelationAggregateInput
    distributions?: WellBillDistributionOrderByRelationAggregateInput
  }

  export type WellBillingPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WellBillingPeriodWhereInput | WellBillingPeriodWhereInput[]
    OR?: WellBillingPeriodWhereInput[]
    NOT?: WellBillingPeriodWhereInput | WellBillingPeriodWhereInput[]
    wellId?: StringFilter<"WellBillingPeriod"> | string
    startDate?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    endDate?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    totalAmount?: FloatFilter<"WellBillingPeriod"> | number
    totalUsage?: FloatNullableFilter<"WellBillingPeriod"> | number | null
    status?: StringFilter<"WellBillingPeriod"> | string
    createdAt?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    well?: XOR<WellScalarRelationFilter, WellWhereInput>
    irrigationUsages?: WellBillingIrrigationUsageListRelationFilter
    distributions?: WellBillDistributionListRelationFilter
  }, "id">

  export type WellBillingPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    wellId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalAmount?: SortOrder
    totalUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: WellBillingPeriodCountOrderByAggregateInput
    _avg?: WellBillingPeriodAvgOrderByAggregateInput
    _max?: WellBillingPeriodMaxOrderByAggregateInput
    _min?: WellBillingPeriodMinOrderByAggregateInput
    _sum?: WellBillingPeriodSumOrderByAggregateInput
  }

  export type WellBillingPeriodScalarWhereWithAggregatesInput = {
    AND?: WellBillingPeriodScalarWhereWithAggregatesInput | WellBillingPeriodScalarWhereWithAggregatesInput[]
    OR?: WellBillingPeriodScalarWhereWithAggregatesInput[]
    NOT?: WellBillingPeriodScalarWhereWithAggregatesInput | WellBillingPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellBillingPeriod"> | string
    wellId?: StringWithAggregatesFilter<"WellBillingPeriod"> | string
    startDate?: DateTimeWithAggregatesFilter<"WellBillingPeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"WellBillingPeriod"> | Date | string
    totalAmount?: FloatWithAggregatesFilter<"WellBillingPeriod"> | number
    totalUsage?: FloatNullableWithAggregatesFilter<"WellBillingPeriod"> | number | null
    status?: StringWithAggregatesFilter<"WellBillingPeriod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WellBillingPeriod"> | Date | string
  }

  export type WellBillingIrrigationUsageWhereInput = {
    AND?: WellBillingIrrigationUsageWhereInput | WellBillingIrrigationUsageWhereInput[]
    OR?: WellBillingIrrigationUsageWhereInput[]
    NOT?: WellBillingIrrigationUsageWhereInput | WellBillingIrrigationUsageWhereInput[]
    id?: StringFilter<"WellBillingIrrigationUsage"> | string
    wellBillingPeriodId?: StringFilter<"WellBillingIrrigationUsage"> | string
    irrigationLogId?: StringFilter<"WellBillingIrrigationUsage"> | string
    duration?: FloatFilter<"WellBillingIrrigationUsage"> | number
    percentage?: FloatFilter<"WellBillingIrrigationUsage"> | number
    amount?: FloatFilter<"WellBillingIrrigationUsage"> | number
    createdAt?: DateTimeFilter<"WellBillingIrrigationUsage"> | Date | string
    wellBillingPeriod?: XOR<WellBillingPeriodScalarRelationFilter, WellBillingPeriodWhereInput>
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
  }

  export type WellBillingIrrigationUsageOrderByWithRelationInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    irrigationLogId?: SortOrder
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    wellBillingPeriod?: WellBillingPeriodOrderByWithRelationInput
    irrigationLog?: IrrigationLogOrderByWithRelationInput
  }

  export type WellBillingIrrigationUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WellBillingIrrigationUsageWhereInput | WellBillingIrrigationUsageWhereInput[]
    OR?: WellBillingIrrigationUsageWhereInput[]
    NOT?: WellBillingIrrigationUsageWhereInput | WellBillingIrrigationUsageWhereInput[]
    wellBillingPeriodId?: StringFilter<"WellBillingIrrigationUsage"> | string
    irrigationLogId?: StringFilter<"WellBillingIrrigationUsage"> | string
    duration?: FloatFilter<"WellBillingIrrigationUsage"> | number
    percentage?: FloatFilter<"WellBillingIrrigationUsage"> | number
    amount?: FloatFilter<"WellBillingIrrigationUsage"> | number
    createdAt?: DateTimeFilter<"WellBillingIrrigationUsage"> | Date | string
    wellBillingPeriod?: XOR<WellBillingPeriodScalarRelationFilter, WellBillingPeriodWhereInput>
    irrigationLog?: XOR<IrrigationLogScalarRelationFilter, IrrigationLogWhereInput>
  }, "id">

  export type WellBillingIrrigationUsageOrderByWithAggregationInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    irrigationLogId?: SortOrder
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    _count?: WellBillingIrrigationUsageCountOrderByAggregateInput
    _avg?: WellBillingIrrigationUsageAvgOrderByAggregateInput
    _max?: WellBillingIrrigationUsageMaxOrderByAggregateInput
    _min?: WellBillingIrrigationUsageMinOrderByAggregateInput
    _sum?: WellBillingIrrigationUsageSumOrderByAggregateInput
  }

  export type WellBillingIrrigationUsageScalarWhereWithAggregatesInput = {
    AND?: WellBillingIrrigationUsageScalarWhereWithAggregatesInput | WellBillingIrrigationUsageScalarWhereWithAggregatesInput[]
    OR?: WellBillingIrrigationUsageScalarWhereWithAggregatesInput[]
    NOT?: WellBillingIrrigationUsageScalarWhereWithAggregatesInput | WellBillingIrrigationUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellBillingIrrigationUsage"> | string
    wellBillingPeriodId?: StringWithAggregatesFilter<"WellBillingIrrigationUsage"> | string
    irrigationLogId?: StringWithAggregatesFilter<"WellBillingIrrigationUsage"> | string
    duration?: FloatWithAggregatesFilter<"WellBillingIrrigationUsage"> | number
    percentage?: FloatWithAggregatesFilter<"WellBillingIrrigationUsage"> | number
    amount?: FloatWithAggregatesFilter<"WellBillingIrrigationUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WellBillingIrrigationUsage"> | Date | string
  }

  export type WellBillDistributionWhereInput = {
    AND?: WellBillDistributionWhereInput | WellBillDistributionWhereInput[]
    OR?: WellBillDistributionWhereInput[]
    NOT?: WellBillDistributionWhereInput | WellBillDistributionWhereInput[]
    id?: StringFilter<"WellBillDistribution"> | string
    wellBillingPeriodId?: StringFilter<"WellBillDistribution"> | string
    fieldId?: StringFilter<"WellBillDistribution"> | string
    ownerId?: StringFilter<"WellBillDistribution"> | string
    basisDuration?: FloatFilter<"WellBillDistribution"> | number
    basisArea?: FloatNullableFilter<"WellBillDistribution"> | number | null
    basisWeight?: FloatFilter<"WellBillDistribution"> | number
    sharePercentage?: FloatFilter<"WellBillDistribution"> | number
    amount?: FloatFilter<"WellBillDistribution"> | number
    createdAt?: DateTimeFilter<"WellBillDistribution"> | Date | string
    debtId?: StringNullableFilter<"WellBillDistribution"> | string | null
    wellBillingPeriod?: XOR<WellBillingPeriodScalarRelationFilter, WellBillingPeriodWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    debt?: XOR<DebtNullableScalarRelationFilter, DebtWhereInput> | null
  }

  export type WellBillDistributionOrderByWithRelationInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    fieldId?: SortOrder
    ownerId?: SortOrder
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    wellBillingPeriod?: WellBillingPeriodOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    debt?: DebtOrderByWithRelationInput
  }

  export type WellBillDistributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    wellBillingPeriodId_ownerId_fieldId?: WellBillDistributionWellBillingPeriodIdOwnerIdFieldIdCompoundUniqueInput
    AND?: WellBillDistributionWhereInput | WellBillDistributionWhereInput[]
    OR?: WellBillDistributionWhereInput[]
    NOT?: WellBillDistributionWhereInput | WellBillDistributionWhereInput[]
    wellBillingPeriodId?: StringFilter<"WellBillDistribution"> | string
    fieldId?: StringFilter<"WellBillDistribution"> | string
    ownerId?: StringFilter<"WellBillDistribution"> | string
    basisDuration?: FloatFilter<"WellBillDistribution"> | number
    basisArea?: FloatNullableFilter<"WellBillDistribution"> | number | null
    basisWeight?: FloatFilter<"WellBillDistribution"> | number
    sharePercentage?: FloatFilter<"WellBillDistribution"> | number
    amount?: FloatFilter<"WellBillDistribution"> | number
    createdAt?: DateTimeFilter<"WellBillDistribution"> | Date | string
    debtId?: StringNullableFilter<"WellBillDistribution"> | string | null
    wellBillingPeriod?: XOR<WellBillingPeriodScalarRelationFilter, WellBillingPeriodWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    debt?: XOR<DebtNullableScalarRelationFilter, DebtWhereInput> | null
  }, "id" | "wellBillingPeriodId_ownerId_fieldId">

  export type WellBillDistributionOrderByWithAggregationInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    fieldId?: SortOrder
    ownerId?: SortOrder
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    _count?: WellBillDistributionCountOrderByAggregateInput
    _avg?: WellBillDistributionAvgOrderByAggregateInput
    _max?: WellBillDistributionMaxOrderByAggregateInput
    _min?: WellBillDistributionMinOrderByAggregateInput
    _sum?: WellBillDistributionSumOrderByAggregateInput
  }

  export type WellBillDistributionScalarWhereWithAggregatesInput = {
    AND?: WellBillDistributionScalarWhereWithAggregatesInput | WellBillDistributionScalarWhereWithAggregatesInput[]
    OR?: WellBillDistributionScalarWhereWithAggregatesInput[]
    NOT?: WellBillDistributionScalarWhereWithAggregatesInput | WellBillDistributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellBillDistribution"> | string
    wellBillingPeriodId?: StringWithAggregatesFilter<"WellBillDistribution"> | string
    fieldId?: StringWithAggregatesFilter<"WellBillDistribution"> | string
    ownerId?: StringWithAggregatesFilter<"WellBillDistribution"> | string
    basisDuration?: FloatWithAggregatesFilter<"WellBillDistribution"> | number
    basisArea?: FloatNullableWithAggregatesFilter<"WellBillDistribution"> | number | null
    basisWeight?: FloatWithAggregatesFilter<"WellBillDistribution"> | number
    sharePercentage?: FloatWithAggregatesFilter<"WellBillDistribution"> | number
    amount?: FloatWithAggregatesFilter<"WellBillDistribution"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WellBillDistribution"> | Date | string
    debtId?: StringNullableWithAggregatesFilter<"WellBillDistribution"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type SeasonUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldCreateInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FieldCreateManyInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
  }

  export type FieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldOwnershipCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    field: FieldCreateNestedOneWithoutOwnersInput
    user: UserCreateNestedOneWithoutOwnedFieldsInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutFieldOwnershipInput
  }

  export type FieldOwnershipUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    fieldId: string
    userId: string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutFieldOwnershipInput
  }

  export type FieldOwnershipUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    field?: FieldUpdateOneRequiredWithoutOwnersNestedInput
    user?: UserUpdateOneRequiredWithoutOwnedFieldsNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutFieldOwnershipNestedInput
  }

  export type FieldOwnershipUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    fieldId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutFieldOwnershipNestedInput
  }

  export type FieldOwnershipCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    fieldId: string
    userId: string
  }

  export type FieldOwnershipUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
  }

  export type FieldOwnershipUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    fieldId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWorkerAssignmentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutWorkerAssignmentsInput
    user: UserCreateNestedOneWithoutAssignedFieldsInput
  }

  export type FieldWorkerAssignmentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    userId: string
  }

  export type FieldWorkerAssignmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutWorkerAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutAssignedFieldsNestedInput
  }

  export type FieldWorkerAssignmentUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWorkerAssignmentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    userId: string
  }

  export type FieldWorkerAssignmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldWorkerAssignmentUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWellCreateInput = {
    id?: string
    createdAt?: Date | string
    field: FieldCreateNestedOneWithoutFieldWellsInput
    well: WellCreateNestedOneWithoutFieldWellsInput
  }

  export type FieldWellUncheckedCreateInput = {
    id?: string
    fieldId: string
    wellId: string
    createdAt?: Date | string
  }

  export type FieldWellUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldWellsNestedInput
    well?: WellUpdateOneRequiredWithoutFieldWellsNestedInput
  }

  export type FieldWellUncheckedUpdateInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    wellId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldWellCreateManyInput = {
    id?: string
    fieldId: string
    wellId: string
    createdAt?: Date | string
  }

  export type FieldWellUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldWellUncheckedUpdateManyInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    wellId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerWellAssignmentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    worker: UserCreateNestedOneWithoutWellAssignmentsInput
    well: WellCreateNestedOneWithoutWorkerAssignmentsInput
  }

  export type WorkerWellAssignmentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workerId: string
    wellId: string
  }

  export type WorkerWellAssignmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worker?: UserUpdateOneRequiredWithoutWellAssignmentsNestedInput
    well?: WellUpdateOneRequiredWithoutWorkerAssignmentsNestedInput
  }

  export type WorkerWellAssignmentUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerId?: StringFieldUpdateOperationsInput | string
    wellId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerWellAssignmentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workerId: string
    wellId: string
  }

  export type WorkerWellAssignmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerWellAssignmentUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerId?: StringFieldUpdateOperationsInput | string
    wellId?: StringFieldUpdateOperationsInput | string
  }

  export type WellCreateInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellCreateNestedManyWithoutWellInput
    notifications?: NotificationCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWellInput
  }

  export type WellUncheckedCreateInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutWellInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodUncheckedCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWellInput
  }

  export type WellUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUpdateManyWithoutWellNestedInput
    notifications?: NotificationUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUpdateManyWithoutWellNestedInput
  }

  export type WellUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUncheckedUpdateManyWithoutWellNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUncheckedUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWellNestedInput
  }

  export type WellCreateManyInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropCreateInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutCropsInput
    field: FieldCreateNestedOneWithoutCropsInput
    notifications?: NotificationCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutCropsNestedInput
    field?: FieldUpdateOneRequiredWithoutCropsNestedInput
    notifications?: NotificationUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropCreateManyInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldId: string
  }

  export type CropUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessingLogCreateInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutProcessingLogsInput
    notifications?: NotificationCreateNestedManyWithoutProcessingLogInput
  }

  export type ProcessingLogUncheckedCreateInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessingLogInput
  }

  export type ProcessingLogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutProcessingLogsNestedInput
    notifications?: NotificationUpdateManyWithoutProcessingLogNestedInput
  }

  export type ProcessingLogUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutProcessingLogNestedInput
  }

  export type ProcessingLogCreateManyInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type ProcessingLogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingLogUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCreateInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutInventoryInput
    notifications?: NotificationCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipUncheckedCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUncheckedUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryOwnershipCreateInput = {
    id?: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutOwnershipsInput
    user: UserCreateNestedOneWithoutInventoryOwnershipInput
  }

  export type InventoryOwnershipUncheckedCreateInput = {
    id?: string
    inventoryId: string
    userId: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryOwnershipUpdateInput = {
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutOwnershipsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryOwnershipNestedInput
  }

  export type InventoryOwnershipUncheckedUpdateInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryOwnershipCreateManyInput = {
    id?: string
    inventoryId: string
    userId: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryOwnershipUpdateManyMutationInput = {
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryOwnershipUncheckedUpdateManyInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
  }

  export type PurchaseUpdateManyMutationInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseUncheckedUpdateManyInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseApprovalCreateInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutPurchaseApprovalsInput
    notifications?: NotificationCreateNestedManyWithoutApprovalInput
  }

  export type PurchaseApprovalUncheckedCreateInput = {
    id?: string
    purchaseId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type PurchaseApprovalUpdateInput = {
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutPurchaseApprovalsNestedInput
    notifications?: NotificationUpdateManyWithoutApprovalNestedInput
  }

  export type PurchaseApprovalUncheckedUpdateInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type PurchaseApprovalCreateManyInput = {
    id?: string
    purchaseId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseApprovalUpdateManyMutationInput = {
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseApprovalUncheckedUpdateManyInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseContributorCreateInput = {
    id?: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutContributorsInput
    user: UserCreateNestedOneWithoutPurchaseContributionsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutContributorInput
    notifications?: NotificationCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorUncheckedCreateInput = {
    id?: string
    purchaseId: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutContributorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorUpdateInput = {
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutContributorsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseContributionsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutContributorNestedInput
    notifications?: NotificationUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutContributorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorCreateManyInput = {
    id?: string
    purchaseId: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseContributorUpdateManyMutationInput = {
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseContributorUncheckedUpdateManyInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentHistoryCreateInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debt?: DebtCreateNestedOneWithoutPaymentHistoryInput
    contributor?: PurchaseContributorCreateNestedOneWithoutPaymentHistoryInput
    payer: UserCreateNestedOneWithoutPaymentsMadeInput
    receiver: UserCreateNestedOneWithoutPaymentsReceivedInput
    notifications?: NotificationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryUncheckedCreateInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    payerId: string
    receiverId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneWithoutPaymentHistoryNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutPaymentHistoryNestedInput
    payer?: UserUpdateOneRequiredWithoutPaymentsMadeNestedInput
    receiver?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    notifications?: NotificationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryCreateManyInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    payerId: string
    receiverId: string
  }

  export type PaymentHistoryUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentHistoryUncheckedUpdateManyInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryTransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    season?: SeasonCreateNestedOneWithoutInventoryTransactionsInput
    inventory: InventoryCreateNestedOneWithoutInventoryTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutInventoryTransactionsInput
    user: UserCreateNestedOneWithoutInventoryTransactionsInput
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionUncheckedCreateInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    purchaseId?: string | null
    userId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutInventoryTransactionsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutInventoryTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionCreateManyInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    purchaseId?: string | null
    userId: string
  }

  export type InventoryTransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DebtCreateInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtCreateManyInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
  }

  export type DebtUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DebtUncheckedUpdateManyInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaser: UserCreateNestedOneWithoutInvoicesPurchasedInput
    debts?: DebtCreateNestedManyWithoutInvoiceInput
    purchase?: PurchaseCreateNestedOneWithoutInvoicesInput
    notifications?: NotificationCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaserId: string
    purchaseId?: string | null
    debts?: DebtUncheckedCreateNestedManyWithoutInvoiceInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaser?: UserUpdateOneRequiredWithoutInvoicesPurchasedNestedInput
    debts?: DebtUpdateManyWithoutInvoiceNestedInput
    purchase?: PurchaseUpdateOneWithoutInvoicesNestedInput
    notifications?: NotificationUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaserId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    debts?: DebtUncheckedUpdateManyWithoutInvoiceNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaserId: string
    purchaseId?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaserId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUsageCreateInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutUsagesInput
    usedBy: UserCreateNestedOneWithoutInventoryUsagesInput
    field?: FieldCreateNestedOneWithoutInventoryUsagesInput
    process?: ProcessCreateNestedOneWithoutInventoryUsagesInput
    notifications?: NotificationCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageUncheckedCreateInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageUpdateInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutUsagesNestedInput
    usedBy?: UserUpdateOneRequiredWithoutInventoryUsagesNestedInput
    field?: FieldUpdateOneWithoutInventoryUsagesNestedInput
    process?: ProcessUpdateOneWithoutInventoryUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageCreateManyInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageUpdateManyMutationInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageUncheckedUpdateManyInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCreateInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    worker: UserCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessUpdateInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessCreateManyInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessUpdateManyMutationInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessUncheckedUpdateManyInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    inAppNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyDigest?: BoolFieldUpdateOperationsInput | boolean
    notifyOnDebtReminders?: BoolFieldUpdateOperationsInput | boolean
    notifyOnPayments?: BoolFieldUpdateOperationsInput | boolean
    notifyOnProcessUpdates?: BoolFieldUpdateOperationsInput | boolean
    notifyOnInventoryAlerts?: BoolFieldUpdateOperationsInput | boolean
    notifyOnApprovals?: BoolFieldUpdateOperationsInput | boolean
    notifyOnIrrigation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    inAppNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyDigest?: BoolFieldUpdateOperationsInput | boolean
    notifyOnDebtReminders?: BoolFieldUpdateOperationsInput | boolean
    notifyOnPayments?: BoolFieldUpdateOperationsInput | boolean
    notifyOnProcessUpdates?: BoolFieldUpdateOperationsInput | boolean
    notifyOnInventoryAlerts?: BoolFieldUpdateOperationsInput | boolean
    notifyOnApprovals?: BoolFieldUpdateOperationsInput | boolean
    notifyOnIrrigation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    inAppNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyDigest?: BoolFieldUpdateOperationsInput | boolean
    notifyOnDebtReminders?: BoolFieldUpdateOperationsInput | boolean
    notifyOnPayments?: BoolFieldUpdateOperationsInput | boolean
    notifyOnProcessUpdates?: BoolFieldUpdateOperationsInput | boolean
    notifyOnInventoryAlerts?: BoolFieldUpdateOperationsInput | boolean
    notifyOnApprovals?: BoolFieldUpdateOperationsInput | boolean
    notifyOnIrrigation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    inAppNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyDigest?: BoolFieldUpdateOperationsInput | boolean
    notifyOnDebtReminders?: BoolFieldUpdateOperationsInput | boolean
    notifyOnPayments?: BoolFieldUpdateOperationsInput | boolean
    notifyOnProcessUpdates?: BoolFieldUpdateOperationsInput | boolean
    notifyOnInventoryAlerts?: BoolFieldUpdateOperationsInput | boolean
    notifyOnApprovals?: BoolFieldUpdateOperationsInput | boolean
    notifyOnIrrigation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipCreateNestedManyWithoutEquipmentInput
    capabilities?: EquipmentCapabilityCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutEquipmentInput
    capabilities?: EquipmentCapabilityUncheckedCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUpdateManyWithoutEquipmentNestedInput
    capabilities?: EquipmentCapabilityUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentNestedInput
    capabilities?: EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentOwnershipCreateInput = {
    id?: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment: EquipmentCreateNestedOneWithoutOwnershipsInput
    user: UserCreateNestedOneWithoutEquipmentOwnershipsInput
  }

  export type EquipmentOwnershipUncheckedCreateInput = {
    id?: string
    equipmentId: string
    userId: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentOwnershipUpdateInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentUpdateOneRequiredWithoutOwnershipsNestedInput
    user?: UserUpdateOneRequiredWithoutEquipmentOwnershipsNestedInput
  }

  export type EquipmentOwnershipUncheckedUpdateInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentOwnershipCreateManyInput = {
    id?: string
    equipmentId: string
    userId: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentOwnershipUpdateManyMutationInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentOwnershipUncheckedUpdateManyInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCapabilityCreateInput = {
    id?: string
    inventoryCategory: $Enums.InventoryCategory
    canUse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment: EquipmentCreateNestedOneWithoutCapabilitiesInput
  }

  export type EquipmentCapabilityUncheckedCreateInput = {
    id?: string
    equipmentId: string
    inventoryCategory: $Enums.InventoryCategory
    canUse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCapabilityUpdateInput = {
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentUpdateOneRequiredWithoutCapabilitiesNestedInput
  }

  export type EquipmentCapabilityUncheckedUpdateInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCapabilityCreateManyInput = {
    id?: string
    equipmentId: string
    inventoryCategory: $Enums.InventoryCategory
    canUse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCapabilityUpdateManyMutationInput = {
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCapabilityUncheckedUpdateManyInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUsageCreateInput = {
    id?: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutEquipmentUsagesInput
    equipment: EquipmentCreateNestedOneWithoutUsagesInput
    user: UserCreateNestedOneWithoutEquipmentUsagesInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageUncheckedCreateInput = {
    id?: string
    processId: string
    equipmentId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageUpdateInput = {
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutUsagesNestedInput
    user?: UserUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateInput = {
    processId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageCreateManyInput = {
    id?: string
    processId: string
    equipmentId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUsageUpdateManyMutationInput = {
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUsageUncheckedUpdateManyInput = {
    processId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCostCreateInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutProcessCostsInput
    field: FieldCreateNestedOneWithoutProcessCostsInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutProcessCostInput
    notifications?: NotificationCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostUncheckedCreateInput = {
    id?: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutProcessCostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostUpdateInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutProcessCostsNestedInput
    field?: FieldUpdateOneRequiredWithoutProcessCostsNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutProcessCostNestedInput
    notifications?: NotificationUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateInput = {
    processId?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostCreateManyInput = {
    id?: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type ProcessCostUpdateManyMutationInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCostUncheckedUpdateManyInput = {
    processId?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldExpenseCreateInput = {
    id?: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutFieldExpensesInput
    season: SeasonCreateNestedOneWithoutFieldExpensesInput
    notifications?: NotificationCreateNestedManyWithoutFieldExpenseInput
  }

  export type FieldExpenseUncheckedCreateInput = {
    id?: string
    fieldId: string
    seasonId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldExpenseInput
  }

  export type FieldExpenseUpdateInput = {
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldExpensesNestedInput
    season?: SeasonUpdateOneRequiredWithoutFieldExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutFieldExpenseNestedInput
  }

  export type FieldExpenseUncheckedUpdateInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutFieldExpenseNestedInput
  }

  export type FieldExpenseCreateManyInput = {
    id?: string
    fieldId: string
    seasonId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldExpenseUpdateManyMutationInput = {
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldExpenseUncheckedUpdateManyInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOwnerExpenseCreateInput = {
    id?: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldOwnership: FieldOwnershipCreateNestedOneWithoutOwnerExpensesInput
    processCost: ProcessCostCreateNestedOneWithoutOwnerExpensesInput
    user: UserCreateNestedOneWithoutFieldOwnerExpensesInput
    notifications?: NotificationCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseUncheckedCreateInput = {
    id?: string
    fieldOwnershipId: string
    processCostId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldOwnership?: FieldOwnershipUpdateOneRequiredWithoutOwnerExpensesNestedInput
    processCost?: ProcessCostUpdateOneRequiredWithoutOwnerExpensesNestedInput
    user?: UserUpdateOneRequiredWithoutFieldOwnerExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    processCostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseCreateManyInput = {
    id?: string
    fieldOwnershipId: string
    processCostId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldOwnerExpenseUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOwnerExpenseUncheckedUpdateManyInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    processCostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationLogCreateInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUpdateInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogCreateManyInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
  }

  export type IrrigationLogUpdateManyMutationInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationLogUncheckedUpdateManyInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationFieldUsageCreateInput = {
    id?: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutFieldUsagesInput
    field: FieldCreateNestedOneWithoutIrrigationFieldUsagesInput
    ownerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutIrrigationFieldUsageInput
  }

  export type IrrigationFieldUsageUncheckedCreateInput = {
    id?: string
    irrigationLogId: string
    fieldId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    ownerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutIrrigationFieldUsageInput
  }

  export type IrrigationFieldUsageUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutFieldUsagesNestedInput
    field?: FieldUpdateOneRequiredWithoutIrrigationFieldUsagesNestedInput
    ownerUsages?: IrrigationOwnerUsageUpdateManyWithoutIrrigationFieldUsageNestedInput
  }

  export type IrrigationFieldUsageUncheckedUpdateInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutIrrigationFieldUsageNestedInput
  }

  export type IrrigationFieldUsageCreateManyInput = {
    id?: string
    irrigationLogId: string
    fieldId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
  }

  export type IrrigationFieldUsageUpdateManyMutationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationFieldUsageUncheckedUpdateManyInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerUsageCreateInput = {
    id?: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
    irrigationFieldUsage: IrrigationFieldUsageCreateNestedOneWithoutOwnerUsagesInput
    owner: UserCreateNestedOneWithoutIrrigationOwnerUsagesInput
  }

  export type IrrigationOwnerUsageUncheckedCreateInput = {
    id?: string
    irrigationFieldUsageId: string
    ownerId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerUsageUpdateInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationFieldUsage?: IrrigationFieldUsageUpdateOneRequiredWithoutOwnerUsagesNestedInput
    owner?: UserUpdateOneRequiredWithoutIrrigationOwnerUsagesNestedInput
  }

  export type IrrigationOwnerUsageUncheckedUpdateInput = {
    irrigationFieldUsageId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerUsageCreateManyInput = {
    id?: string
    irrigationFieldUsageId: string
    ownerId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerUsageUpdateManyMutationInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerUsageUncheckedUpdateManyInput = {
    irrigationFieldUsageId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryCreateInput = {
    id?: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutOwnerSummariesInput
    owner: UserCreateNestedOneWithoutIrrigationOwnerSummariesInput
  }

  export type IrrigationOwnerSummaryUncheckedCreateInput = {
    id?: string
    irrigationLogId: string
    ownerId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerSummaryUpdateInput = {
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutOwnerSummariesNestedInput
    owner?: UserUpdateOneRequiredWithoutIrrigationOwnerSummariesNestedInput
  }

  export type IrrigationOwnerSummaryUncheckedUpdateInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryCreateManyInput = {
    id?: string
    irrigationLogId: string
    ownerId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerSummaryUpdateManyMutationInput = {
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryUncheckedUpdateManyInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryUsageCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutInventoryUsagesInput
    inventory: InventoryCreateNestedOneWithoutIrrigationInventoryUsagesInput
    ownerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutIrrigationInventoryUsageInput
  }

  export type IrrigationInventoryUsageUncheckedCreateInput = {
    id?: string
    irrigationLogId: string
    inventoryId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    ownerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutIrrigationInventoryUsageInput
  }

  export type IrrigationInventoryUsageUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutInventoryUsagesNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutIrrigationInventoryUsagesNestedInput
    ownerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutIrrigationInventoryUsageNestedInput
  }

  export type IrrigationInventoryUsageUncheckedUpdateInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutIrrigationInventoryUsageNestedInput
  }

  export type IrrigationInventoryUsageCreateManyInput = {
    id?: string
    irrigationLogId: string
    inventoryId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryUsageUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryUsageUncheckedUpdateManyInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageCreateInput = {
    id?: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
    irrigationInventoryUsage: IrrigationInventoryUsageCreateNestedOneWithoutOwnerUsagesInput
    owner: UserCreateNestedOneWithoutIrrigationInventoryOwnerUsagesInput
  }

  export type IrrigationInventoryOwnerUsageUncheckedCreateInput = {
    id?: string
    irrigationInventoryUsageId: string
    ownerId: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryOwnerUsageUpdateInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationInventoryUsage?: IrrigationInventoryUsageUpdateOneRequiredWithoutOwnerUsagesNestedInput
    owner?: UserUpdateOneRequiredWithoutIrrigationInventoryOwnerUsagesNestedInput
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateInput = {
    irrigationInventoryUsageId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageCreateManyInput = {
    id?: string
    irrigationInventoryUsageId: string
    ownerId: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryOwnerUsageUpdateManyMutationInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateManyInput = {
    irrigationInventoryUsageId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingPeriodCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    well: WellCreateNestedOneWithoutWellBillingPeriodsInput
    irrigationUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutWellBillingPeriodInput
    distributions?: WellBillDistributionCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodUncheckedCreateInput = {
    id?: string
    wellId: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    irrigationUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutWellBillingPeriodInput
    distributions?: WellBillDistributionUncheckedCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutWellBillingPeriodsNestedInput
    irrigationUsages?: WellBillingIrrigationUsageUpdateManyWithoutWellBillingPeriodNestedInput
    distributions?: WellBillDistributionUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type WellBillingPeriodUncheckedUpdateInput = {
    wellId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutWellBillingPeriodNestedInput
    distributions?: WellBillDistributionUncheckedUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type WellBillingPeriodCreateManyInput = {
    id?: string
    wellId: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type WellBillingPeriodUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingPeriodUncheckedUpdateManyInput = {
    wellId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageCreateInput = {
    id?: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
    wellBillingPeriod: WellBillingPeriodCreateNestedOneWithoutIrrigationUsagesInput
    irrigationLog: IrrigationLogCreateNestedOneWithoutBillingUsagesInput
  }

  export type WellBillingIrrigationUsageUncheckedCreateInput = {
    id?: string
    wellBillingPeriodId: string
    irrigationLogId: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
  }

  export type WellBillingIrrigationUsageUpdateInput = {
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellBillingPeriod?: WellBillingPeriodUpdateOneRequiredWithoutIrrigationUsagesNestedInput
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutBillingUsagesNestedInput
  }

  export type WellBillingIrrigationUsageUncheckedUpdateInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageCreateManyInput = {
    id?: string
    wellBillingPeriodId: string
    irrigationLogId: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
  }

  export type WellBillingIrrigationUsageUpdateManyMutationInput = {
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageUncheckedUpdateManyInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillDistributionCreateInput = {
    id?: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    wellBillingPeriod: WellBillingPeriodCreateNestedOneWithoutDistributionsInput
    field: FieldCreateNestedOneWithoutWellBillDistributionsInput
    owner: UserCreateNestedOneWithoutWellBillDistributionsInput
    debt?: DebtCreateNestedOneWithoutWellBillDistributionsInput
  }

  export type WellBillDistributionUncheckedCreateInput = {
    id?: string
    wellBillingPeriodId: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type WellBillDistributionUpdateInput = {
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellBillingPeriod?: WellBillingPeriodUpdateOneRequiredWithoutDistributionsNestedInput
    field?: FieldUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    owner?: UserUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    debt?: DebtUpdateOneWithoutWellBillDistributionsNestedInput
  }

  export type WellBillDistributionUncheckedUpdateInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WellBillDistributionCreateManyInput = {
    id?: string
    wellBillingPeriodId: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type WellBillDistributionUpdateManyMutationInput = {
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillDistributionUncheckedUpdateManyInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IrrigationLogListRelationFilter = {
    every?: IrrigationLogWhereInput
    some?: IrrigationLogWhereInput
    none?: IrrigationLogWhereInput
  }

  export type FieldOwnershipListRelationFilter = {
    every?: FieldOwnershipWhereInput
    some?: FieldOwnershipWhereInput
    none?: FieldOwnershipWhereInput
  }

  export type FieldWorkerAssignmentListRelationFilter = {
    every?: FieldWorkerAssignmentWhereInput
    some?: FieldWorkerAssignmentWhereInput
    none?: FieldWorkerAssignmentWhereInput
  }

  export type InventoryOwnershipListRelationFilter = {
    every?: InventoryOwnershipWhereInput
    some?: InventoryOwnershipWhereInput
    none?: InventoryOwnershipWhereInput
  }

  export type DebtListRelationFilter = {
    every?: DebtWhereInput
    some?: DebtWhereInput
    none?: DebtWhereInput
  }

  export type PurchaseContributorListRelationFilter = {
    every?: PurchaseContributorWhereInput
    some?: PurchaseContributorWhereInput
    none?: PurchaseContributorWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type InventoryUsageListRelationFilter = {
    every?: InventoryUsageWhereInput
    some?: InventoryUsageWhereInput
    none?: InventoryUsageWhereInput
  }

  export type ProcessListRelationFilter = {
    every?: ProcessWhereInput
    some?: ProcessWhereInput
    none?: ProcessWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentHistoryListRelationFilter = {
    every?: PaymentHistoryWhereInput
    some?: PaymentHistoryWhereInput
    none?: PaymentHistoryWhereInput
  }

  export type InventoryTransactionListRelationFilter = {
    every?: InventoryTransactionWhereInput
    some?: InventoryTransactionWhereInput
    none?: InventoryTransactionWhereInput
  }

  export type SeasonListRelationFilter = {
    every?: SeasonWhereInput
    some?: SeasonWhereInput
    none?: SeasonWhereInput
  }

  export type PurchaseApprovalListRelationFilter = {
    every?: PurchaseApprovalWhereInput
    some?: PurchaseApprovalWhereInput
    none?: PurchaseApprovalWhereInput
  }

  export type EquipmentOwnershipListRelationFilter = {
    every?: EquipmentOwnershipWhereInput
    some?: EquipmentOwnershipWhereInput
    none?: EquipmentOwnershipWhereInput
  }

  export type EquipmentUsageListRelationFilter = {
    every?: EquipmentUsageWhereInput
    some?: EquipmentUsageWhereInput
    none?: EquipmentUsageWhereInput
  }

  export type FieldOwnerExpenseListRelationFilter = {
    every?: FieldOwnerExpenseWhereInput
    some?: FieldOwnerExpenseWhereInput
    none?: FieldOwnerExpenseWhereInput
  }

  export type WorkerWellAssignmentListRelationFilter = {
    every?: WorkerWellAssignmentWhereInput
    some?: WorkerWellAssignmentWhereInput
    none?: WorkerWellAssignmentWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type IrrigationOwnerUsageListRelationFilter = {
    every?: IrrigationOwnerUsageWhereInput
    some?: IrrigationOwnerUsageWhereInput
    none?: IrrigationOwnerUsageWhereInput
  }

  export type IrrigationInventoryOwnerUsageListRelationFilter = {
    every?: IrrigationInventoryOwnerUsageWhereInput
    some?: IrrigationInventoryOwnerUsageWhereInput
    none?: IrrigationInventoryOwnerUsageWhereInput
  }

  export type IrrigationOwnerSummaryListRelationFilter = {
    every?: IrrigationOwnerSummaryWhereInput
    some?: IrrigationOwnerSummaryWhereInput
    none?: IrrigationOwnerSummaryWhereInput
  }

  export type WellBillDistributionListRelationFilter = {
    every?: WellBillDistributionWhereInput
    some?: WellBillDistributionWhereInput
    none?: WellBillDistributionWhereInput
  }

  export type IrrigationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldOwnershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldWorkerAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOwnershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseContributorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOwnershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldOwnerExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerWellAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IrrigationOwnerUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IrrigationInventoryOwnerUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IrrigationOwnerSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WellBillDistributionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FieldListRelationFilter = {
    every?: FieldWhereInput
    some?: FieldWhereInput
    none?: FieldWhereInput
  }

  export type CropListRelationFilter = {
    every?: CropWhereInput
    some?: CropWhereInput
    none?: CropWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type FieldExpenseListRelationFilter = {
    every?: FieldExpenseWhereInput
    some?: FieldExpenseWhereInput
    none?: FieldExpenseWhereInput
  }

  export type FieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CropOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SeasonNullableScalarRelationFilter = {
    is?: SeasonWhereInput | null
    isNot?: SeasonWhereInput | null
  }

  export type FieldWellListRelationFilter = {
    every?: FieldWellWhereInput
    some?: FieldWellWhereInput
    none?: FieldWellWhereInput
  }

  export type ProcessingLogListRelationFilter = {
    every?: ProcessingLogWhereInput
    some?: ProcessingLogWhereInput
    none?: ProcessingLogWhereInput
  }

  export type ProcessCostListRelationFilter = {
    every?: ProcessCostWhereInput
    some?: ProcessCostWhereInput
    none?: ProcessCostWhereInput
  }

  export type IrrigationFieldUsageListRelationFilter = {
    every?: IrrigationFieldUsageWhereInput
    some?: IrrigationFieldUsageWhereInput
    none?: IrrigationFieldUsageWhereInput
  }

  export type FieldWellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessingLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IrrigationFieldUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    size?: SortOrder
    coordinates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
  }

  export type FieldAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    size?: SortOrder
    coordinates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
  }

  export type FieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    size?: SortOrder
    coordinates?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
  }

  export type FieldSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FieldScalarRelationFilter = {
    is?: FieldWhereInput
    isNot?: FieldWhereInput
  }

  export type FieldOwnershipFieldIdUserIdCompoundUniqueInput = {
    fieldId: string
    userId: string
  }

  export type FieldOwnershipCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    percentage?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
  }

  export type FieldOwnershipAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type FieldOwnershipMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    percentage?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
  }

  export type FieldOwnershipMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    percentage?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
  }

  export type FieldOwnershipSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type FieldWorkerAssignmentFieldIdUserIdCompoundUniqueInput = {
    fieldId: string
    userId: string
  }

  export type FieldWorkerAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
  }

  export type FieldWorkerAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
  }

  export type FieldWorkerAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
    userId?: SortOrder
  }

  export type WellScalarRelationFilter = {
    is?: WellWhereInput
    isNot?: WellWhereInput
  }

  export type FieldWellFieldIdWellIdCompoundUniqueInput = {
    fieldId: string
    wellId: string
  }

  export type FieldWellCountOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    wellId?: SortOrder
    createdAt?: SortOrder
  }

  export type FieldWellMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    wellId?: SortOrder
    createdAt?: SortOrder
  }

  export type FieldWellMinOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    wellId?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerWellAssignmentWorkerIdWellIdCompoundUniqueInput = {
    workerId: string
    wellId: string
  }

  export type WorkerWellAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workerId?: SortOrder
    wellId?: SortOrder
  }

  export type WorkerWellAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workerId?: SortOrder
    wellId?: SortOrder
  }

  export type WorkerWellAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workerId?: SortOrder
    wellId?: SortOrder
  }

  export type WellBillingPeriodListRelationFilter = {
    every?: WellBillingPeriodWhereInput
    some?: WellBillingPeriodWhereInput
    none?: WellBillingPeriodWhereInput
  }

  export type WellBillingPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WellCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellAvgOrderByAggregateInput = {
    depth?: SortOrder
    capacity?: SortOrder
  }

  export type WellMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    depth?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellSumOrderByAggregateInput = {
    depth?: SortOrder
    capacity?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type EnumCropStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CropStatus | EnumCropStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCropStatusFilter<$PrismaModel> | $Enums.CropStatus
  }

  export type CropCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plantedDate?: SortOrder
    harvestDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    fieldId?: SortOrder
  }

  export type CropMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plantedDate?: SortOrder
    harvestDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    fieldId?: SortOrder
  }

  export type CropMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plantedDate?: SortOrder
    harvestDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    fieldId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumCropStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CropStatus | EnumCropStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCropStatusWithAggregatesFilter<$PrismaModel> | $Enums.CropStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCropStatusFilter<$PrismaModel>
    _max?: NestedEnumCropStatusFilter<$PrismaModel>
  }

  export type EnumProcessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeFilter<$PrismaModel> | $Enums.ProcessType
  }

  export type ProcessingLogCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    processType?: SortOrder
    equipment?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
  }

  export type ProcessingLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ProcessingLogMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    processType?: SortOrder
    equipment?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
  }

  export type ProcessingLogMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    processType?: SortOrder
    equipment?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
  }

  export type ProcessingLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumProcessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProcessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessTypeFilter<$PrismaModel>
    _max?: NestedEnumProcessTypeFilter<$PrismaModel>
  }

  export type EnumInventoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryFilter<$PrismaModel> | $Enums.InventoryCategory
  }

  export type EnumUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.Unit | EnumUnitFieldRefInput<$PrismaModel>
    in?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitFilter<$PrismaModel> | $Enums.Unit
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type EnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type IrrigationInventoryUsageListRelationFilter = {
    every?: IrrigationInventoryUsageWhereInput
    some?: IrrigationInventoryUsageWhereInput
    none?: IrrigationInventoryUsageWhereInput
  }

  export type IrrigationInventoryUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    totalQuantity?: SortOrder
    unit?: SortOrder
    totalStock?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    costPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    totalQuantity?: SortOrder
    totalStock?: SortOrder
    costPrice?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    totalQuantity?: SortOrder
    unit?: SortOrder
    totalStock?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    costPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    totalQuantity?: SortOrder
    unit?: SortOrder
    totalStock?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    status?: SortOrder
    costPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    totalQuantity?: SortOrder
    totalStock?: SortOrder
    costPrice?: SortOrder
  }

  export type EnumInventoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InventoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumInventoryCategoryFilter<$PrismaModel>
  }

  export type EnumUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Unit | EnumUnitFieldRefInput<$PrismaModel>
    in?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitWithAggregatesFilter<$PrismaModel> | $Enums.Unit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitFilter<$PrismaModel>
    _max?: NestedEnumUnitFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type InventoryScalarRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryOwnershipCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    userId?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryOwnershipAvgOrderByAggregateInput = {
    shareQuantity?: SortOrder
  }

  export type InventoryOwnershipMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    userId?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryOwnershipMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    userId?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryOwnershipSumOrderByAggregateInput = {
    shareQuantity?: SortOrder
  }

  export type EnumProductCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProductCategoryFilter<$PrismaModel> | $Enums.ProductCategory
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    paymentMethod?: SortOrder
    creditorPaymentDueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    isTemplate?: SortOrder
    templateName?: SortOrder
    approvalStatus?: SortOrder
    approvalRequired?: SortOrder
    approvalThreshold?: SortOrder
    seasonId?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    approvalThreshold?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    paymentMethod?: SortOrder
    creditorPaymentDueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    isTemplate?: SortOrder
    templateName?: SortOrder
    approvalStatus?: SortOrder
    approvalRequired?: SortOrder
    approvalThreshold?: SortOrder
    seasonId?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    paymentMethod?: SortOrder
    creditorPaymentDueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    isTemplate?: SortOrder
    templateName?: SortOrder
    approvalStatus?: SortOrder
    approvalRequired?: SortOrder
    approvalThreshold?: SortOrder
    seasonId?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    approvalThreshold?: SortOrder
  }

  export type EnumProductCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProductCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductCategoryFilter<$PrismaModel>
    _max?: NestedEnumProductCategoryFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type PurchaseScalarRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type PurchaseApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseContributorCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
    hasPaid?: SortOrder
    paymentDate?: SortOrder
    isCreditor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseContributorAvgOrderByAggregateInput = {
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
  }

  export type PurchaseContributorMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
    hasPaid?: SortOrder
    paymentDate?: SortOrder
    isCreditor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseContributorMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
    hasPaid?: SortOrder
    paymentDate?: SortOrder
    isCreditor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseContributorSumOrderByAggregateInput = {
    sharePercentage?: SortOrder
    contribution?: SortOrder
    expectedContribution?: SortOrder
    actualContribution?: SortOrder
    remainingAmount?: SortOrder
  }

  export type DebtNullableScalarRelationFilter = {
    is?: DebtWhereInput | null
    isNot?: DebtWhereInput | null
  }

  export type PurchaseContributorNullableScalarRelationFilter = {
    is?: PurchaseContributorWhereInput | null
    isNot?: PurchaseContributorWhereInput | null
  }

  export type PaymentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    contributorId?: SortOrder
    payerId?: SortOrder
    receiverId?: SortOrder
  }

  export type PaymentHistoryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    contributorId?: SortOrder
    payerId?: SortOrder
    receiverId?: SortOrder
  }

  export type PaymentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
    contributorId?: SortOrder
    payerId?: SortOrder
    receiverId?: SortOrder
  }

  export type PaymentHistorySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type PurchaseNullableScalarRelationFilter = {
    is?: PurchaseWhereInput | null
    isNot?: PurchaseWhereInput | null
  }

  export type InventoryTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    seasonId?: SortOrder
    inventoryId?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    seasonId?: SortOrder
    inventoryId?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    seasonId?: SortOrder
    inventoryId?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumDebtStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtStatus | EnumDebtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtStatusFilter<$PrismaModel> | $Enums.DebtStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type DebtCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    paymentDate?: SortOrder
    reminderSent?: SortOrder
    lastReminderDate?: SortOrder
    reason?: SortOrder
    creditorId?: SortOrder
    debtorId?: SortOrder
    invoiceId?: SortOrder
    purchaseId?: SortOrder
  }

  export type DebtAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DebtMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    paymentDate?: SortOrder
    reminderSent?: SortOrder
    lastReminderDate?: SortOrder
    reason?: SortOrder
    creditorId?: SortOrder
    debtorId?: SortOrder
    invoiceId?: SortOrder
    purchaseId?: SortOrder
  }

  export type DebtMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    paymentDate?: SortOrder
    reminderSent?: SortOrder
    lastReminderDate?: SortOrder
    reason?: SortOrder
    creditorId?: SortOrder
    debtorId?: SortOrder
    invoiceId?: SortOrder
    purchaseId?: SortOrder
  }

  export type DebtSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDebtStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtStatus | EnumDebtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtStatusWithAggregatesFilter<$PrismaModel> | $Enums.DebtStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebtStatusFilter<$PrismaModel>
    _max?: NestedEnumDebtStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaserId?: SortOrder
    purchaseId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaserId?: SortOrder
    purchaseId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaserId?: SortOrder
    purchaseId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumUsageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeFilter<$PrismaModel> | $Enums.UsageType
  }

  export type FieldNullableScalarRelationFilter = {
    is?: FieldWhereInput | null
    isNot?: FieldWhereInput | null
  }

  export type ProcessNullableScalarRelationFilter = {
    is?: ProcessWhereInput | null
    isNot?: ProcessWhereInput | null
  }

  export type InventoryUsageCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    usedQuantity?: SortOrder
    usageType?: SortOrder
    usedById?: SortOrder
    fieldId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryUsageAvgOrderByAggregateInput = {
    usedQuantity?: SortOrder
  }

  export type InventoryUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    usedQuantity?: SortOrder
    usageType?: SortOrder
    usedById?: SortOrder
    fieldId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryUsageMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    usedQuantity?: SortOrder
    usageType?: SortOrder
    usedById?: SortOrder
    fieldId?: SortOrder
    processId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryUsageSumOrderByAggregateInput = {
    usedQuantity?: SortOrder
  }

  export type EnumUsageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeWithAggregatesFilter<$PrismaModel> | $Enums.UsageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsageTypeFilter<$PrismaModel>
    _max?: NestedEnumUsageTypeFilter<$PrismaModel>
  }

  export type EnumProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusFilter<$PrismaModel> | $Enums.ProcessStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type ProcessCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    fieldId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
    seasonId?: SortOrder
    inventoryDistribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessAvgOrderByAggregateInput = {
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
  }

  export type ProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    fieldId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
    seasonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    fieldId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
    seasonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessSumOrderByAggregateInput = {
    totalArea?: SortOrder
    processedArea?: SortOrder
    processedPercentage?: SortOrder
  }

  export type EnumProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InventoryNullableScalarRelationFilter = {
    is?: InventoryWhereInput | null
    isNot?: InventoryWhereInput | null
  }

  export type IrrigationLogNullableScalarRelationFilter = {
    is?: IrrigationLogWhereInput | null
    isNot?: IrrigationLogWhereInput | null
  }

  export type CropNullableScalarRelationFilter = {
    is?: CropWhereInput | null
    isNot?: CropWhereInput | null
  }

  export type WellNullableScalarRelationFilter = {
    is?: WellWhereInput | null
    isNot?: WellWhereInput | null
  }

  export type ProcessingLogNullableScalarRelationFilter = {
    is?: ProcessingLogWhereInput | null
    isNot?: ProcessingLogWhereInput | null
  }

  export type InventoryUsageNullableScalarRelationFilter = {
    is?: InventoryUsageWhereInput | null
    isNot?: InventoryUsageWhereInput | null
  }

  export type InventoryTransactionNullableScalarRelationFilter = {
    is?: InventoryTransactionWhereInput | null
    isNot?: InventoryTransactionWhereInput | null
  }

  export type PaymentHistoryNullableScalarRelationFilter = {
    is?: PaymentHistoryWhereInput | null
    isNot?: PaymentHistoryWhereInput | null
  }

  export type PurchaseApprovalNullableScalarRelationFilter = {
    is?: PurchaseApprovalWhereInput | null
    isNot?: PurchaseApprovalWhereInput | null
  }

  export type EquipmentNullableScalarRelationFilter = {
    is?: EquipmentWhereInput | null
    isNot?: EquipmentWhereInput | null
  }

  export type EquipmentUsageNullableScalarRelationFilter = {
    is?: EquipmentUsageWhereInput | null
    isNot?: EquipmentUsageWhereInput | null
  }

  export type ProcessCostNullableScalarRelationFilter = {
    is?: ProcessCostWhereInput | null
    isNot?: ProcessCostWhereInput | null
  }

  export type FieldExpenseNullableScalarRelationFilter = {
    is?: FieldExpenseWhereInput | null
    isNot?: FieldExpenseWhereInput | null
  }

  export type FieldOwnerExpenseNullableScalarRelationFilter = {
    is?: FieldOwnerExpenseWhereInput | null
    isNot?: FieldOwnerExpenseWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    link?: SortOrder
    expiresAt?: SortOrder
    targetRoles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiverId?: SortOrder
    senderId?: SortOrder
    processId?: SortOrder
    debtId?: SortOrder
    purchaseId?: SortOrder
    inventoryId?: SortOrder
    irrigationId?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    cropId?: SortOrder
    wellId?: SortOrder
    processingLogId?: SortOrder
    invoiceId?: SortOrder
    inventoryUsageId?: SortOrder
    transactionId?: SortOrder
    paymentId?: SortOrder
    contributorId?: SortOrder
    approvalId?: SortOrder
    equipmentId?: SortOrder
    equipmentUsageId?: SortOrder
    processCostId?: SortOrder
    fieldExpenseId?: SortOrder
    ownerExpenseId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    link?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiverId?: SortOrder
    senderId?: SortOrder
    processId?: SortOrder
    debtId?: SortOrder
    purchaseId?: SortOrder
    inventoryId?: SortOrder
    irrigationId?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    cropId?: SortOrder
    wellId?: SortOrder
    processingLogId?: SortOrder
    invoiceId?: SortOrder
    inventoryUsageId?: SortOrder
    transactionId?: SortOrder
    paymentId?: SortOrder
    contributorId?: SortOrder
    approvalId?: SortOrder
    equipmentId?: SortOrder
    equipmentUsageId?: SortOrder
    processCostId?: SortOrder
    fieldExpenseId?: SortOrder
    ownerExpenseId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    isArchived?: SortOrder
    link?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiverId?: SortOrder
    senderId?: SortOrder
    processId?: SortOrder
    debtId?: SortOrder
    purchaseId?: SortOrder
    inventoryId?: SortOrder
    irrigationId?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    cropId?: SortOrder
    wellId?: SortOrder
    processingLogId?: SortOrder
    invoiceId?: SortOrder
    inventoryUsageId?: SortOrder
    transactionId?: SortOrder
    paymentId?: SortOrder
    contributorId?: SortOrder
    approvalId?: SortOrder
    equipmentId?: SortOrder
    equipmentUsageId?: SortOrder
    processCostId?: SortOrder
    fieldExpenseId?: SortOrder
    ownerExpenseId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    inAppNotifications?: SortOrder
    dailyDigest?: SortOrder
    notifyOnDebtReminders?: SortOrder
    notifyOnPayments?: SortOrder
    notifyOnProcessUpdates?: SortOrder
    notifyOnInventoryAlerts?: SortOrder
    notifyOnApprovals?: SortOrder
    notifyOnIrrigation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    inAppNotifications?: SortOrder
    dailyDigest?: SortOrder
    notifyOnDebtReminders?: SortOrder
    notifyOnPayments?: SortOrder
    notifyOnProcessUpdates?: SortOrder
    notifyOnInventoryAlerts?: SortOrder
    notifyOnApprovals?: SortOrder
    notifyOnIrrigation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    inAppNotifications?: SortOrder
    dailyDigest?: SortOrder
    notifyOnDebtReminders?: SortOrder
    notifyOnPayments?: SortOrder
    notifyOnProcessUpdates?: SortOrder
    notifyOnInventoryAlerts?: SortOrder
    notifyOnApprovals?: SortOrder
    notifyOnIrrigation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEquipmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeFilter<$PrismaModel> | $Enums.EquipmentType
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type EquipmentCapabilityListRelationFilter = {
    every?: EquipmentCapabilityWhereInput
    some?: EquipmentCapabilityWhereInput
    none?: EquipmentCapabilityWhereInput
  }

  export type EquipmentCapabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fuelConsumptionPerDecare?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    fuelConsumptionPerDecare?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fuelConsumptionPerDecare?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fuelConsumptionPerDecare?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    fuelConsumptionPerDecare?: SortOrder
  }

  export type EnumEquipmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentTypeFilter<$PrismaModel>
    _max?: NestedEnumEquipmentTypeFilter<$PrismaModel>
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type EquipmentOwnershipEquipmentIdUserIdCompoundUniqueInput = {
    equipmentId: string
    userId: string
  }

  export type EquipmentOwnershipCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    ownershipPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentOwnershipAvgOrderByAggregateInput = {
    ownershipPercentage?: SortOrder
  }

  export type EquipmentOwnershipMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    ownershipPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentOwnershipMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    ownershipPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentOwnershipSumOrderByAggregateInput = {
    ownershipPercentage?: SortOrder
  }

  export type EquipmentCapabilityEquipmentIdInventoryCategoryCompoundUniqueInput = {
    equipmentId: string
    inventoryCategory: $Enums.InventoryCategory
  }

  export type EquipmentCapabilityCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    inventoryCategory?: SortOrder
    canUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentCapabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    inventoryCategory?: SortOrder
    canUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentCapabilityMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    inventoryCategory?: SortOrder
    canUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessScalarRelationFilter = {
    is?: ProcessWhereInput
    isNot?: ProcessWhereInput
  }

  export type EquipmentUsageCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentUsageAvgOrderByAggregateInput = {
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
  }

  export type EquipmentUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentUsageMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    equipmentId?: SortOrder
    userId?: SortOrder
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentUsageSumOrderByAggregateInput = {
    areaProcessed?: SortOrder
    processedPercentage?: SortOrder
    fuelConsumed?: SortOrder
  }

  export type ProcessCostCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
  }

  export type ProcessCostAvgOrderByAggregateInput = {
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
  }

  export type ProcessCostMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
  }

  export type ProcessCostMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fieldId?: SortOrder
  }

  export type ProcessCostSumOrderByAggregateInput = {
    laborCost?: SortOrder
    equipmentCost?: SortOrder
    inventoryCost?: SortOrder
    fuelCost?: SortOrder
    totalCost?: SortOrder
  }

  export type SeasonScalarRelationFilter = {
    is?: SeasonWhereInput
    isNot?: SeasonWhereInput
  }

  export type FieldExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    totalCost?: SortOrder
    description?: SortOrder
    expenseDate?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FieldExpenseAvgOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type FieldExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    totalCost?: SortOrder
    description?: SortOrder
    expenseDate?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FieldExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    seasonId?: SortOrder
    totalCost?: SortOrder
    description?: SortOrder
    expenseDate?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FieldExpenseSumOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type FieldOwnershipScalarRelationFilter = {
    is?: FieldOwnershipWhereInput
    isNot?: FieldOwnershipWhereInput
  }

  export type ProcessCostScalarRelationFilter = {
    is?: ProcessCostWhereInput
    isNot?: ProcessCostWhereInput
  }

  export type FieldOwnerExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    fieldOwnershipId?: SortOrder
    processCostId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FieldOwnerExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
    percentage?: SortOrder
  }

  export type FieldOwnerExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldOwnershipId?: SortOrder
    processCostId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FieldOwnerExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    fieldOwnershipId?: SortOrder
    processCostId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FieldOwnerExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
    percentage?: SortOrder
  }

  export type WellBillingIrrigationUsageListRelationFilter = {
    every?: WellBillingIrrigationUsageWhereInput
    some?: WellBillingIrrigationUsageWhereInput
    none?: WellBillingIrrigationUsageWhereInput
  }

  export type WellBillingIrrigationUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IrrigationLogCountOrderByAggregateInput = {
    id?: SortOrder
    startDateTime?: SortOrder
    duration?: SortOrder
    wellId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
  }

  export type IrrigationLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IrrigationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    startDateTime?: SortOrder
    duration?: SortOrder
    wellId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
  }

  export type IrrigationLogMinOrderByAggregateInput = {
    id?: SortOrder
    startDateTime?: SortOrder
    duration?: SortOrder
    wellId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
  }

  export type IrrigationLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IrrigationLogScalarRelationFilter = {
    is?: IrrigationLogWhereInput
    isNot?: IrrigationLogWhereInput
  }

  export type IrrigationFieldUsageCountOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    fieldId?: SortOrder
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationFieldUsageAvgOrderByAggregateInput = {
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
  }

  export type IrrigationFieldUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    fieldId?: SortOrder
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationFieldUsageMinOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    fieldId?: SortOrder
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationFieldUsageSumOrderByAggregateInput = {
    percentage?: SortOrder
    actualIrrigatedArea?: SortOrder
  }

  export type IrrigationFieldUsageScalarRelationFilter = {
    is?: IrrigationFieldUsageWhereInput
    isNot?: IrrigationFieldUsageWhereInput
  }

  export type IrrigationOwnerUsageCountOrderByAggregateInput = {
    id?: SortOrder
    irrigationFieldUsageId?: SortOrder
    ownerId?: SortOrder
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationOwnerUsageAvgOrderByAggregateInput = {
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
  }

  export type IrrigationOwnerUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    irrigationFieldUsageId?: SortOrder
    ownerId?: SortOrder
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationOwnerUsageMinOrderByAggregateInput = {
    id?: SortOrder
    irrigationFieldUsageId?: SortOrder
    ownerId?: SortOrder
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationOwnerUsageSumOrderByAggregateInput = {
    ownershipPercentage?: SortOrder
    usagePercentage?: SortOrder
  }

  export type IrrigationOwnerSummaryIrrigationLogIdOwnerIdCompoundUniqueInput = {
    irrigationLogId: string
    ownerId: string
  }

  export type IrrigationOwnerSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    ownerId?: SortOrder
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationOwnerSummaryAvgOrderByAggregateInput = {
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
  }

  export type IrrigationOwnerSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    ownerId?: SortOrder
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationOwnerSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    ownerId?: SortOrder
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationOwnerSummarySumOrderByAggregateInput = {
    totalIrrigatedArea?: SortOrder
    totalAllocatedDuration?: SortOrder
  }

  export type IrrigationInventoryUsageCountOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationInventoryUsageAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
  }

  export type IrrigationInventoryUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationInventoryUsageMinOrderByAggregateInput = {
    id?: SortOrder
    irrigationLogId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationInventoryUsageSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalCost?: SortOrder
  }

  export type IrrigationInventoryUsageScalarRelationFilter = {
    is?: IrrigationInventoryUsageWhereInput
    isNot?: IrrigationInventoryUsageWhereInput
  }

  export type IrrigationInventoryOwnerUsageCountOrderByAggregateInput = {
    id?: SortOrder
    irrigationInventoryUsageId?: SortOrder
    ownerId?: SortOrder
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationInventoryOwnerUsageAvgOrderByAggregateInput = {
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
  }

  export type IrrigationInventoryOwnerUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    irrigationInventoryUsageId?: SortOrder
    ownerId?: SortOrder
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationInventoryOwnerUsageMinOrderByAggregateInput = {
    id?: SortOrder
    irrigationInventoryUsageId?: SortOrder
    ownerId?: SortOrder
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type IrrigationInventoryOwnerUsageSumOrderByAggregateInput = {
    percentage?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
  }

  export type WellBillingPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    wellId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalAmount?: SortOrder
    totalUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBillingPeriodAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    totalUsage?: SortOrder
  }

  export type WellBillingPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    wellId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalAmount?: SortOrder
    totalUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBillingPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    wellId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalAmount?: SortOrder
    totalUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBillingPeriodSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    totalUsage?: SortOrder
  }

  export type WellBillingPeriodScalarRelationFilter = {
    is?: WellBillingPeriodWhereInput
    isNot?: WellBillingPeriodWhereInput
  }

  export type WellBillingIrrigationUsageCountOrderByAggregateInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    irrigationLogId?: SortOrder
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBillingIrrigationUsageAvgOrderByAggregateInput = {
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
  }

  export type WellBillingIrrigationUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    irrigationLogId?: SortOrder
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBillingIrrigationUsageMinOrderByAggregateInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    irrigationLogId?: SortOrder
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
  }

  export type WellBillingIrrigationUsageSumOrderByAggregateInput = {
    duration?: SortOrder
    percentage?: SortOrder
    amount?: SortOrder
  }

  export type WellBillDistributionWellBillingPeriodIdOwnerIdFieldIdCompoundUniqueInput = {
    wellBillingPeriodId: string
    ownerId: string
    fieldId: string
  }

  export type WellBillDistributionCountOrderByAggregateInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    fieldId?: SortOrder
    ownerId?: SortOrder
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
  }

  export type WellBillDistributionAvgOrderByAggregateInput = {
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
  }

  export type WellBillDistributionMaxOrderByAggregateInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    fieldId?: SortOrder
    ownerId?: SortOrder
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
  }

  export type WellBillDistributionMinOrderByAggregateInput = {
    id?: SortOrder
    wellBillingPeriodId?: SortOrder
    fieldId?: SortOrder
    ownerId?: SortOrder
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    debtId?: SortOrder
  }

  export type WellBillDistributionSumOrderByAggregateInput = {
    basisDuration?: SortOrder
    basisArea?: SortOrder
    basisWeight?: SortOrder
    sharePercentage?: SortOrder
    amount?: SortOrder
  }

  export type IrrigationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<IrrigationLogCreateWithoutUserInput, IrrigationLogUncheckedCreateWithoutUserInput> | IrrigationLogCreateWithoutUserInput[] | IrrigationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutUserInput | IrrigationLogCreateOrConnectWithoutUserInput[]
    createMany?: IrrigationLogCreateManyUserInputEnvelope
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
  }

  export type FieldOwnershipCreateNestedManyWithoutUserInput = {
    create?: XOR<FieldOwnershipCreateWithoutUserInput, FieldOwnershipUncheckedCreateWithoutUserInput> | FieldOwnershipCreateWithoutUserInput[] | FieldOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutUserInput | FieldOwnershipCreateOrConnectWithoutUserInput[]
    createMany?: FieldOwnershipCreateManyUserInputEnvelope
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
  }

  export type FieldWorkerAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutUserInput, FieldWorkerAssignmentUncheckedCreateWithoutUserInput> | FieldWorkerAssignmentCreateWithoutUserInput[] | FieldWorkerAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutUserInput | FieldWorkerAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: FieldWorkerAssignmentCreateManyUserInputEnvelope
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
  }

  export type InventoryOwnershipCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryOwnershipCreateWithoutUserInput, InventoryOwnershipUncheckedCreateWithoutUserInput> | InventoryOwnershipCreateWithoutUserInput[] | InventoryOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutUserInput | InventoryOwnershipCreateOrConnectWithoutUserInput[]
    createMany?: InventoryOwnershipCreateManyUserInputEnvelope
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
  }

  export type DebtCreateNestedManyWithoutCreditorInput = {
    create?: XOR<DebtCreateWithoutCreditorInput, DebtUncheckedCreateWithoutCreditorInput> | DebtCreateWithoutCreditorInput[] | DebtUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutCreditorInput | DebtCreateOrConnectWithoutCreditorInput[]
    createMany?: DebtCreateManyCreditorInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type DebtCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtCreateWithoutDebtorInput, DebtUncheckedCreateWithoutDebtorInput> | DebtCreateWithoutDebtorInput[] | DebtUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutDebtorInput | DebtCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtCreateManyDebtorInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type PurchaseContributorCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseContributorCreateWithoutUserInput, PurchaseContributorUncheckedCreateWithoutUserInput> | PurchaseContributorCreateWithoutUserInput[] | PurchaseContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutUserInput | PurchaseContributorCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseContributorCreateManyUserInputEnvelope
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutReceiverInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InventoryUsageCreateNestedManyWithoutUsedByInput = {
    create?: XOR<InventoryUsageCreateWithoutUsedByInput, InventoryUsageUncheckedCreateWithoutUsedByInput> | InventoryUsageCreateWithoutUsedByInput[] | InventoryUsageUncheckedCreateWithoutUsedByInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutUsedByInput | InventoryUsageCreateOrConnectWithoutUsedByInput[]
    createMany?: InventoryUsageCreateManyUsedByInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutWorkerInput = {
    create?: XOR<ProcessCreateWithoutWorkerInput, ProcessUncheckedCreateWithoutWorkerInput> | ProcessCreateWithoutWorkerInput[] | ProcessUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutWorkerInput | ProcessCreateOrConnectWithoutWorkerInput[]
    createMany?: ProcessCreateManyWorkerInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPurchaserInput = {
    create?: XOR<InvoiceCreateWithoutPurchaserInput, InvoiceUncheckedCreateWithoutPurchaserInput> | InvoiceCreateWithoutPurchaserInput[] | InvoiceUncheckedCreateWithoutPurchaserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaserInput | InvoiceCreateOrConnectWithoutPurchaserInput[]
    createMany?: InvoiceCreateManyPurchaserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentHistoryCreateNestedManyWithoutPayerInput = {
    create?: XOR<PaymentHistoryCreateWithoutPayerInput, PaymentHistoryUncheckedCreateWithoutPayerInput> | PaymentHistoryCreateWithoutPayerInput[] | PaymentHistoryUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutPayerInput | PaymentHistoryCreateOrConnectWithoutPayerInput[]
    createMany?: PaymentHistoryCreateManyPayerInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type PaymentHistoryCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PaymentHistoryCreateWithoutReceiverInput, PaymentHistoryUncheckedCreateWithoutReceiverInput> | PaymentHistoryCreateWithoutReceiverInput[] | PaymentHistoryUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutReceiverInput | PaymentHistoryCreateOrConnectWithoutReceiverInput[]
    createMany?: PaymentHistoryCreateManyReceiverInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type SeasonCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SeasonCreateWithoutCreatorInput, SeasonUncheckedCreateWithoutCreatorInput> | SeasonCreateWithoutCreatorInput[] | SeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCreatorInput | SeasonCreateOrConnectWithoutCreatorInput[]
    createMany?: SeasonCreateManyCreatorInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type PurchaseApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<PurchaseApprovalCreateWithoutApproverInput, PurchaseApprovalUncheckedCreateWithoutApproverInput> | PurchaseApprovalCreateWithoutApproverInput[] | PurchaseApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutApproverInput | PurchaseApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: PurchaseApprovalCreateManyApproverInputEnvelope
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
  }

  export type EquipmentOwnershipCreateNestedManyWithoutUserInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutUserInput, EquipmentOwnershipUncheckedCreateWithoutUserInput> | EquipmentOwnershipCreateWithoutUserInput[] | EquipmentOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutUserInput | EquipmentOwnershipCreateOrConnectWithoutUserInput[]
    createMany?: EquipmentOwnershipCreateManyUserInputEnvelope
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
  }

  export type EquipmentUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<EquipmentUsageCreateWithoutUserInput, EquipmentUsageUncheckedCreateWithoutUserInput> | EquipmentUsageCreateWithoutUserInput[] | EquipmentUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutUserInput | EquipmentUsageCreateOrConnectWithoutUserInput[]
    createMany?: EquipmentUsageCreateManyUserInputEnvelope
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
  }

  export type FieldOwnerExpenseCreateNestedManyWithoutUserInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutUserInput, FieldOwnerExpenseUncheckedCreateWithoutUserInput> | FieldOwnerExpenseCreateWithoutUserInput[] | FieldOwnerExpenseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutUserInput | FieldOwnerExpenseCreateOrConnectWithoutUserInput[]
    createMany?: FieldOwnerExpenseCreateManyUserInputEnvelope
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
  }

  export type WorkerWellAssignmentCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWorkerInput, WorkerWellAssignmentUncheckedCreateWithoutWorkerInput> | WorkerWellAssignmentCreateWithoutWorkerInput[] | WorkerWellAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWorkerInput | WorkerWellAssignmentCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerWellAssignmentCreateManyWorkerInputEnvelope
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutOwnerInput, IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationOwnerUsageCreateWithoutOwnerInput[] | IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput[]
    createMany?: IrrigationOwnerUsageCreateManyOwnerInputEnvelope
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationInventoryOwnerUsageCreateWithoutOwnerInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyOwnerInputEnvelope
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput> | IrrigationOwnerSummaryCreateWithoutOwnerInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput | IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput[]
    createMany?: IrrigationOwnerSummaryCreateManyOwnerInputEnvelope
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
  }

  export type WellBillDistributionCreateNestedManyWithoutOwnerInput = {
    create?: XOR<WellBillDistributionCreateWithoutOwnerInput, WellBillDistributionUncheckedCreateWithoutOwnerInput> | WellBillDistributionCreateWithoutOwnerInput[] | WellBillDistributionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutOwnerInput | WellBillDistributionCreateOrConnectWithoutOwnerInput[]
    createMany?: WellBillDistributionCreateManyOwnerInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type IrrigationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IrrigationLogCreateWithoutUserInput, IrrigationLogUncheckedCreateWithoutUserInput> | IrrigationLogCreateWithoutUserInput[] | IrrigationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutUserInput | IrrigationLogCreateOrConnectWithoutUserInput[]
    createMany?: IrrigationLogCreateManyUserInputEnvelope
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
  }

  export type FieldOwnershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FieldOwnershipCreateWithoutUserInput, FieldOwnershipUncheckedCreateWithoutUserInput> | FieldOwnershipCreateWithoutUserInput[] | FieldOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutUserInput | FieldOwnershipCreateOrConnectWithoutUserInput[]
    createMany?: FieldOwnershipCreateManyUserInputEnvelope
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
  }

  export type FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutUserInput, FieldWorkerAssignmentUncheckedCreateWithoutUserInput> | FieldWorkerAssignmentCreateWithoutUserInput[] | FieldWorkerAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutUserInput | FieldWorkerAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: FieldWorkerAssignmentCreateManyUserInputEnvelope
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
  }

  export type InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryOwnershipCreateWithoutUserInput, InventoryOwnershipUncheckedCreateWithoutUserInput> | InventoryOwnershipCreateWithoutUserInput[] | InventoryOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutUserInput | InventoryOwnershipCreateOrConnectWithoutUserInput[]
    createMany?: InventoryOwnershipCreateManyUserInputEnvelope
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
  }

  export type DebtUncheckedCreateNestedManyWithoutCreditorInput = {
    create?: XOR<DebtCreateWithoutCreditorInput, DebtUncheckedCreateWithoutCreditorInput> | DebtCreateWithoutCreditorInput[] | DebtUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutCreditorInput | DebtCreateOrConnectWithoutCreditorInput[]
    createMany?: DebtCreateManyCreditorInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type DebtUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtCreateWithoutDebtorInput, DebtUncheckedCreateWithoutDebtorInput> | DebtCreateWithoutDebtorInput[] | DebtUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutDebtorInput | DebtCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtCreateManyDebtorInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type PurchaseContributorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseContributorCreateWithoutUserInput, PurchaseContributorUncheckedCreateWithoutUserInput> | PurchaseContributorCreateWithoutUserInput[] | PurchaseContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutUserInput | PurchaseContributorCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseContributorCreateManyUserInputEnvelope
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput = {
    create?: XOR<InventoryUsageCreateWithoutUsedByInput, InventoryUsageUncheckedCreateWithoutUsedByInput> | InventoryUsageCreateWithoutUsedByInput[] | InventoryUsageUncheckedCreateWithoutUsedByInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutUsedByInput | InventoryUsageCreateOrConnectWithoutUsedByInput[]
    createMany?: InventoryUsageCreateManyUsedByInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<ProcessCreateWithoutWorkerInput, ProcessUncheckedCreateWithoutWorkerInput> | ProcessCreateWithoutWorkerInput[] | ProcessUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutWorkerInput | ProcessCreateOrConnectWithoutWorkerInput[]
    createMany?: ProcessCreateManyWorkerInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPurchaserInput = {
    create?: XOR<InvoiceCreateWithoutPurchaserInput, InvoiceUncheckedCreateWithoutPurchaserInput> | InvoiceCreateWithoutPurchaserInput[] | InvoiceUncheckedCreateWithoutPurchaserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaserInput | InvoiceCreateOrConnectWithoutPurchaserInput[]
    createMany?: InvoiceCreateManyPurchaserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput = {
    create?: XOR<PaymentHistoryCreateWithoutPayerInput, PaymentHistoryUncheckedCreateWithoutPayerInput> | PaymentHistoryCreateWithoutPayerInput[] | PaymentHistoryUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutPayerInput | PaymentHistoryCreateOrConnectWithoutPayerInput[]
    createMany?: PaymentHistoryCreateManyPayerInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PaymentHistoryCreateWithoutReceiverInput, PaymentHistoryUncheckedCreateWithoutReceiverInput> | PaymentHistoryCreateWithoutReceiverInput[] | PaymentHistoryUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutReceiverInput | PaymentHistoryCreateOrConnectWithoutReceiverInput[]
    createMany?: PaymentHistoryCreateManyReceiverInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type SeasonUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SeasonCreateWithoutCreatorInput, SeasonUncheckedCreateWithoutCreatorInput> | SeasonCreateWithoutCreatorInput[] | SeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCreatorInput | SeasonCreateOrConnectWithoutCreatorInput[]
    createMany?: SeasonCreateManyCreatorInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<PurchaseApprovalCreateWithoutApproverInput, PurchaseApprovalUncheckedCreateWithoutApproverInput> | PurchaseApprovalCreateWithoutApproverInput[] | PurchaseApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutApproverInput | PurchaseApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: PurchaseApprovalCreateManyApproverInputEnvelope
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
  }

  export type EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutUserInput, EquipmentOwnershipUncheckedCreateWithoutUserInput> | EquipmentOwnershipCreateWithoutUserInput[] | EquipmentOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutUserInput | EquipmentOwnershipCreateOrConnectWithoutUserInput[]
    createMany?: EquipmentOwnershipCreateManyUserInputEnvelope
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
  }

  export type EquipmentUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EquipmentUsageCreateWithoutUserInput, EquipmentUsageUncheckedCreateWithoutUserInput> | EquipmentUsageCreateWithoutUserInput[] | EquipmentUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutUserInput | EquipmentUsageCreateOrConnectWithoutUserInput[]
    createMany?: EquipmentUsageCreateManyUserInputEnvelope
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
  }

  export type FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutUserInput, FieldOwnerExpenseUncheckedCreateWithoutUserInput> | FieldOwnerExpenseCreateWithoutUserInput[] | FieldOwnerExpenseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutUserInput | FieldOwnerExpenseCreateOrConnectWithoutUserInput[]
    createMany?: FieldOwnerExpenseCreateManyUserInputEnvelope
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
  }

  export type WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWorkerInput, WorkerWellAssignmentUncheckedCreateWithoutWorkerInput> | WorkerWellAssignmentCreateWithoutWorkerInput[] | WorkerWellAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWorkerInput | WorkerWellAssignmentCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerWellAssignmentCreateManyWorkerInputEnvelope
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutOwnerInput, IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationOwnerUsageCreateWithoutOwnerInput[] | IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput[]
    createMany?: IrrigationOwnerUsageCreateManyOwnerInputEnvelope
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationInventoryOwnerUsageCreateWithoutOwnerInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyOwnerInputEnvelope
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput> | IrrigationOwnerSummaryCreateWithoutOwnerInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput | IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput[]
    createMany?: IrrigationOwnerSummaryCreateManyOwnerInputEnvelope
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
  }

  export type WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<WellBillDistributionCreateWithoutOwnerInput, WellBillDistributionUncheckedCreateWithoutOwnerInput> | WellBillDistributionCreateWithoutOwnerInput[] | WellBillDistributionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutOwnerInput | WellBillDistributionCreateOrConnectWithoutOwnerInput[]
    createMany?: WellBillDistributionCreateManyOwnerInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IrrigationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutUserInput, IrrigationLogUncheckedCreateWithoutUserInput> | IrrigationLogCreateWithoutUserInput[] | IrrigationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutUserInput | IrrigationLogCreateOrConnectWithoutUserInput[]
    upsert?: IrrigationLogUpsertWithWhereUniqueWithoutUserInput | IrrigationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IrrigationLogCreateManyUserInputEnvelope
    set?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    disconnect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    delete?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    update?: IrrigationLogUpdateWithWhereUniqueWithoutUserInput | IrrigationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IrrigationLogUpdateManyWithWhereWithoutUserInput | IrrigationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
  }

  export type FieldOwnershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<FieldOwnershipCreateWithoutUserInput, FieldOwnershipUncheckedCreateWithoutUserInput> | FieldOwnershipCreateWithoutUserInput[] | FieldOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutUserInput | FieldOwnershipCreateOrConnectWithoutUserInput[]
    upsert?: FieldOwnershipUpsertWithWhereUniqueWithoutUserInput | FieldOwnershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FieldOwnershipCreateManyUserInputEnvelope
    set?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    disconnect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    delete?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    update?: FieldOwnershipUpdateWithWhereUniqueWithoutUserInput | FieldOwnershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FieldOwnershipUpdateManyWithWhereWithoutUserInput | FieldOwnershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FieldOwnershipScalarWhereInput | FieldOwnershipScalarWhereInput[]
  }

  export type FieldWorkerAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutUserInput, FieldWorkerAssignmentUncheckedCreateWithoutUserInput> | FieldWorkerAssignmentCreateWithoutUserInput[] | FieldWorkerAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutUserInput | FieldWorkerAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: FieldWorkerAssignmentUpsertWithWhereUniqueWithoutUserInput | FieldWorkerAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FieldWorkerAssignmentCreateManyUserInputEnvelope
    set?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    disconnect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    delete?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    update?: FieldWorkerAssignmentUpdateWithWhereUniqueWithoutUserInput | FieldWorkerAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FieldWorkerAssignmentUpdateManyWithWhereWithoutUserInput | FieldWorkerAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FieldWorkerAssignmentScalarWhereInput | FieldWorkerAssignmentScalarWhereInput[]
  }

  export type InventoryOwnershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryOwnershipCreateWithoutUserInput, InventoryOwnershipUncheckedCreateWithoutUserInput> | InventoryOwnershipCreateWithoutUserInput[] | InventoryOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutUserInput | InventoryOwnershipCreateOrConnectWithoutUserInput[]
    upsert?: InventoryOwnershipUpsertWithWhereUniqueWithoutUserInput | InventoryOwnershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryOwnershipCreateManyUserInputEnvelope
    set?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    disconnect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    delete?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    update?: InventoryOwnershipUpdateWithWhereUniqueWithoutUserInput | InventoryOwnershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryOwnershipUpdateManyWithWhereWithoutUserInput | InventoryOwnershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryOwnershipScalarWhereInput | InventoryOwnershipScalarWhereInput[]
  }

  export type DebtUpdateManyWithoutCreditorNestedInput = {
    create?: XOR<DebtCreateWithoutCreditorInput, DebtUncheckedCreateWithoutCreditorInput> | DebtCreateWithoutCreditorInput[] | DebtUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutCreditorInput | DebtCreateOrConnectWithoutCreditorInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutCreditorInput | DebtUpsertWithWhereUniqueWithoutCreditorInput[]
    createMany?: DebtCreateManyCreditorInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutCreditorInput | DebtUpdateWithWhereUniqueWithoutCreditorInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutCreditorInput | DebtUpdateManyWithWhereWithoutCreditorInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type DebtUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtCreateWithoutDebtorInput, DebtUncheckedCreateWithoutDebtorInput> | DebtCreateWithoutDebtorInput[] | DebtUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutDebtorInput | DebtCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutDebtorInput | DebtUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtCreateManyDebtorInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutDebtorInput | DebtUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutDebtorInput | DebtUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type PurchaseContributorUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseContributorCreateWithoutUserInput, PurchaseContributorUncheckedCreateWithoutUserInput> | PurchaseContributorCreateWithoutUserInput[] | PurchaseContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutUserInput | PurchaseContributorCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseContributorUpsertWithWhereUniqueWithoutUserInput | PurchaseContributorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseContributorCreateManyUserInputEnvelope
    set?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    disconnect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    delete?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    update?: PurchaseContributorUpdateWithWhereUniqueWithoutUserInput | PurchaseContributorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseContributorUpdateManyWithWhereWithoutUserInput | PurchaseContributorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseContributorScalarWhereInput | PurchaseContributorScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutReceiverInput | NotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutReceiverInput | NotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutReceiverInput | NotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InventoryUsageUpdateManyWithoutUsedByNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutUsedByInput, InventoryUsageUncheckedCreateWithoutUsedByInput> | InventoryUsageCreateWithoutUsedByInput[] | InventoryUsageUncheckedCreateWithoutUsedByInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutUsedByInput | InventoryUsageCreateOrConnectWithoutUsedByInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutUsedByInput | InventoryUsageUpsertWithWhereUniqueWithoutUsedByInput[]
    createMany?: InventoryUsageCreateManyUsedByInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutUsedByInput | InventoryUsageUpdateWithWhereUniqueWithoutUsedByInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutUsedByInput | InventoryUsageUpdateManyWithWhereWithoutUsedByInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<ProcessCreateWithoutWorkerInput, ProcessUncheckedCreateWithoutWorkerInput> | ProcessCreateWithoutWorkerInput[] | ProcessUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutWorkerInput | ProcessCreateOrConnectWithoutWorkerInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutWorkerInput | ProcessUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: ProcessCreateManyWorkerInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutWorkerInput | ProcessUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutWorkerInput | ProcessUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPurchaserNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchaserInput, InvoiceUncheckedCreateWithoutPurchaserInput> | InvoiceCreateWithoutPurchaserInput[] | InvoiceUncheckedCreateWithoutPurchaserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaserInput | InvoiceCreateOrConnectWithoutPurchaserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPurchaserInput | InvoiceUpsertWithWhereUniqueWithoutPurchaserInput[]
    createMany?: InvoiceCreateManyPurchaserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPurchaserInput | InvoiceUpdateWithWhereUniqueWithoutPurchaserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPurchaserInput | InvoiceUpdateManyWithWhereWithoutPurchaserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentHistoryUpdateManyWithoutPayerNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutPayerInput, PaymentHistoryUncheckedCreateWithoutPayerInput> | PaymentHistoryCreateWithoutPayerInput[] | PaymentHistoryUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutPayerInput | PaymentHistoryCreateOrConnectWithoutPayerInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutPayerInput | PaymentHistoryUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: PaymentHistoryCreateManyPayerInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutPayerInput | PaymentHistoryUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutPayerInput | PaymentHistoryUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type PaymentHistoryUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutReceiverInput, PaymentHistoryUncheckedCreateWithoutReceiverInput> | PaymentHistoryCreateWithoutReceiverInput[] | PaymentHistoryUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutReceiverInput | PaymentHistoryCreateOrConnectWithoutReceiverInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutReceiverInput | PaymentHistoryUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PaymentHistoryCreateManyReceiverInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutReceiverInput | PaymentHistoryUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutReceiverInput | PaymentHistoryUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutUserInput | InventoryTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutUserInput | InventoryTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutUserInput | InventoryTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type SeasonUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SeasonCreateWithoutCreatorInput, SeasonUncheckedCreateWithoutCreatorInput> | SeasonCreateWithoutCreatorInput[] | SeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCreatorInput | SeasonCreateOrConnectWithoutCreatorInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutCreatorInput | SeasonUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SeasonCreateManyCreatorInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutCreatorInput | SeasonUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutCreatorInput | SeasonUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type PurchaseApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PurchaseApprovalCreateWithoutApproverInput, PurchaseApprovalUncheckedCreateWithoutApproverInput> | PurchaseApprovalCreateWithoutApproverInput[] | PurchaseApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutApproverInput | PurchaseApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: PurchaseApprovalUpsertWithWhereUniqueWithoutApproverInput | PurchaseApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PurchaseApprovalCreateManyApproverInputEnvelope
    set?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    disconnect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    delete?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    update?: PurchaseApprovalUpdateWithWhereUniqueWithoutApproverInput | PurchaseApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PurchaseApprovalUpdateManyWithWhereWithoutApproverInput | PurchaseApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PurchaseApprovalScalarWhereInput | PurchaseApprovalScalarWhereInput[]
  }

  export type EquipmentOwnershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutUserInput, EquipmentOwnershipUncheckedCreateWithoutUserInput> | EquipmentOwnershipCreateWithoutUserInput[] | EquipmentOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutUserInput | EquipmentOwnershipCreateOrConnectWithoutUserInput[]
    upsert?: EquipmentOwnershipUpsertWithWhereUniqueWithoutUserInput | EquipmentOwnershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EquipmentOwnershipCreateManyUserInputEnvelope
    set?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    disconnect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    delete?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    update?: EquipmentOwnershipUpdateWithWhereUniqueWithoutUserInput | EquipmentOwnershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EquipmentOwnershipUpdateManyWithWhereWithoutUserInput | EquipmentOwnershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EquipmentOwnershipScalarWhereInput | EquipmentOwnershipScalarWhereInput[]
  }

  export type EquipmentUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutUserInput, EquipmentUsageUncheckedCreateWithoutUserInput> | EquipmentUsageCreateWithoutUserInput[] | EquipmentUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutUserInput | EquipmentUsageCreateOrConnectWithoutUserInput[]
    upsert?: EquipmentUsageUpsertWithWhereUniqueWithoutUserInput | EquipmentUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EquipmentUsageCreateManyUserInputEnvelope
    set?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    disconnect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    delete?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    update?: EquipmentUsageUpdateWithWhereUniqueWithoutUserInput | EquipmentUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EquipmentUsageUpdateManyWithWhereWithoutUserInput | EquipmentUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
  }

  export type FieldOwnerExpenseUpdateManyWithoutUserNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutUserInput, FieldOwnerExpenseUncheckedCreateWithoutUserInput> | FieldOwnerExpenseCreateWithoutUserInput[] | FieldOwnerExpenseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutUserInput | FieldOwnerExpenseCreateOrConnectWithoutUserInput[]
    upsert?: FieldOwnerExpenseUpsertWithWhereUniqueWithoutUserInput | FieldOwnerExpenseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FieldOwnerExpenseCreateManyUserInputEnvelope
    set?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    disconnect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    delete?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    update?: FieldOwnerExpenseUpdateWithWhereUniqueWithoutUserInput | FieldOwnerExpenseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FieldOwnerExpenseUpdateManyWithWhereWithoutUserInput | FieldOwnerExpenseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
  }

  export type WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWorkerInput, WorkerWellAssignmentUncheckedCreateWithoutWorkerInput> | WorkerWellAssignmentCreateWithoutWorkerInput[] | WorkerWellAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWorkerInput | WorkerWellAssignmentCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerWellAssignmentUpsertWithWhereUniqueWithoutWorkerInput | WorkerWellAssignmentUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerWellAssignmentCreateManyWorkerInputEnvelope
    set?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    disconnect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    delete?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    update?: WorkerWellAssignmentUpdateWithWhereUniqueWithoutWorkerInput | WorkerWellAssignmentUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerWellAssignmentUpdateManyWithWhereWithoutWorkerInput | WorkerWellAssignmentUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerWellAssignmentScalarWhereInput | WorkerWellAssignmentScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutOwnerInput, IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationOwnerUsageCreateWithoutOwnerInput[] | IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput[]
    upsert?: IrrigationOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput | IrrigationOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: IrrigationOwnerUsageCreateManyOwnerInputEnvelope
    set?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    delete?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    update?: IrrigationOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput | IrrigationOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: IrrigationOwnerUsageUpdateManyWithWhereWithoutOwnerInput | IrrigationOwnerUsageUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: IrrigationOwnerUsageScalarWhereInput | IrrigationOwnerUsageScalarWhereInput[]
  }

  export type IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationInventoryOwnerUsageCreateWithoutOwnerInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput[]
    upsert?: IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput | IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyOwnerInputEnvelope
    set?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    delete?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    update?: IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput | IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutOwnerInput | IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: IrrigationInventoryOwnerUsageScalarWhereInput | IrrigationInventoryOwnerUsageScalarWhereInput[]
  }

  export type IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput> | IrrigationOwnerSummaryCreateWithoutOwnerInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput | IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput[]
    upsert?: IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutOwnerInput | IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: IrrigationOwnerSummaryCreateManyOwnerInputEnvelope
    set?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    disconnect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    delete?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    update?: IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutOwnerInput | IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: IrrigationOwnerSummaryUpdateManyWithWhereWithoutOwnerInput | IrrigationOwnerSummaryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: IrrigationOwnerSummaryScalarWhereInput | IrrigationOwnerSummaryScalarWhereInput[]
  }

  export type WellBillDistributionUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutOwnerInput, WellBillDistributionUncheckedCreateWithoutOwnerInput> | WellBillDistributionCreateWithoutOwnerInput[] | WellBillDistributionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutOwnerInput | WellBillDistributionCreateOrConnectWithoutOwnerInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutOwnerInput | WellBillDistributionUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: WellBillDistributionCreateManyOwnerInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutOwnerInput | WellBillDistributionUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutOwnerInput | WellBillDistributionUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type IrrigationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutUserInput, IrrigationLogUncheckedCreateWithoutUserInput> | IrrigationLogCreateWithoutUserInput[] | IrrigationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutUserInput | IrrigationLogCreateOrConnectWithoutUserInput[]
    upsert?: IrrigationLogUpsertWithWhereUniqueWithoutUserInput | IrrigationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IrrigationLogCreateManyUserInputEnvelope
    set?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    disconnect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    delete?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    update?: IrrigationLogUpdateWithWhereUniqueWithoutUserInput | IrrigationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IrrigationLogUpdateManyWithWhereWithoutUserInput | IrrigationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
  }

  export type FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FieldOwnershipCreateWithoutUserInput, FieldOwnershipUncheckedCreateWithoutUserInput> | FieldOwnershipCreateWithoutUserInput[] | FieldOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutUserInput | FieldOwnershipCreateOrConnectWithoutUserInput[]
    upsert?: FieldOwnershipUpsertWithWhereUniqueWithoutUserInput | FieldOwnershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FieldOwnershipCreateManyUserInputEnvelope
    set?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    disconnect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    delete?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    update?: FieldOwnershipUpdateWithWhereUniqueWithoutUserInput | FieldOwnershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FieldOwnershipUpdateManyWithWhereWithoutUserInput | FieldOwnershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FieldOwnershipScalarWhereInput | FieldOwnershipScalarWhereInput[]
  }

  export type FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutUserInput, FieldWorkerAssignmentUncheckedCreateWithoutUserInput> | FieldWorkerAssignmentCreateWithoutUserInput[] | FieldWorkerAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutUserInput | FieldWorkerAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: FieldWorkerAssignmentUpsertWithWhereUniqueWithoutUserInput | FieldWorkerAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FieldWorkerAssignmentCreateManyUserInputEnvelope
    set?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    disconnect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    delete?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    update?: FieldWorkerAssignmentUpdateWithWhereUniqueWithoutUserInput | FieldWorkerAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FieldWorkerAssignmentUpdateManyWithWhereWithoutUserInput | FieldWorkerAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FieldWorkerAssignmentScalarWhereInput | FieldWorkerAssignmentScalarWhereInput[]
  }

  export type InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryOwnershipCreateWithoutUserInput, InventoryOwnershipUncheckedCreateWithoutUserInput> | InventoryOwnershipCreateWithoutUserInput[] | InventoryOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutUserInput | InventoryOwnershipCreateOrConnectWithoutUserInput[]
    upsert?: InventoryOwnershipUpsertWithWhereUniqueWithoutUserInput | InventoryOwnershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryOwnershipCreateManyUserInputEnvelope
    set?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    disconnect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    delete?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    update?: InventoryOwnershipUpdateWithWhereUniqueWithoutUserInput | InventoryOwnershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryOwnershipUpdateManyWithWhereWithoutUserInput | InventoryOwnershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryOwnershipScalarWhereInput | InventoryOwnershipScalarWhereInput[]
  }

  export type DebtUncheckedUpdateManyWithoutCreditorNestedInput = {
    create?: XOR<DebtCreateWithoutCreditorInput, DebtUncheckedCreateWithoutCreditorInput> | DebtCreateWithoutCreditorInput[] | DebtUncheckedCreateWithoutCreditorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutCreditorInput | DebtCreateOrConnectWithoutCreditorInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutCreditorInput | DebtUpsertWithWhereUniqueWithoutCreditorInput[]
    createMany?: DebtCreateManyCreditorInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutCreditorInput | DebtUpdateWithWhereUniqueWithoutCreditorInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutCreditorInput | DebtUpdateManyWithWhereWithoutCreditorInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type DebtUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtCreateWithoutDebtorInput, DebtUncheckedCreateWithoutDebtorInput> | DebtCreateWithoutDebtorInput[] | DebtUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutDebtorInput | DebtCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutDebtorInput | DebtUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtCreateManyDebtorInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutDebtorInput | DebtUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutDebtorInput | DebtUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseContributorCreateWithoutUserInput, PurchaseContributorUncheckedCreateWithoutUserInput> | PurchaseContributorCreateWithoutUserInput[] | PurchaseContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutUserInput | PurchaseContributorCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseContributorUpsertWithWhereUniqueWithoutUserInput | PurchaseContributorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseContributorCreateManyUserInputEnvelope
    set?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    disconnect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    delete?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    update?: PurchaseContributorUpdateWithWhereUniqueWithoutUserInput | PurchaseContributorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseContributorUpdateManyWithWhereWithoutUserInput | PurchaseContributorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseContributorScalarWhereInput | PurchaseContributorScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutReceiverInput | NotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutReceiverInput | NotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutReceiverInput | NotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutUsedByInput, InventoryUsageUncheckedCreateWithoutUsedByInput> | InventoryUsageCreateWithoutUsedByInput[] | InventoryUsageUncheckedCreateWithoutUsedByInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutUsedByInput | InventoryUsageCreateOrConnectWithoutUsedByInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutUsedByInput | InventoryUsageUpsertWithWhereUniqueWithoutUsedByInput[]
    createMany?: InventoryUsageCreateManyUsedByInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutUsedByInput | InventoryUsageUpdateWithWhereUniqueWithoutUsedByInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutUsedByInput | InventoryUsageUpdateManyWithWhereWithoutUsedByInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<ProcessCreateWithoutWorkerInput, ProcessUncheckedCreateWithoutWorkerInput> | ProcessCreateWithoutWorkerInput[] | ProcessUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutWorkerInput | ProcessCreateOrConnectWithoutWorkerInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutWorkerInput | ProcessUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: ProcessCreateManyWorkerInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutWorkerInput | ProcessUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutWorkerInput | ProcessUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchaserInput, InvoiceUncheckedCreateWithoutPurchaserInput> | InvoiceCreateWithoutPurchaserInput[] | InvoiceUncheckedCreateWithoutPurchaserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaserInput | InvoiceCreateOrConnectWithoutPurchaserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPurchaserInput | InvoiceUpsertWithWhereUniqueWithoutPurchaserInput[]
    createMany?: InvoiceCreateManyPurchaserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPurchaserInput | InvoiceUpdateWithWhereUniqueWithoutPurchaserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPurchaserInput | InvoiceUpdateManyWithWhereWithoutPurchaserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutPayerInput, PaymentHistoryUncheckedCreateWithoutPayerInput> | PaymentHistoryCreateWithoutPayerInput[] | PaymentHistoryUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutPayerInput | PaymentHistoryCreateOrConnectWithoutPayerInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutPayerInput | PaymentHistoryUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: PaymentHistoryCreateManyPayerInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutPayerInput | PaymentHistoryUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutPayerInput | PaymentHistoryUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutReceiverInput, PaymentHistoryUncheckedCreateWithoutReceiverInput> | PaymentHistoryCreateWithoutReceiverInput[] | PaymentHistoryUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutReceiverInput | PaymentHistoryCreateOrConnectWithoutReceiverInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutReceiverInput | PaymentHistoryUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PaymentHistoryCreateManyReceiverInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutReceiverInput | PaymentHistoryUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutReceiverInput | PaymentHistoryUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutUserInput | InventoryTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutUserInput | InventoryTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutUserInput | InventoryTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type SeasonUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SeasonCreateWithoutCreatorInput, SeasonUncheckedCreateWithoutCreatorInput> | SeasonCreateWithoutCreatorInput[] | SeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutCreatorInput | SeasonCreateOrConnectWithoutCreatorInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutCreatorInput | SeasonUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SeasonCreateManyCreatorInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutCreatorInput | SeasonUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutCreatorInput | SeasonUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PurchaseApprovalCreateWithoutApproverInput, PurchaseApprovalUncheckedCreateWithoutApproverInput> | PurchaseApprovalCreateWithoutApproverInput[] | PurchaseApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutApproverInput | PurchaseApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: PurchaseApprovalUpsertWithWhereUniqueWithoutApproverInput | PurchaseApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PurchaseApprovalCreateManyApproverInputEnvelope
    set?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    disconnect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    delete?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    update?: PurchaseApprovalUpdateWithWhereUniqueWithoutApproverInput | PurchaseApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PurchaseApprovalUpdateManyWithWhereWithoutApproverInput | PurchaseApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PurchaseApprovalScalarWhereInput | PurchaseApprovalScalarWhereInput[]
  }

  export type EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutUserInput, EquipmentOwnershipUncheckedCreateWithoutUserInput> | EquipmentOwnershipCreateWithoutUserInput[] | EquipmentOwnershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutUserInput | EquipmentOwnershipCreateOrConnectWithoutUserInput[]
    upsert?: EquipmentOwnershipUpsertWithWhereUniqueWithoutUserInput | EquipmentOwnershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EquipmentOwnershipCreateManyUserInputEnvelope
    set?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    disconnect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    delete?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    update?: EquipmentOwnershipUpdateWithWhereUniqueWithoutUserInput | EquipmentOwnershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EquipmentOwnershipUpdateManyWithWhereWithoutUserInput | EquipmentOwnershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EquipmentOwnershipScalarWhereInput | EquipmentOwnershipScalarWhereInput[]
  }

  export type EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutUserInput, EquipmentUsageUncheckedCreateWithoutUserInput> | EquipmentUsageCreateWithoutUserInput[] | EquipmentUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutUserInput | EquipmentUsageCreateOrConnectWithoutUserInput[]
    upsert?: EquipmentUsageUpsertWithWhereUniqueWithoutUserInput | EquipmentUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EquipmentUsageCreateManyUserInputEnvelope
    set?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    disconnect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    delete?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    update?: EquipmentUsageUpdateWithWhereUniqueWithoutUserInput | EquipmentUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EquipmentUsageUpdateManyWithWhereWithoutUserInput | EquipmentUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
  }

  export type FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutUserInput, FieldOwnerExpenseUncheckedCreateWithoutUserInput> | FieldOwnerExpenseCreateWithoutUserInput[] | FieldOwnerExpenseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutUserInput | FieldOwnerExpenseCreateOrConnectWithoutUserInput[]
    upsert?: FieldOwnerExpenseUpsertWithWhereUniqueWithoutUserInput | FieldOwnerExpenseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FieldOwnerExpenseCreateManyUserInputEnvelope
    set?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    disconnect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    delete?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    update?: FieldOwnerExpenseUpdateWithWhereUniqueWithoutUserInput | FieldOwnerExpenseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FieldOwnerExpenseUpdateManyWithWhereWithoutUserInput | FieldOwnerExpenseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
  }

  export type WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWorkerInput, WorkerWellAssignmentUncheckedCreateWithoutWorkerInput> | WorkerWellAssignmentCreateWithoutWorkerInput[] | WorkerWellAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWorkerInput | WorkerWellAssignmentCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerWellAssignmentUpsertWithWhereUniqueWithoutWorkerInput | WorkerWellAssignmentUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerWellAssignmentCreateManyWorkerInputEnvelope
    set?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    disconnect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    delete?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    update?: WorkerWellAssignmentUpdateWithWhereUniqueWithoutWorkerInput | WorkerWellAssignmentUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerWellAssignmentUpdateManyWithWhereWithoutWorkerInput | WorkerWellAssignmentUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerWellAssignmentScalarWhereInput | WorkerWellAssignmentScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutOwnerInput, IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationOwnerUsageCreateWithoutOwnerInput[] | IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput[]
    upsert?: IrrigationOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput | IrrigationOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: IrrigationOwnerUsageCreateManyOwnerInputEnvelope
    set?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    delete?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    update?: IrrigationOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput | IrrigationOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: IrrigationOwnerUsageUpdateManyWithWhereWithoutOwnerInput | IrrigationOwnerUsageUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: IrrigationOwnerUsageScalarWhereInput | IrrigationOwnerUsageScalarWhereInput[]
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput> | IrrigationInventoryOwnerUsageCreateWithoutOwnerInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput[]
    upsert?: IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput | IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyOwnerInputEnvelope
    set?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    delete?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    update?: IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput | IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutOwnerInput | IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: IrrigationInventoryOwnerUsageScalarWhereInput | IrrigationInventoryOwnerUsageScalarWhereInput[]
  }

  export type IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput> | IrrigationOwnerSummaryCreateWithoutOwnerInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput | IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput[]
    upsert?: IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutOwnerInput | IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: IrrigationOwnerSummaryCreateManyOwnerInputEnvelope
    set?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    disconnect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    delete?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    update?: IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutOwnerInput | IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: IrrigationOwnerSummaryUpdateManyWithWhereWithoutOwnerInput | IrrigationOwnerSummaryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: IrrigationOwnerSummaryScalarWhereInput | IrrigationOwnerSummaryScalarWhereInput[]
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutOwnerInput, WellBillDistributionUncheckedCreateWithoutOwnerInput> | WellBillDistributionCreateWithoutOwnerInput[] | WellBillDistributionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutOwnerInput | WellBillDistributionCreateOrConnectWithoutOwnerInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutOwnerInput | WellBillDistributionUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: WellBillDistributionCreateManyOwnerInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutOwnerInput | WellBillDistributionUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutOwnerInput | WellBillDistributionUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<UserCreateWithoutSeasonsInput, UserUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSeasonsInput
    connect?: UserWhereUniqueInput
  }

  export type FieldCreateNestedManyWithoutSeasonInput = {
    create?: XOR<FieldCreateWithoutSeasonInput, FieldUncheckedCreateWithoutSeasonInput> | FieldCreateWithoutSeasonInput[] | FieldUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutSeasonInput | FieldCreateOrConnectWithoutSeasonInput[]
    createMany?: FieldCreateManySeasonInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type CropCreateNestedManyWithoutSeasonInput = {
    create?: XOR<CropCreateWithoutSeasonInput, CropUncheckedCreateWithoutSeasonInput> | CropCreateWithoutSeasonInput[] | CropUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: CropCreateOrConnectWithoutSeasonInput | CropCreateOrConnectWithoutSeasonInput[]
    createMany?: CropCreateManySeasonInputEnvelope
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutSeasonInput = {
    create?: XOR<PurchaseCreateWithoutSeasonInput, PurchaseUncheckedCreateWithoutSeasonInput> | PurchaseCreateWithoutSeasonInput[] | PurchaseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSeasonInput | PurchaseCreateOrConnectWithoutSeasonInput[]
    createMany?: PurchaseCreateManySeasonInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutSeasonInput = {
    create?: XOR<InventoryTransactionCreateWithoutSeasonInput, InventoryTransactionUncheckedCreateWithoutSeasonInput> | InventoryTransactionCreateWithoutSeasonInput[] | InventoryTransactionUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutSeasonInput | InventoryTransactionCreateOrConnectWithoutSeasonInput[]
    createMany?: InventoryTransactionCreateManySeasonInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutSeasonInput = {
    create?: XOR<ProcessCreateWithoutSeasonInput, ProcessUncheckedCreateWithoutSeasonInput> | ProcessCreateWithoutSeasonInput[] | ProcessUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutSeasonInput | ProcessCreateOrConnectWithoutSeasonInput[]
    createMany?: ProcessCreateManySeasonInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type IrrigationLogCreateNestedManyWithoutSeasonInput = {
    create?: XOR<IrrigationLogCreateWithoutSeasonInput, IrrigationLogUncheckedCreateWithoutSeasonInput> | IrrigationLogCreateWithoutSeasonInput[] | IrrigationLogUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutSeasonInput | IrrigationLogCreateOrConnectWithoutSeasonInput[]
    createMany?: IrrigationLogCreateManySeasonInputEnvelope
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
  }

  export type FieldExpenseCreateNestedManyWithoutSeasonInput = {
    create?: XOR<FieldExpenseCreateWithoutSeasonInput, FieldExpenseUncheckedCreateWithoutSeasonInput> | FieldExpenseCreateWithoutSeasonInput[] | FieldExpenseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutSeasonInput | FieldExpenseCreateOrConnectWithoutSeasonInput[]
    createMany?: FieldExpenseCreateManySeasonInputEnvelope
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSeasonInput = {
    create?: XOR<NotificationCreateWithoutSeasonInput, NotificationUncheckedCreateWithoutSeasonInput> | NotificationCreateWithoutSeasonInput[] | NotificationUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSeasonInput | NotificationCreateOrConnectWithoutSeasonInput[]
    createMany?: NotificationCreateManySeasonInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FieldUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<FieldCreateWithoutSeasonInput, FieldUncheckedCreateWithoutSeasonInput> | FieldCreateWithoutSeasonInput[] | FieldUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutSeasonInput | FieldCreateOrConnectWithoutSeasonInput[]
    createMany?: FieldCreateManySeasonInputEnvelope
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
  }

  export type CropUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<CropCreateWithoutSeasonInput, CropUncheckedCreateWithoutSeasonInput> | CropCreateWithoutSeasonInput[] | CropUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: CropCreateOrConnectWithoutSeasonInput | CropCreateOrConnectWithoutSeasonInput[]
    createMany?: CropCreateManySeasonInputEnvelope
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<PurchaseCreateWithoutSeasonInput, PurchaseUncheckedCreateWithoutSeasonInput> | PurchaseCreateWithoutSeasonInput[] | PurchaseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSeasonInput | PurchaseCreateOrConnectWithoutSeasonInput[]
    createMany?: PurchaseCreateManySeasonInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<InventoryTransactionCreateWithoutSeasonInput, InventoryTransactionUncheckedCreateWithoutSeasonInput> | InventoryTransactionCreateWithoutSeasonInput[] | InventoryTransactionUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutSeasonInput | InventoryTransactionCreateOrConnectWithoutSeasonInput[]
    createMany?: InventoryTransactionCreateManySeasonInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<ProcessCreateWithoutSeasonInput, ProcessUncheckedCreateWithoutSeasonInput> | ProcessCreateWithoutSeasonInput[] | ProcessUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutSeasonInput | ProcessCreateOrConnectWithoutSeasonInput[]
    createMany?: ProcessCreateManySeasonInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<IrrigationLogCreateWithoutSeasonInput, IrrigationLogUncheckedCreateWithoutSeasonInput> | IrrigationLogCreateWithoutSeasonInput[] | IrrigationLogUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutSeasonInput | IrrigationLogCreateOrConnectWithoutSeasonInput[]
    createMany?: IrrigationLogCreateManySeasonInputEnvelope
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
  }

  export type FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<FieldExpenseCreateWithoutSeasonInput, FieldExpenseUncheckedCreateWithoutSeasonInput> | FieldExpenseCreateWithoutSeasonInput[] | FieldExpenseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutSeasonInput | FieldExpenseCreateOrConnectWithoutSeasonInput[]
    createMany?: FieldExpenseCreateManySeasonInputEnvelope
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<NotificationCreateWithoutSeasonInput, NotificationUncheckedCreateWithoutSeasonInput> | NotificationCreateWithoutSeasonInput[] | NotificationUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSeasonInput | NotificationCreateOrConnectWithoutSeasonInput[]
    createMany?: NotificationCreateManySeasonInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<UserCreateWithoutSeasonsInput, UserUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSeasonsInput
    upsert?: UserUpsertWithoutSeasonsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSeasonsInput, UserUpdateWithoutSeasonsInput>, UserUncheckedUpdateWithoutSeasonsInput>
  }

  export type FieldUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<FieldCreateWithoutSeasonInput, FieldUncheckedCreateWithoutSeasonInput> | FieldCreateWithoutSeasonInput[] | FieldUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutSeasonInput | FieldCreateOrConnectWithoutSeasonInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutSeasonInput | FieldUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: FieldCreateManySeasonInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutSeasonInput | FieldUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutSeasonInput | FieldUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type CropUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<CropCreateWithoutSeasonInput, CropUncheckedCreateWithoutSeasonInput> | CropCreateWithoutSeasonInput[] | CropUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: CropCreateOrConnectWithoutSeasonInput | CropCreateOrConnectWithoutSeasonInput[]
    upsert?: CropUpsertWithWhereUniqueWithoutSeasonInput | CropUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: CropCreateManySeasonInputEnvelope
    set?: CropWhereUniqueInput | CropWhereUniqueInput[]
    disconnect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    delete?: CropWhereUniqueInput | CropWhereUniqueInput[]
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    update?: CropUpdateWithWhereUniqueWithoutSeasonInput | CropUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: CropUpdateManyWithWhereWithoutSeasonInput | CropUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: CropScalarWhereInput | CropScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<PurchaseCreateWithoutSeasonInput, PurchaseUncheckedCreateWithoutSeasonInput> | PurchaseCreateWithoutSeasonInput[] | PurchaseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSeasonInput | PurchaseCreateOrConnectWithoutSeasonInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSeasonInput | PurchaseUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: PurchaseCreateManySeasonInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSeasonInput | PurchaseUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSeasonInput | PurchaseUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutSeasonInput, InventoryTransactionUncheckedCreateWithoutSeasonInput> | InventoryTransactionCreateWithoutSeasonInput[] | InventoryTransactionUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutSeasonInput | InventoryTransactionCreateOrConnectWithoutSeasonInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutSeasonInput | InventoryTransactionUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: InventoryTransactionCreateManySeasonInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutSeasonInput | InventoryTransactionUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutSeasonInput | InventoryTransactionUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<ProcessCreateWithoutSeasonInput, ProcessUncheckedCreateWithoutSeasonInput> | ProcessCreateWithoutSeasonInput[] | ProcessUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutSeasonInput | ProcessCreateOrConnectWithoutSeasonInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutSeasonInput | ProcessUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: ProcessCreateManySeasonInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutSeasonInput | ProcessUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutSeasonInput | ProcessUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type IrrigationLogUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutSeasonInput, IrrigationLogUncheckedCreateWithoutSeasonInput> | IrrigationLogCreateWithoutSeasonInput[] | IrrigationLogUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutSeasonInput | IrrigationLogCreateOrConnectWithoutSeasonInput[]
    upsert?: IrrigationLogUpsertWithWhereUniqueWithoutSeasonInput | IrrigationLogUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: IrrigationLogCreateManySeasonInputEnvelope
    set?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    disconnect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    delete?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    update?: IrrigationLogUpdateWithWhereUniqueWithoutSeasonInput | IrrigationLogUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: IrrigationLogUpdateManyWithWhereWithoutSeasonInput | IrrigationLogUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
  }

  export type FieldExpenseUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<FieldExpenseCreateWithoutSeasonInput, FieldExpenseUncheckedCreateWithoutSeasonInput> | FieldExpenseCreateWithoutSeasonInput[] | FieldExpenseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutSeasonInput | FieldExpenseCreateOrConnectWithoutSeasonInput[]
    upsert?: FieldExpenseUpsertWithWhereUniqueWithoutSeasonInput | FieldExpenseUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: FieldExpenseCreateManySeasonInputEnvelope
    set?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    disconnect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    delete?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    update?: FieldExpenseUpdateWithWhereUniqueWithoutSeasonInput | FieldExpenseUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: FieldExpenseUpdateManyWithWhereWithoutSeasonInput | FieldExpenseUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: FieldExpenseScalarWhereInput | FieldExpenseScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<NotificationCreateWithoutSeasonInput, NotificationUncheckedCreateWithoutSeasonInput> | NotificationCreateWithoutSeasonInput[] | NotificationUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSeasonInput | NotificationCreateOrConnectWithoutSeasonInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSeasonInput | NotificationUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: NotificationCreateManySeasonInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSeasonInput | NotificationUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSeasonInput | NotificationUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FieldUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<FieldCreateWithoutSeasonInput, FieldUncheckedCreateWithoutSeasonInput> | FieldCreateWithoutSeasonInput[] | FieldUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldCreateOrConnectWithoutSeasonInput | FieldCreateOrConnectWithoutSeasonInput[]
    upsert?: FieldUpsertWithWhereUniqueWithoutSeasonInput | FieldUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: FieldCreateManySeasonInputEnvelope
    set?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    disconnect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    delete?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    connect?: FieldWhereUniqueInput | FieldWhereUniqueInput[]
    update?: FieldUpdateWithWhereUniqueWithoutSeasonInput | FieldUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: FieldUpdateManyWithWhereWithoutSeasonInput | FieldUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: FieldScalarWhereInput | FieldScalarWhereInput[]
  }

  export type CropUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<CropCreateWithoutSeasonInput, CropUncheckedCreateWithoutSeasonInput> | CropCreateWithoutSeasonInput[] | CropUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: CropCreateOrConnectWithoutSeasonInput | CropCreateOrConnectWithoutSeasonInput[]
    upsert?: CropUpsertWithWhereUniqueWithoutSeasonInput | CropUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: CropCreateManySeasonInputEnvelope
    set?: CropWhereUniqueInput | CropWhereUniqueInput[]
    disconnect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    delete?: CropWhereUniqueInput | CropWhereUniqueInput[]
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    update?: CropUpdateWithWhereUniqueWithoutSeasonInput | CropUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: CropUpdateManyWithWhereWithoutSeasonInput | CropUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: CropScalarWhereInput | CropScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<PurchaseCreateWithoutSeasonInput, PurchaseUncheckedCreateWithoutSeasonInput> | PurchaseCreateWithoutSeasonInput[] | PurchaseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSeasonInput | PurchaseCreateOrConnectWithoutSeasonInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSeasonInput | PurchaseUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: PurchaseCreateManySeasonInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSeasonInput | PurchaseUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSeasonInput | PurchaseUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutSeasonInput, InventoryTransactionUncheckedCreateWithoutSeasonInput> | InventoryTransactionCreateWithoutSeasonInput[] | InventoryTransactionUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutSeasonInput | InventoryTransactionCreateOrConnectWithoutSeasonInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutSeasonInput | InventoryTransactionUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: InventoryTransactionCreateManySeasonInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutSeasonInput | InventoryTransactionUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutSeasonInput | InventoryTransactionUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<ProcessCreateWithoutSeasonInput, ProcessUncheckedCreateWithoutSeasonInput> | ProcessCreateWithoutSeasonInput[] | ProcessUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutSeasonInput | ProcessCreateOrConnectWithoutSeasonInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutSeasonInput | ProcessUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: ProcessCreateManySeasonInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutSeasonInput | ProcessUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutSeasonInput | ProcessUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutSeasonInput, IrrigationLogUncheckedCreateWithoutSeasonInput> | IrrigationLogCreateWithoutSeasonInput[] | IrrigationLogUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutSeasonInput | IrrigationLogCreateOrConnectWithoutSeasonInput[]
    upsert?: IrrigationLogUpsertWithWhereUniqueWithoutSeasonInput | IrrigationLogUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: IrrigationLogCreateManySeasonInputEnvelope
    set?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    disconnect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    delete?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    update?: IrrigationLogUpdateWithWhereUniqueWithoutSeasonInput | IrrigationLogUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: IrrigationLogUpdateManyWithWhereWithoutSeasonInput | IrrigationLogUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
  }

  export type FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<FieldExpenseCreateWithoutSeasonInput, FieldExpenseUncheckedCreateWithoutSeasonInput> | FieldExpenseCreateWithoutSeasonInput[] | FieldExpenseUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutSeasonInput | FieldExpenseCreateOrConnectWithoutSeasonInput[]
    upsert?: FieldExpenseUpsertWithWhereUniqueWithoutSeasonInput | FieldExpenseUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: FieldExpenseCreateManySeasonInputEnvelope
    set?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    disconnect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    delete?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    update?: FieldExpenseUpdateWithWhereUniqueWithoutSeasonInput | FieldExpenseUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: FieldExpenseUpdateManyWithWhereWithoutSeasonInput | FieldExpenseUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: FieldExpenseScalarWhereInput | FieldExpenseScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<NotificationCreateWithoutSeasonInput, NotificationUncheckedCreateWithoutSeasonInput> | NotificationCreateWithoutSeasonInput[] | NotificationUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSeasonInput | NotificationCreateOrConnectWithoutSeasonInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSeasonInput | NotificationUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: NotificationCreateManySeasonInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSeasonInput | NotificationUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSeasonInput | NotificationUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SeasonCreateNestedOneWithoutFieldsInput = {
    create?: XOR<SeasonCreateWithoutFieldsInput, SeasonUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutFieldsInput
    connect?: SeasonWhereUniqueInput
  }

  export type FieldOwnershipCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldOwnershipCreateWithoutFieldInput, FieldOwnershipUncheckedCreateWithoutFieldInput> | FieldOwnershipCreateWithoutFieldInput[] | FieldOwnershipUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutFieldInput | FieldOwnershipCreateOrConnectWithoutFieldInput[]
    createMany?: FieldOwnershipCreateManyFieldInputEnvelope
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
  }

  export type FieldWorkerAssignmentCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutFieldInput, FieldWorkerAssignmentUncheckedCreateWithoutFieldInput> | FieldWorkerAssignmentCreateWithoutFieldInput[] | FieldWorkerAssignmentUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutFieldInput | FieldWorkerAssignmentCreateOrConnectWithoutFieldInput[]
    createMany?: FieldWorkerAssignmentCreateManyFieldInputEnvelope
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
  }

  export type CropCreateNestedManyWithoutFieldInput = {
    create?: XOR<CropCreateWithoutFieldInput, CropUncheckedCreateWithoutFieldInput> | CropCreateWithoutFieldInput[] | CropUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CropCreateOrConnectWithoutFieldInput | CropCreateOrConnectWithoutFieldInput[]
    createMany?: CropCreateManyFieldInputEnvelope
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
  }

  export type FieldWellCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldWellCreateWithoutFieldInput, FieldWellUncheckedCreateWithoutFieldInput> | FieldWellCreateWithoutFieldInput[] | FieldWellUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutFieldInput | FieldWellCreateOrConnectWithoutFieldInput[]
    createMany?: FieldWellCreateManyFieldInputEnvelope
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
  }

  export type ProcessingLogCreateNestedManyWithoutFieldInput = {
    create?: XOR<ProcessingLogCreateWithoutFieldInput, ProcessingLogUncheckedCreateWithoutFieldInput> | ProcessingLogCreateWithoutFieldInput[] | ProcessingLogUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessingLogCreateOrConnectWithoutFieldInput | ProcessingLogCreateOrConnectWithoutFieldInput[]
    createMany?: ProcessingLogCreateManyFieldInputEnvelope
    connect?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
  }

  export type ProcessCostCreateNestedManyWithoutFieldInput = {
    create?: XOR<ProcessCostCreateWithoutFieldInput, ProcessCostUncheckedCreateWithoutFieldInput> | ProcessCostCreateWithoutFieldInput[] | ProcessCostUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutFieldInput | ProcessCostCreateOrConnectWithoutFieldInput[]
    createMany?: ProcessCostCreateManyFieldInputEnvelope
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
  }

  export type InventoryUsageCreateNestedManyWithoutFieldInput = {
    create?: XOR<InventoryUsageCreateWithoutFieldInput, InventoryUsageUncheckedCreateWithoutFieldInput> | InventoryUsageCreateWithoutFieldInput[] | InventoryUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutFieldInput | InventoryUsageCreateOrConnectWithoutFieldInput[]
    createMany?: InventoryUsageCreateManyFieldInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type ProcessCreateNestedManyWithoutFieldInput = {
    create?: XOR<ProcessCreateWithoutFieldInput, ProcessUncheckedCreateWithoutFieldInput> | ProcessCreateWithoutFieldInput[] | ProcessUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutFieldInput | ProcessCreateOrConnectWithoutFieldInput[]
    createMany?: ProcessCreateManyFieldInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type FieldExpenseCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldExpenseCreateWithoutFieldInput, FieldExpenseUncheckedCreateWithoutFieldInput> | FieldExpenseCreateWithoutFieldInput[] | FieldExpenseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutFieldInput | FieldExpenseCreateOrConnectWithoutFieldInput[]
    createMany?: FieldExpenseCreateManyFieldInputEnvelope
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutFieldInput = {
    create?: XOR<NotificationCreateWithoutFieldInput, NotificationUncheckedCreateWithoutFieldInput> | NotificationCreateWithoutFieldInput[] | NotificationUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldInput | NotificationCreateOrConnectWithoutFieldInput[]
    createMany?: NotificationCreateManyFieldInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationFieldUsageCreateNestedManyWithoutFieldInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutFieldInput, IrrigationFieldUsageUncheckedCreateWithoutFieldInput> | IrrigationFieldUsageCreateWithoutFieldInput[] | IrrigationFieldUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutFieldInput | IrrigationFieldUsageCreateOrConnectWithoutFieldInput[]
    createMany?: IrrigationFieldUsageCreateManyFieldInputEnvelope
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
  }

  export type WellBillDistributionCreateNestedManyWithoutFieldInput = {
    create?: XOR<WellBillDistributionCreateWithoutFieldInput, WellBillDistributionUncheckedCreateWithoutFieldInput> | WellBillDistributionCreateWithoutFieldInput[] | WellBillDistributionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutFieldInput | WellBillDistributionCreateOrConnectWithoutFieldInput[]
    createMany?: WellBillDistributionCreateManyFieldInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldOwnershipCreateWithoutFieldInput, FieldOwnershipUncheckedCreateWithoutFieldInput> | FieldOwnershipCreateWithoutFieldInput[] | FieldOwnershipUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutFieldInput | FieldOwnershipCreateOrConnectWithoutFieldInput[]
    createMany?: FieldOwnershipCreateManyFieldInputEnvelope
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
  }

  export type FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutFieldInput, FieldWorkerAssignmentUncheckedCreateWithoutFieldInput> | FieldWorkerAssignmentCreateWithoutFieldInput[] | FieldWorkerAssignmentUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutFieldInput | FieldWorkerAssignmentCreateOrConnectWithoutFieldInput[]
    createMany?: FieldWorkerAssignmentCreateManyFieldInputEnvelope
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
  }

  export type CropUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<CropCreateWithoutFieldInput, CropUncheckedCreateWithoutFieldInput> | CropCreateWithoutFieldInput[] | CropUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CropCreateOrConnectWithoutFieldInput | CropCreateOrConnectWithoutFieldInput[]
    createMany?: CropCreateManyFieldInputEnvelope
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
  }

  export type FieldWellUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldWellCreateWithoutFieldInput, FieldWellUncheckedCreateWithoutFieldInput> | FieldWellCreateWithoutFieldInput[] | FieldWellUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutFieldInput | FieldWellCreateOrConnectWithoutFieldInput[]
    createMany?: FieldWellCreateManyFieldInputEnvelope
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
  }

  export type ProcessingLogUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<ProcessingLogCreateWithoutFieldInput, ProcessingLogUncheckedCreateWithoutFieldInput> | ProcessingLogCreateWithoutFieldInput[] | ProcessingLogUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessingLogCreateOrConnectWithoutFieldInput | ProcessingLogCreateOrConnectWithoutFieldInput[]
    createMany?: ProcessingLogCreateManyFieldInputEnvelope
    connect?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
  }

  export type ProcessCostUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<ProcessCostCreateWithoutFieldInput, ProcessCostUncheckedCreateWithoutFieldInput> | ProcessCostCreateWithoutFieldInput[] | ProcessCostUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutFieldInput | ProcessCostCreateOrConnectWithoutFieldInput[]
    createMany?: ProcessCostCreateManyFieldInputEnvelope
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
  }

  export type InventoryUsageUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<InventoryUsageCreateWithoutFieldInput, InventoryUsageUncheckedCreateWithoutFieldInput> | InventoryUsageCreateWithoutFieldInput[] | InventoryUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutFieldInput | InventoryUsageCreateOrConnectWithoutFieldInput[]
    createMany?: InventoryUsageCreateManyFieldInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<ProcessCreateWithoutFieldInput, ProcessUncheckedCreateWithoutFieldInput> | ProcessCreateWithoutFieldInput[] | ProcessUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutFieldInput | ProcessCreateOrConnectWithoutFieldInput[]
    createMany?: ProcessCreateManyFieldInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type FieldExpenseUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldExpenseCreateWithoutFieldInput, FieldExpenseUncheckedCreateWithoutFieldInput> | FieldExpenseCreateWithoutFieldInput[] | FieldExpenseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutFieldInput | FieldExpenseCreateOrConnectWithoutFieldInput[]
    createMany?: FieldExpenseCreateManyFieldInputEnvelope
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<NotificationCreateWithoutFieldInput, NotificationUncheckedCreateWithoutFieldInput> | NotificationCreateWithoutFieldInput[] | NotificationUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldInput | NotificationCreateOrConnectWithoutFieldInput[]
    createMany?: NotificationCreateManyFieldInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutFieldInput, IrrigationFieldUsageUncheckedCreateWithoutFieldInput> | IrrigationFieldUsageCreateWithoutFieldInput[] | IrrigationFieldUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutFieldInput | IrrigationFieldUsageCreateOrConnectWithoutFieldInput[]
    createMany?: IrrigationFieldUsageCreateManyFieldInputEnvelope
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
  }

  export type WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<WellBillDistributionCreateWithoutFieldInput, WellBillDistributionUncheckedCreateWithoutFieldInput> | WellBillDistributionCreateWithoutFieldInput[] | WellBillDistributionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutFieldInput | WellBillDistributionCreateOrConnectWithoutFieldInput[]
    createMany?: WellBillDistributionCreateManyFieldInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SeasonUpdateOneWithoutFieldsNestedInput = {
    create?: XOR<SeasonCreateWithoutFieldsInput, SeasonUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutFieldsInput
    upsert?: SeasonUpsertWithoutFieldsInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutFieldsInput, SeasonUpdateWithoutFieldsInput>, SeasonUncheckedUpdateWithoutFieldsInput>
  }

  export type FieldOwnershipUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldOwnershipCreateWithoutFieldInput, FieldOwnershipUncheckedCreateWithoutFieldInput> | FieldOwnershipCreateWithoutFieldInput[] | FieldOwnershipUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutFieldInput | FieldOwnershipCreateOrConnectWithoutFieldInput[]
    upsert?: FieldOwnershipUpsertWithWhereUniqueWithoutFieldInput | FieldOwnershipUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldOwnershipCreateManyFieldInputEnvelope
    set?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    disconnect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    delete?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    update?: FieldOwnershipUpdateWithWhereUniqueWithoutFieldInput | FieldOwnershipUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldOwnershipUpdateManyWithWhereWithoutFieldInput | FieldOwnershipUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldOwnershipScalarWhereInput | FieldOwnershipScalarWhereInput[]
  }

  export type FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutFieldInput, FieldWorkerAssignmentUncheckedCreateWithoutFieldInput> | FieldWorkerAssignmentCreateWithoutFieldInput[] | FieldWorkerAssignmentUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutFieldInput | FieldWorkerAssignmentCreateOrConnectWithoutFieldInput[]
    upsert?: FieldWorkerAssignmentUpsertWithWhereUniqueWithoutFieldInput | FieldWorkerAssignmentUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldWorkerAssignmentCreateManyFieldInputEnvelope
    set?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    disconnect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    delete?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    update?: FieldWorkerAssignmentUpdateWithWhereUniqueWithoutFieldInput | FieldWorkerAssignmentUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldWorkerAssignmentUpdateManyWithWhereWithoutFieldInput | FieldWorkerAssignmentUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldWorkerAssignmentScalarWhereInput | FieldWorkerAssignmentScalarWhereInput[]
  }

  export type CropUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CropCreateWithoutFieldInput, CropUncheckedCreateWithoutFieldInput> | CropCreateWithoutFieldInput[] | CropUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CropCreateOrConnectWithoutFieldInput | CropCreateOrConnectWithoutFieldInput[]
    upsert?: CropUpsertWithWhereUniqueWithoutFieldInput | CropUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CropCreateManyFieldInputEnvelope
    set?: CropWhereUniqueInput | CropWhereUniqueInput[]
    disconnect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    delete?: CropWhereUniqueInput | CropWhereUniqueInput[]
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    update?: CropUpdateWithWhereUniqueWithoutFieldInput | CropUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CropUpdateManyWithWhereWithoutFieldInput | CropUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CropScalarWhereInput | CropScalarWhereInput[]
  }

  export type FieldWellUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldWellCreateWithoutFieldInput, FieldWellUncheckedCreateWithoutFieldInput> | FieldWellCreateWithoutFieldInput[] | FieldWellUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutFieldInput | FieldWellCreateOrConnectWithoutFieldInput[]
    upsert?: FieldWellUpsertWithWhereUniqueWithoutFieldInput | FieldWellUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldWellCreateManyFieldInputEnvelope
    set?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    disconnect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    delete?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    update?: FieldWellUpdateWithWhereUniqueWithoutFieldInput | FieldWellUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldWellUpdateManyWithWhereWithoutFieldInput | FieldWellUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldWellScalarWhereInput | FieldWellScalarWhereInput[]
  }

  export type ProcessingLogUpdateManyWithoutFieldNestedInput = {
    create?: XOR<ProcessingLogCreateWithoutFieldInput, ProcessingLogUncheckedCreateWithoutFieldInput> | ProcessingLogCreateWithoutFieldInput[] | ProcessingLogUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessingLogCreateOrConnectWithoutFieldInput | ProcessingLogCreateOrConnectWithoutFieldInput[]
    upsert?: ProcessingLogUpsertWithWhereUniqueWithoutFieldInput | ProcessingLogUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: ProcessingLogCreateManyFieldInputEnvelope
    set?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    disconnect?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    delete?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    connect?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    update?: ProcessingLogUpdateWithWhereUniqueWithoutFieldInput | ProcessingLogUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: ProcessingLogUpdateManyWithWhereWithoutFieldInput | ProcessingLogUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: ProcessingLogScalarWhereInput | ProcessingLogScalarWhereInput[]
  }

  export type ProcessCostUpdateManyWithoutFieldNestedInput = {
    create?: XOR<ProcessCostCreateWithoutFieldInput, ProcessCostUncheckedCreateWithoutFieldInput> | ProcessCostCreateWithoutFieldInput[] | ProcessCostUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutFieldInput | ProcessCostCreateOrConnectWithoutFieldInput[]
    upsert?: ProcessCostUpsertWithWhereUniqueWithoutFieldInput | ProcessCostUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: ProcessCostCreateManyFieldInputEnvelope
    set?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    disconnect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    delete?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    update?: ProcessCostUpdateWithWhereUniqueWithoutFieldInput | ProcessCostUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: ProcessCostUpdateManyWithWhereWithoutFieldInput | ProcessCostUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: ProcessCostScalarWhereInput | ProcessCostScalarWhereInput[]
  }

  export type InventoryUsageUpdateManyWithoutFieldNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutFieldInput, InventoryUsageUncheckedCreateWithoutFieldInput> | InventoryUsageCreateWithoutFieldInput[] | InventoryUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutFieldInput | InventoryUsageCreateOrConnectWithoutFieldInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutFieldInput | InventoryUsageUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: InventoryUsageCreateManyFieldInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutFieldInput | InventoryUsageUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutFieldInput | InventoryUsageUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type ProcessUpdateManyWithoutFieldNestedInput = {
    create?: XOR<ProcessCreateWithoutFieldInput, ProcessUncheckedCreateWithoutFieldInput> | ProcessCreateWithoutFieldInput[] | ProcessUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutFieldInput | ProcessCreateOrConnectWithoutFieldInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutFieldInput | ProcessUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: ProcessCreateManyFieldInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutFieldInput | ProcessUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutFieldInput | ProcessUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type FieldExpenseUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldExpenseCreateWithoutFieldInput, FieldExpenseUncheckedCreateWithoutFieldInput> | FieldExpenseCreateWithoutFieldInput[] | FieldExpenseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutFieldInput | FieldExpenseCreateOrConnectWithoutFieldInput[]
    upsert?: FieldExpenseUpsertWithWhereUniqueWithoutFieldInput | FieldExpenseUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldExpenseCreateManyFieldInputEnvelope
    set?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    disconnect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    delete?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    update?: FieldExpenseUpdateWithWhereUniqueWithoutFieldInput | FieldExpenseUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldExpenseUpdateManyWithWhereWithoutFieldInput | FieldExpenseUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldExpenseScalarWhereInput | FieldExpenseScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutFieldNestedInput = {
    create?: XOR<NotificationCreateWithoutFieldInput, NotificationUncheckedCreateWithoutFieldInput> | NotificationCreateWithoutFieldInput[] | NotificationUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldInput | NotificationCreateOrConnectWithoutFieldInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutFieldInput | NotificationUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: NotificationCreateManyFieldInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutFieldInput | NotificationUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutFieldInput | NotificationUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationFieldUsageUpdateManyWithoutFieldNestedInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutFieldInput, IrrigationFieldUsageUncheckedCreateWithoutFieldInput> | IrrigationFieldUsageCreateWithoutFieldInput[] | IrrigationFieldUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutFieldInput | IrrigationFieldUsageCreateOrConnectWithoutFieldInput[]
    upsert?: IrrigationFieldUsageUpsertWithWhereUniqueWithoutFieldInput | IrrigationFieldUsageUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: IrrigationFieldUsageCreateManyFieldInputEnvelope
    set?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    disconnect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    delete?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    update?: IrrigationFieldUsageUpdateWithWhereUniqueWithoutFieldInput | IrrigationFieldUsageUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: IrrigationFieldUsageUpdateManyWithWhereWithoutFieldInput | IrrigationFieldUsageUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: IrrigationFieldUsageScalarWhereInput | IrrigationFieldUsageScalarWhereInput[]
  }

  export type WellBillDistributionUpdateManyWithoutFieldNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutFieldInput, WellBillDistributionUncheckedCreateWithoutFieldInput> | WellBillDistributionCreateWithoutFieldInput[] | WellBillDistributionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutFieldInput | WellBillDistributionCreateOrConnectWithoutFieldInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutFieldInput | WellBillDistributionUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: WellBillDistributionCreateManyFieldInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutFieldInput | WellBillDistributionUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutFieldInput | WellBillDistributionUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldOwnershipCreateWithoutFieldInput, FieldOwnershipUncheckedCreateWithoutFieldInput> | FieldOwnershipCreateWithoutFieldInput[] | FieldOwnershipUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutFieldInput | FieldOwnershipCreateOrConnectWithoutFieldInput[]
    upsert?: FieldOwnershipUpsertWithWhereUniqueWithoutFieldInput | FieldOwnershipUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldOwnershipCreateManyFieldInputEnvelope
    set?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    disconnect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    delete?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    connect?: FieldOwnershipWhereUniqueInput | FieldOwnershipWhereUniqueInput[]
    update?: FieldOwnershipUpdateWithWhereUniqueWithoutFieldInput | FieldOwnershipUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldOwnershipUpdateManyWithWhereWithoutFieldInput | FieldOwnershipUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldOwnershipScalarWhereInput | FieldOwnershipScalarWhereInput[]
  }

  export type FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldWorkerAssignmentCreateWithoutFieldInput, FieldWorkerAssignmentUncheckedCreateWithoutFieldInput> | FieldWorkerAssignmentCreateWithoutFieldInput[] | FieldWorkerAssignmentUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWorkerAssignmentCreateOrConnectWithoutFieldInput | FieldWorkerAssignmentCreateOrConnectWithoutFieldInput[]
    upsert?: FieldWorkerAssignmentUpsertWithWhereUniqueWithoutFieldInput | FieldWorkerAssignmentUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldWorkerAssignmentCreateManyFieldInputEnvelope
    set?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    disconnect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    delete?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    connect?: FieldWorkerAssignmentWhereUniqueInput | FieldWorkerAssignmentWhereUniqueInput[]
    update?: FieldWorkerAssignmentUpdateWithWhereUniqueWithoutFieldInput | FieldWorkerAssignmentUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldWorkerAssignmentUpdateManyWithWhereWithoutFieldInput | FieldWorkerAssignmentUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldWorkerAssignmentScalarWhereInput | FieldWorkerAssignmentScalarWhereInput[]
  }

  export type CropUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CropCreateWithoutFieldInput, CropUncheckedCreateWithoutFieldInput> | CropCreateWithoutFieldInput[] | CropUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CropCreateOrConnectWithoutFieldInput | CropCreateOrConnectWithoutFieldInput[]
    upsert?: CropUpsertWithWhereUniqueWithoutFieldInput | CropUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CropCreateManyFieldInputEnvelope
    set?: CropWhereUniqueInput | CropWhereUniqueInput[]
    disconnect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    delete?: CropWhereUniqueInput | CropWhereUniqueInput[]
    connect?: CropWhereUniqueInput | CropWhereUniqueInput[]
    update?: CropUpdateWithWhereUniqueWithoutFieldInput | CropUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CropUpdateManyWithWhereWithoutFieldInput | CropUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CropScalarWhereInput | CropScalarWhereInput[]
  }

  export type FieldWellUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldWellCreateWithoutFieldInput, FieldWellUncheckedCreateWithoutFieldInput> | FieldWellCreateWithoutFieldInput[] | FieldWellUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutFieldInput | FieldWellCreateOrConnectWithoutFieldInput[]
    upsert?: FieldWellUpsertWithWhereUniqueWithoutFieldInput | FieldWellUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldWellCreateManyFieldInputEnvelope
    set?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    disconnect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    delete?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    update?: FieldWellUpdateWithWhereUniqueWithoutFieldInput | FieldWellUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldWellUpdateManyWithWhereWithoutFieldInput | FieldWellUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldWellScalarWhereInput | FieldWellScalarWhereInput[]
  }

  export type ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<ProcessingLogCreateWithoutFieldInput, ProcessingLogUncheckedCreateWithoutFieldInput> | ProcessingLogCreateWithoutFieldInput[] | ProcessingLogUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessingLogCreateOrConnectWithoutFieldInput | ProcessingLogCreateOrConnectWithoutFieldInput[]
    upsert?: ProcessingLogUpsertWithWhereUniqueWithoutFieldInput | ProcessingLogUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: ProcessingLogCreateManyFieldInputEnvelope
    set?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    disconnect?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    delete?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    connect?: ProcessingLogWhereUniqueInput | ProcessingLogWhereUniqueInput[]
    update?: ProcessingLogUpdateWithWhereUniqueWithoutFieldInput | ProcessingLogUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: ProcessingLogUpdateManyWithWhereWithoutFieldInput | ProcessingLogUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: ProcessingLogScalarWhereInput | ProcessingLogScalarWhereInput[]
  }

  export type ProcessCostUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<ProcessCostCreateWithoutFieldInput, ProcessCostUncheckedCreateWithoutFieldInput> | ProcessCostCreateWithoutFieldInput[] | ProcessCostUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutFieldInput | ProcessCostCreateOrConnectWithoutFieldInput[]
    upsert?: ProcessCostUpsertWithWhereUniqueWithoutFieldInput | ProcessCostUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: ProcessCostCreateManyFieldInputEnvelope
    set?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    disconnect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    delete?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    update?: ProcessCostUpdateWithWhereUniqueWithoutFieldInput | ProcessCostUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: ProcessCostUpdateManyWithWhereWithoutFieldInput | ProcessCostUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: ProcessCostScalarWhereInput | ProcessCostScalarWhereInput[]
  }

  export type InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutFieldInput, InventoryUsageUncheckedCreateWithoutFieldInput> | InventoryUsageCreateWithoutFieldInput[] | InventoryUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutFieldInput | InventoryUsageCreateOrConnectWithoutFieldInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutFieldInput | InventoryUsageUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: InventoryUsageCreateManyFieldInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutFieldInput | InventoryUsageUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutFieldInput | InventoryUsageUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<ProcessCreateWithoutFieldInput, ProcessUncheckedCreateWithoutFieldInput> | ProcessCreateWithoutFieldInput[] | ProcessUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutFieldInput | ProcessCreateOrConnectWithoutFieldInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutFieldInput | ProcessUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: ProcessCreateManyFieldInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutFieldInput | ProcessUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutFieldInput | ProcessUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldExpenseCreateWithoutFieldInput, FieldExpenseUncheckedCreateWithoutFieldInput> | FieldExpenseCreateWithoutFieldInput[] | FieldExpenseUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutFieldInput | FieldExpenseCreateOrConnectWithoutFieldInput[]
    upsert?: FieldExpenseUpsertWithWhereUniqueWithoutFieldInput | FieldExpenseUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldExpenseCreateManyFieldInputEnvelope
    set?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    disconnect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    delete?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    connect?: FieldExpenseWhereUniqueInput | FieldExpenseWhereUniqueInput[]
    update?: FieldExpenseUpdateWithWhereUniqueWithoutFieldInput | FieldExpenseUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldExpenseUpdateManyWithWhereWithoutFieldInput | FieldExpenseUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldExpenseScalarWhereInput | FieldExpenseScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<NotificationCreateWithoutFieldInput, NotificationUncheckedCreateWithoutFieldInput> | NotificationCreateWithoutFieldInput[] | NotificationUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldInput | NotificationCreateOrConnectWithoutFieldInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutFieldInput | NotificationUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: NotificationCreateManyFieldInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutFieldInput | NotificationUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutFieldInput | NotificationUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutFieldInput, IrrigationFieldUsageUncheckedCreateWithoutFieldInput> | IrrigationFieldUsageCreateWithoutFieldInput[] | IrrigationFieldUsageUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutFieldInput | IrrigationFieldUsageCreateOrConnectWithoutFieldInput[]
    upsert?: IrrigationFieldUsageUpsertWithWhereUniqueWithoutFieldInput | IrrigationFieldUsageUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: IrrigationFieldUsageCreateManyFieldInputEnvelope
    set?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    disconnect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    delete?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    update?: IrrigationFieldUsageUpdateWithWhereUniqueWithoutFieldInput | IrrigationFieldUsageUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: IrrigationFieldUsageUpdateManyWithWhereWithoutFieldInput | IrrigationFieldUsageUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: IrrigationFieldUsageScalarWhereInput | IrrigationFieldUsageScalarWhereInput[]
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutFieldInput, WellBillDistributionUncheckedCreateWithoutFieldInput> | WellBillDistributionCreateWithoutFieldInput[] | WellBillDistributionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutFieldInput | WellBillDistributionCreateOrConnectWithoutFieldInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutFieldInput | WellBillDistributionUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: WellBillDistributionCreateManyFieldInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutFieldInput | WellBillDistributionUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutFieldInput | WellBillDistributionUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type FieldCreateNestedOneWithoutOwnersInput = {
    create?: XOR<FieldCreateWithoutOwnersInput, FieldUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: FieldCreateOrConnectWithoutOwnersInput
    connect?: FieldWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedFieldsInput = {
    create?: XOR<UserCreateWithoutOwnedFieldsInput, UserUncheckedCreateWithoutOwnedFieldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedFieldsInput
    connect?: UserWhereUniqueInput
  }

  export type FieldOwnerExpenseCreateNestedManyWithoutFieldOwnershipInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput> | FieldOwnerExpenseCreateWithoutFieldOwnershipInput[] | FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput | FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput[]
    createMany?: FieldOwnerExpenseCreateManyFieldOwnershipInputEnvelope
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
  }

  export type FieldOwnerExpenseUncheckedCreateNestedManyWithoutFieldOwnershipInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput> | FieldOwnerExpenseCreateWithoutFieldOwnershipInput[] | FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput | FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput[]
    createMany?: FieldOwnerExpenseCreateManyFieldOwnershipInputEnvelope
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
  }

  export type FieldUpdateOneRequiredWithoutOwnersNestedInput = {
    create?: XOR<FieldCreateWithoutOwnersInput, FieldUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: FieldCreateOrConnectWithoutOwnersInput
    upsert?: FieldUpsertWithoutOwnersInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutOwnersInput, FieldUpdateWithoutOwnersInput>, FieldUncheckedUpdateWithoutOwnersInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedFieldsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedFieldsInput, UserUncheckedCreateWithoutOwnedFieldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedFieldsInput
    upsert?: UserUpsertWithoutOwnedFieldsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedFieldsInput, UserUpdateWithoutOwnedFieldsInput>, UserUncheckedUpdateWithoutOwnedFieldsInput>
  }

  export type FieldOwnerExpenseUpdateManyWithoutFieldOwnershipNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput> | FieldOwnerExpenseCreateWithoutFieldOwnershipInput[] | FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput | FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput[]
    upsert?: FieldOwnerExpenseUpsertWithWhereUniqueWithoutFieldOwnershipInput | FieldOwnerExpenseUpsertWithWhereUniqueWithoutFieldOwnershipInput[]
    createMany?: FieldOwnerExpenseCreateManyFieldOwnershipInputEnvelope
    set?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    disconnect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    delete?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    update?: FieldOwnerExpenseUpdateWithWhereUniqueWithoutFieldOwnershipInput | FieldOwnerExpenseUpdateWithWhereUniqueWithoutFieldOwnershipInput[]
    updateMany?: FieldOwnerExpenseUpdateManyWithWhereWithoutFieldOwnershipInput | FieldOwnerExpenseUpdateManyWithWhereWithoutFieldOwnershipInput[]
    deleteMany?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
  }

  export type FieldOwnerExpenseUncheckedUpdateManyWithoutFieldOwnershipNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput> | FieldOwnerExpenseCreateWithoutFieldOwnershipInput[] | FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput | FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput[]
    upsert?: FieldOwnerExpenseUpsertWithWhereUniqueWithoutFieldOwnershipInput | FieldOwnerExpenseUpsertWithWhereUniqueWithoutFieldOwnershipInput[]
    createMany?: FieldOwnerExpenseCreateManyFieldOwnershipInputEnvelope
    set?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    disconnect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    delete?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    update?: FieldOwnerExpenseUpdateWithWhereUniqueWithoutFieldOwnershipInput | FieldOwnerExpenseUpdateWithWhereUniqueWithoutFieldOwnershipInput[]
    updateMany?: FieldOwnerExpenseUpdateManyWithWhereWithoutFieldOwnershipInput | FieldOwnerExpenseUpdateManyWithWhereWithoutFieldOwnershipInput[]
    deleteMany?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
  }

  export type FieldCreateNestedOneWithoutWorkerAssignmentsInput = {
    create?: XOR<FieldCreateWithoutWorkerAssignmentsInput, FieldUncheckedCreateWithoutWorkerAssignmentsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutWorkerAssignmentsInput
    connect?: FieldWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedFieldsInput = {
    create?: XOR<UserCreateWithoutAssignedFieldsInput, UserUncheckedCreateWithoutAssignedFieldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFieldsInput
    connect?: UserWhereUniqueInput
  }

  export type FieldUpdateOneRequiredWithoutWorkerAssignmentsNestedInput = {
    create?: XOR<FieldCreateWithoutWorkerAssignmentsInput, FieldUncheckedCreateWithoutWorkerAssignmentsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutWorkerAssignmentsInput
    upsert?: FieldUpsertWithoutWorkerAssignmentsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutWorkerAssignmentsInput, FieldUpdateWithoutWorkerAssignmentsInput>, FieldUncheckedUpdateWithoutWorkerAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedFieldsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedFieldsInput, UserUncheckedCreateWithoutAssignedFieldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFieldsInput
    upsert?: UserUpsertWithoutAssignedFieldsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedFieldsInput, UserUpdateWithoutAssignedFieldsInput>, UserUncheckedUpdateWithoutAssignedFieldsInput>
  }

  export type FieldCreateNestedOneWithoutFieldWellsInput = {
    create?: XOR<FieldCreateWithoutFieldWellsInput, FieldUncheckedCreateWithoutFieldWellsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldWellsInput
    connect?: FieldWhereUniqueInput
  }

  export type WellCreateNestedOneWithoutFieldWellsInput = {
    create?: XOR<WellCreateWithoutFieldWellsInput, WellUncheckedCreateWithoutFieldWellsInput>
    connectOrCreate?: WellCreateOrConnectWithoutFieldWellsInput
    connect?: WellWhereUniqueInput
  }

  export type FieldUpdateOneRequiredWithoutFieldWellsNestedInput = {
    create?: XOR<FieldCreateWithoutFieldWellsInput, FieldUncheckedCreateWithoutFieldWellsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldWellsInput
    upsert?: FieldUpsertWithoutFieldWellsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFieldWellsInput, FieldUpdateWithoutFieldWellsInput>, FieldUncheckedUpdateWithoutFieldWellsInput>
  }

  export type WellUpdateOneRequiredWithoutFieldWellsNestedInput = {
    create?: XOR<WellCreateWithoutFieldWellsInput, WellUncheckedCreateWithoutFieldWellsInput>
    connectOrCreate?: WellCreateOrConnectWithoutFieldWellsInput
    upsert?: WellUpsertWithoutFieldWellsInput
    connect?: WellWhereUniqueInput
    update?: XOR<XOR<WellUpdateToOneWithWhereWithoutFieldWellsInput, WellUpdateWithoutFieldWellsInput>, WellUncheckedUpdateWithoutFieldWellsInput>
  }

  export type UserCreateNestedOneWithoutWellAssignmentsInput = {
    create?: XOR<UserCreateWithoutWellAssignmentsInput, UserUncheckedCreateWithoutWellAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type WellCreateNestedOneWithoutWorkerAssignmentsInput = {
    create?: XOR<WellCreateWithoutWorkerAssignmentsInput, WellUncheckedCreateWithoutWorkerAssignmentsInput>
    connectOrCreate?: WellCreateOrConnectWithoutWorkerAssignmentsInput
    connect?: WellWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWellAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutWellAssignmentsInput, UserUncheckedCreateWithoutWellAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellAssignmentsInput
    upsert?: UserUpsertWithoutWellAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWellAssignmentsInput, UserUpdateWithoutWellAssignmentsInput>, UserUncheckedUpdateWithoutWellAssignmentsInput>
  }

  export type WellUpdateOneRequiredWithoutWorkerAssignmentsNestedInput = {
    create?: XOR<WellCreateWithoutWorkerAssignmentsInput, WellUncheckedCreateWithoutWorkerAssignmentsInput>
    connectOrCreate?: WellCreateOrConnectWithoutWorkerAssignmentsInput
    upsert?: WellUpsertWithoutWorkerAssignmentsInput
    connect?: WellWhereUniqueInput
    update?: XOR<XOR<WellUpdateToOneWithWhereWithoutWorkerAssignmentsInput, WellUpdateWithoutWorkerAssignmentsInput>, WellUncheckedUpdateWithoutWorkerAssignmentsInput>
  }

  export type FieldWellCreateNestedManyWithoutWellInput = {
    create?: XOR<FieldWellCreateWithoutWellInput, FieldWellUncheckedCreateWithoutWellInput> | FieldWellCreateWithoutWellInput[] | FieldWellUncheckedCreateWithoutWellInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutWellInput | FieldWellCreateOrConnectWithoutWellInput[]
    createMany?: FieldWellCreateManyWellInputEnvelope
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutWellInput = {
    create?: XOR<NotificationCreateWithoutWellInput, NotificationUncheckedCreateWithoutWellInput> | NotificationCreateWithoutWellInput[] | NotificationUncheckedCreateWithoutWellInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutWellInput | NotificationCreateOrConnectWithoutWellInput[]
    createMany?: NotificationCreateManyWellInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationLogCreateNestedManyWithoutWellInput = {
    create?: XOR<IrrigationLogCreateWithoutWellInput, IrrigationLogUncheckedCreateWithoutWellInput> | IrrigationLogCreateWithoutWellInput[] | IrrigationLogUncheckedCreateWithoutWellInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutWellInput | IrrigationLogCreateOrConnectWithoutWellInput[]
    createMany?: IrrigationLogCreateManyWellInputEnvelope
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
  }

  export type WellBillingPeriodCreateNestedManyWithoutWellInput = {
    create?: XOR<WellBillingPeriodCreateWithoutWellInput, WellBillingPeriodUncheckedCreateWithoutWellInput> | WellBillingPeriodCreateWithoutWellInput[] | WellBillingPeriodUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutWellInput | WellBillingPeriodCreateOrConnectWithoutWellInput[]
    createMany?: WellBillingPeriodCreateManyWellInputEnvelope
    connect?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
  }

  export type WorkerWellAssignmentCreateNestedManyWithoutWellInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWellInput, WorkerWellAssignmentUncheckedCreateWithoutWellInput> | WorkerWellAssignmentCreateWithoutWellInput[] | WorkerWellAssignmentUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWellInput | WorkerWellAssignmentCreateOrConnectWithoutWellInput[]
    createMany?: WorkerWellAssignmentCreateManyWellInputEnvelope
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
  }

  export type FieldWellUncheckedCreateNestedManyWithoutWellInput = {
    create?: XOR<FieldWellCreateWithoutWellInput, FieldWellUncheckedCreateWithoutWellInput> | FieldWellCreateWithoutWellInput[] | FieldWellUncheckedCreateWithoutWellInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutWellInput | FieldWellCreateOrConnectWithoutWellInput[]
    createMany?: FieldWellCreateManyWellInputEnvelope
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutWellInput = {
    create?: XOR<NotificationCreateWithoutWellInput, NotificationUncheckedCreateWithoutWellInput> | NotificationCreateWithoutWellInput[] | NotificationUncheckedCreateWithoutWellInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutWellInput | NotificationCreateOrConnectWithoutWellInput[]
    createMany?: NotificationCreateManyWellInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationLogUncheckedCreateNestedManyWithoutWellInput = {
    create?: XOR<IrrigationLogCreateWithoutWellInput, IrrigationLogUncheckedCreateWithoutWellInput> | IrrigationLogCreateWithoutWellInput[] | IrrigationLogUncheckedCreateWithoutWellInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutWellInput | IrrigationLogCreateOrConnectWithoutWellInput[]
    createMany?: IrrigationLogCreateManyWellInputEnvelope
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
  }

  export type WellBillingPeriodUncheckedCreateNestedManyWithoutWellInput = {
    create?: XOR<WellBillingPeriodCreateWithoutWellInput, WellBillingPeriodUncheckedCreateWithoutWellInput> | WellBillingPeriodCreateWithoutWellInput[] | WellBillingPeriodUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutWellInput | WellBillingPeriodCreateOrConnectWithoutWellInput[]
    createMany?: WellBillingPeriodCreateManyWellInputEnvelope
    connect?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
  }

  export type WorkerWellAssignmentUncheckedCreateNestedManyWithoutWellInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWellInput, WorkerWellAssignmentUncheckedCreateWithoutWellInput> | WorkerWellAssignmentCreateWithoutWellInput[] | WorkerWellAssignmentUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWellInput | WorkerWellAssignmentCreateOrConnectWithoutWellInput[]
    createMany?: WorkerWellAssignmentCreateManyWellInputEnvelope
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
  }

  export type FieldWellUpdateManyWithoutWellNestedInput = {
    create?: XOR<FieldWellCreateWithoutWellInput, FieldWellUncheckedCreateWithoutWellInput> | FieldWellCreateWithoutWellInput[] | FieldWellUncheckedCreateWithoutWellInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutWellInput | FieldWellCreateOrConnectWithoutWellInput[]
    upsert?: FieldWellUpsertWithWhereUniqueWithoutWellInput | FieldWellUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: FieldWellCreateManyWellInputEnvelope
    set?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    disconnect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    delete?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    update?: FieldWellUpdateWithWhereUniqueWithoutWellInput | FieldWellUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: FieldWellUpdateManyWithWhereWithoutWellInput | FieldWellUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: FieldWellScalarWhereInput | FieldWellScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutWellNestedInput = {
    create?: XOR<NotificationCreateWithoutWellInput, NotificationUncheckedCreateWithoutWellInput> | NotificationCreateWithoutWellInput[] | NotificationUncheckedCreateWithoutWellInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutWellInput | NotificationCreateOrConnectWithoutWellInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutWellInput | NotificationUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: NotificationCreateManyWellInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutWellInput | NotificationUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutWellInput | NotificationUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationLogUpdateManyWithoutWellNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutWellInput, IrrigationLogUncheckedCreateWithoutWellInput> | IrrigationLogCreateWithoutWellInput[] | IrrigationLogUncheckedCreateWithoutWellInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutWellInput | IrrigationLogCreateOrConnectWithoutWellInput[]
    upsert?: IrrigationLogUpsertWithWhereUniqueWithoutWellInput | IrrigationLogUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: IrrigationLogCreateManyWellInputEnvelope
    set?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    disconnect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    delete?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    update?: IrrigationLogUpdateWithWhereUniqueWithoutWellInput | IrrigationLogUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: IrrigationLogUpdateManyWithWhereWithoutWellInput | IrrigationLogUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
  }

  export type WellBillingPeriodUpdateManyWithoutWellNestedInput = {
    create?: XOR<WellBillingPeriodCreateWithoutWellInput, WellBillingPeriodUncheckedCreateWithoutWellInput> | WellBillingPeriodCreateWithoutWellInput[] | WellBillingPeriodUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutWellInput | WellBillingPeriodCreateOrConnectWithoutWellInput[]
    upsert?: WellBillingPeriodUpsertWithWhereUniqueWithoutWellInput | WellBillingPeriodUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: WellBillingPeriodCreateManyWellInputEnvelope
    set?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    disconnect?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    delete?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    connect?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    update?: WellBillingPeriodUpdateWithWhereUniqueWithoutWellInput | WellBillingPeriodUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: WellBillingPeriodUpdateManyWithWhereWithoutWellInput | WellBillingPeriodUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: WellBillingPeriodScalarWhereInput | WellBillingPeriodScalarWhereInput[]
  }

  export type WorkerWellAssignmentUpdateManyWithoutWellNestedInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWellInput, WorkerWellAssignmentUncheckedCreateWithoutWellInput> | WorkerWellAssignmentCreateWithoutWellInput[] | WorkerWellAssignmentUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWellInput | WorkerWellAssignmentCreateOrConnectWithoutWellInput[]
    upsert?: WorkerWellAssignmentUpsertWithWhereUniqueWithoutWellInput | WorkerWellAssignmentUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: WorkerWellAssignmentCreateManyWellInputEnvelope
    set?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    disconnect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    delete?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    update?: WorkerWellAssignmentUpdateWithWhereUniqueWithoutWellInput | WorkerWellAssignmentUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: WorkerWellAssignmentUpdateManyWithWhereWithoutWellInput | WorkerWellAssignmentUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: WorkerWellAssignmentScalarWhereInput | WorkerWellAssignmentScalarWhereInput[]
  }

  export type FieldWellUncheckedUpdateManyWithoutWellNestedInput = {
    create?: XOR<FieldWellCreateWithoutWellInput, FieldWellUncheckedCreateWithoutWellInput> | FieldWellCreateWithoutWellInput[] | FieldWellUncheckedCreateWithoutWellInput[]
    connectOrCreate?: FieldWellCreateOrConnectWithoutWellInput | FieldWellCreateOrConnectWithoutWellInput[]
    upsert?: FieldWellUpsertWithWhereUniqueWithoutWellInput | FieldWellUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: FieldWellCreateManyWellInputEnvelope
    set?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    disconnect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    delete?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    connect?: FieldWellWhereUniqueInput | FieldWellWhereUniqueInput[]
    update?: FieldWellUpdateWithWhereUniqueWithoutWellInput | FieldWellUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: FieldWellUpdateManyWithWhereWithoutWellInput | FieldWellUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: FieldWellScalarWhereInput | FieldWellScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutWellNestedInput = {
    create?: XOR<NotificationCreateWithoutWellInput, NotificationUncheckedCreateWithoutWellInput> | NotificationCreateWithoutWellInput[] | NotificationUncheckedCreateWithoutWellInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutWellInput | NotificationCreateOrConnectWithoutWellInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutWellInput | NotificationUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: NotificationCreateManyWellInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutWellInput | NotificationUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutWellInput | NotificationUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationLogUncheckedUpdateManyWithoutWellNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutWellInput, IrrigationLogUncheckedCreateWithoutWellInput> | IrrigationLogCreateWithoutWellInput[] | IrrigationLogUncheckedCreateWithoutWellInput[]
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutWellInput | IrrigationLogCreateOrConnectWithoutWellInput[]
    upsert?: IrrigationLogUpsertWithWhereUniqueWithoutWellInput | IrrigationLogUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: IrrigationLogCreateManyWellInputEnvelope
    set?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    disconnect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    delete?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    connect?: IrrigationLogWhereUniqueInput | IrrigationLogWhereUniqueInput[]
    update?: IrrigationLogUpdateWithWhereUniqueWithoutWellInput | IrrigationLogUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: IrrigationLogUpdateManyWithWhereWithoutWellInput | IrrigationLogUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
  }

  export type WellBillingPeriodUncheckedUpdateManyWithoutWellNestedInput = {
    create?: XOR<WellBillingPeriodCreateWithoutWellInput, WellBillingPeriodUncheckedCreateWithoutWellInput> | WellBillingPeriodCreateWithoutWellInput[] | WellBillingPeriodUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutWellInput | WellBillingPeriodCreateOrConnectWithoutWellInput[]
    upsert?: WellBillingPeriodUpsertWithWhereUniqueWithoutWellInput | WellBillingPeriodUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: WellBillingPeriodCreateManyWellInputEnvelope
    set?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    disconnect?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    delete?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    connect?: WellBillingPeriodWhereUniqueInput | WellBillingPeriodWhereUniqueInput[]
    update?: WellBillingPeriodUpdateWithWhereUniqueWithoutWellInput | WellBillingPeriodUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: WellBillingPeriodUpdateManyWithWhereWithoutWellInput | WellBillingPeriodUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: WellBillingPeriodScalarWhereInput | WellBillingPeriodScalarWhereInput[]
  }

  export type WorkerWellAssignmentUncheckedUpdateManyWithoutWellNestedInput = {
    create?: XOR<WorkerWellAssignmentCreateWithoutWellInput, WorkerWellAssignmentUncheckedCreateWithoutWellInput> | WorkerWellAssignmentCreateWithoutWellInput[] | WorkerWellAssignmentUncheckedCreateWithoutWellInput[]
    connectOrCreate?: WorkerWellAssignmentCreateOrConnectWithoutWellInput | WorkerWellAssignmentCreateOrConnectWithoutWellInput[]
    upsert?: WorkerWellAssignmentUpsertWithWhereUniqueWithoutWellInput | WorkerWellAssignmentUpsertWithWhereUniqueWithoutWellInput[]
    createMany?: WorkerWellAssignmentCreateManyWellInputEnvelope
    set?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    disconnect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    delete?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    connect?: WorkerWellAssignmentWhereUniqueInput | WorkerWellAssignmentWhereUniqueInput[]
    update?: WorkerWellAssignmentUpdateWithWhereUniqueWithoutWellInput | WorkerWellAssignmentUpdateWithWhereUniqueWithoutWellInput[]
    updateMany?: WorkerWellAssignmentUpdateManyWithWhereWithoutWellInput | WorkerWellAssignmentUpdateManyWithWhereWithoutWellInput[]
    deleteMany?: WorkerWellAssignmentScalarWhereInput | WorkerWellAssignmentScalarWhereInput[]
  }

  export type SeasonCreateNestedOneWithoutCropsInput = {
    create?: XOR<SeasonCreateWithoutCropsInput, SeasonUncheckedCreateWithoutCropsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutCropsInput
    connect?: SeasonWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutCropsInput = {
    create?: XOR<FieldCreateWithoutCropsInput, FieldUncheckedCreateWithoutCropsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutCropsInput
    connect?: FieldWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutCropInput = {
    create?: XOR<NotificationCreateWithoutCropInput, NotificationUncheckedCreateWithoutCropInput> | NotificationCreateWithoutCropInput[] | NotificationUncheckedCreateWithoutCropInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCropInput | NotificationCreateOrConnectWithoutCropInput[]
    createMany?: NotificationCreateManyCropInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCropInput = {
    create?: XOR<NotificationCreateWithoutCropInput, NotificationUncheckedCreateWithoutCropInput> | NotificationCreateWithoutCropInput[] | NotificationUncheckedCreateWithoutCropInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCropInput | NotificationCreateOrConnectWithoutCropInput[]
    createMany?: NotificationCreateManyCropInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type EnumCropStatusFieldUpdateOperationsInput = {
    set?: $Enums.CropStatus
  }

  export type SeasonUpdateOneWithoutCropsNestedInput = {
    create?: XOR<SeasonCreateWithoutCropsInput, SeasonUncheckedCreateWithoutCropsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutCropsInput
    upsert?: SeasonUpsertWithoutCropsInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutCropsInput, SeasonUpdateWithoutCropsInput>, SeasonUncheckedUpdateWithoutCropsInput>
  }

  export type FieldUpdateOneRequiredWithoutCropsNestedInput = {
    create?: XOR<FieldCreateWithoutCropsInput, FieldUncheckedCreateWithoutCropsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutCropsInput
    upsert?: FieldUpsertWithoutCropsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutCropsInput, FieldUpdateWithoutCropsInput>, FieldUncheckedUpdateWithoutCropsInput>
  }

  export type NotificationUpdateManyWithoutCropNestedInput = {
    create?: XOR<NotificationCreateWithoutCropInput, NotificationUncheckedCreateWithoutCropInput> | NotificationCreateWithoutCropInput[] | NotificationUncheckedCreateWithoutCropInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCropInput | NotificationCreateOrConnectWithoutCropInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCropInput | NotificationUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: NotificationCreateManyCropInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCropInput | NotificationUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCropInput | NotificationUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCropNestedInput = {
    create?: XOR<NotificationCreateWithoutCropInput, NotificationUncheckedCreateWithoutCropInput> | NotificationCreateWithoutCropInput[] | NotificationUncheckedCreateWithoutCropInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCropInput | NotificationCreateOrConnectWithoutCropInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCropInput | NotificationUpsertWithWhereUniqueWithoutCropInput[]
    createMany?: NotificationCreateManyCropInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCropInput | NotificationUpdateWithWhereUniqueWithoutCropInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCropInput | NotificationUpdateManyWithWhereWithoutCropInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FieldCreateNestedOneWithoutProcessingLogsInput = {
    create?: XOR<FieldCreateWithoutProcessingLogsInput, FieldUncheckedCreateWithoutProcessingLogsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutProcessingLogsInput
    connect?: FieldWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutProcessingLogInput = {
    create?: XOR<NotificationCreateWithoutProcessingLogInput, NotificationUncheckedCreateWithoutProcessingLogInput> | NotificationCreateWithoutProcessingLogInput[] | NotificationUncheckedCreateWithoutProcessingLogInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessingLogInput | NotificationCreateOrConnectWithoutProcessingLogInput[]
    createMany?: NotificationCreateManyProcessingLogInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutProcessingLogInput = {
    create?: XOR<NotificationCreateWithoutProcessingLogInput, NotificationUncheckedCreateWithoutProcessingLogInput> | NotificationCreateWithoutProcessingLogInput[] | NotificationUncheckedCreateWithoutProcessingLogInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessingLogInput | NotificationCreateOrConnectWithoutProcessingLogInput[]
    createMany?: NotificationCreateManyProcessingLogInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumProcessTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProcessType
  }

  export type FieldUpdateOneRequiredWithoutProcessingLogsNestedInput = {
    create?: XOR<FieldCreateWithoutProcessingLogsInput, FieldUncheckedCreateWithoutProcessingLogsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutProcessingLogsInput
    upsert?: FieldUpsertWithoutProcessingLogsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutProcessingLogsInput, FieldUpdateWithoutProcessingLogsInput>, FieldUncheckedUpdateWithoutProcessingLogsInput>
  }

  export type NotificationUpdateManyWithoutProcessingLogNestedInput = {
    create?: XOR<NotificationCreateWithoutProcessingLogInput, NotificationUncheckedCreateWithoutProcessingLogInput> | NotificationCreateWithoutProcessingLogInput[] | NotificationUncheckedCreateWithoutProcessingLogInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessingLogInput | NotificationCreateOrConnectWithoutProcessingLogInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProcessingLogInput | NotificationUpsertWithWhereUniqueWithoutProcessingLogInput[]
    createMany?: NotificationCreateManyProcessingLogInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProcessingLogInput | NotificationUpdateWithWhereUniqueWithoutProcessingLogInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProcessingLogInput | NotificationUpdateManyWithWhereWithoutProcessingLogInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutProcessingLogNestedInput = {
    create?: XOR<NotificationCreateWithoutProcessingLogInput, NotificationUncheckedCreateWithoutProcessingLogInput> | NotificationCreateWithoutProcessingLogInput[] | NotificationUncheckedCreateWithoutProcessingLogInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessingLogInput | NotificationCreateOrConnectWithoutProcessingLogInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProcessingLogInput | NotificationUpsertWithWhereUniqueWithoutProcessingLogInput[]
    createMany?: NotificationCreateManyProcessingLogInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProcessingLogInput | NotificationUpdateWithWhereUniqueWithoutProcessingLogInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProcessingLogInput | NotificationUpdateManyWithWhereWithoutProcessingLogInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InventoryOwnershipCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryOwnershipCreateWithoutInventoryInput, InventoryOwnershipUncheckedCreateWithoutInventoryInput> | InventoryOwnershipCreateWithoutInventoryInput[] | InventoryOwnershipUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutInventoryInput | InventoryOwnershipCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryOwnershipCreateManyInventoryInputEnvelope
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
  }

  export type InventoryUsageCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryUsageCreateWithoutInventoryInput, InventoryUsageUncheckedCreateWithoutInventoryInput> | InventoryUsageCreateWithoutInventoryInput[] | InventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutInventoryInput | InventoryUsageCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryUsageCreateManyInventoryInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryInput, InventoryTransactionUncheckedCreateWithoutInventoryInput> | InventoryTransactionCreateWithoutInventoryInput[] | InventoryTransactionUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryInput | InventoryTransactionCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryTransactionCreateManyInventoryInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutInventoryInput = {
    create?: XOR<NotificationCreateWithoutInventoryInput, NotificationUncheckedCreateWithoutInventoryInput> | NotificationCreateWithoutInventoryInput[] | NotificationUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryInput | NotificationCreateOrConnectWithoutInventoryInput[]
    createMany?: NotificationCreateManyInventoryInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationInventoryUsageCreateNestedManyWithoutInventoryInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutInventoryInput, IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput> | IrrigationInventoryUsageCreateWithoutInventoryInput[] | IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput | IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput[]
    createMany?: IrrigationInventoryUsageCreateManyInventoryInputEnvelope
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
  }

  export type InventoryOwnershipUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryOwnershipCreateWithoutInventoryInput, InventoryOwnershipUncheckedCreateWithoutInventoryInput> | InventoryOwnershipCreateWithoutInventoryInput[] | InventoryOwnershipUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutInventoryInput | InventoryOwnershipCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryOwnershipCreateManyInventoryInputEnvelope
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
  }

  export type InventoryUsageUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryUsageCreateWithoutInventoryInput, InventoryUsageUncheckedCreateWithoutInventoryInput> | InventoryUsageCreateWithoutInventoryInput[] | InventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutInventoryInput | InventoryUsageCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryUsageCreateManyInventoryInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryInput, InventoryTransactionUncheckedCreateWithoutInventoryInput> | InventoryTransactionCreateWithoutInventoryInput[] | InventoryTransactionUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryInput | InventoryTransactionCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryTransactionCreateManyInventoryInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<NotificationCreateWithoutInventoryInput, NotificationUncheckedCreateWithoutInventoryInput> | NotificationCreateWithoutInventoryInput[] | NotificationUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryInput | NotificationCreateOrConnectWithoutInventoryInput[]
    createMany?: NotificationCreateManyInventoryInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationInventoryUsageUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutInventoryInput, IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput> | IrrigationInventoryUsageCreateWithoutInventoryInput[] | IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput | IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput[]
    createMany?: IrrigationInventoryUsageCreateManyInventoryInputEnvelope
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
  }

  export type EnumInventoryCategoryFieldUpdateOperationsInput = {
    set?: $Enums.InventoryCategory
  }

  export type EnumUnitFieldUpdateOperationsInput = {
    set?: $Enums.Unit
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EnumInventoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InventoryStatus
  }

  export type InventoryOwnershipUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryOwnershipCreateWithoutInventoryInput, InventoryOwnershipUncheckedCreateWithoutInventoryInput> | InventoryOwnershipCreateWithoutInventoryInput[] | InventoryOwnershipUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutInventoryInput | InventoryOwnershipCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryOwnershipUpsertWithWhereUniqueWithoutInventoryInput | InventoryOwnershipUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryOwnershipCreateManyInventoryInputEnvelope
    set?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    disconnect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    delete?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    update?: InventoryOwnershipUpdateWithWhereUniqueWithoutInventoryInput | InventoryOwnershipUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryOwnershipUpdateManyWithWhereWithoutInventoryInput | InventoryOwnershipUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryOwnershipScalarWhereInput | InventoryOwnershipScalarWhereInput[]
  }

  export type InventoryUsageUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutInventoryInput, InventoryUsageUncheckedCreateWithoutInventoryInput> | InventoryUsageCreateWithoutInventoryInput[] | InventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutInventoryInput | InventoryUsageCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutInventoryInput | InventoryUsageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryUsageCreateManyInventoryInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutInventoryInput | InventoryUsageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutInventoryInput | InventoryUsageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryInput, InventoryTransactionUncheckedCreateWithoutInventoryInput> | InventoryTransactionCreateWithoutInventoryInput[] | InventoryTransactionUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryInput | InventoryTransactionCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutInventoryInput | InventoryTransactionUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryTransactionCreateManyInventoryInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutInventoryInput | InventoryTransactionUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutInventoryInput | InventoryTransactionUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<NotificationCreateWithoutInventoryInput, NotificationUncheckedCreateWithoutInventoryInput> | NotificationCreateWithoutInventoryInput[] | NotificationUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryInput | NotificationCreateOrConnectWithoutInventoryInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutInventoryInput | NotificationUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: NotificationCreateManyInventoryInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutInventoryInput | NotificationUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutInventoryInput | NotificationUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationInventoryUsageUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutInventoryInput, IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput> | IrrigationInventoryUsageCreateWithoutInventoryInput[] | IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput | IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput[]
    upsert?: IrrigationInventoryUsageUpsertWithWhereUniqueWithoutInventoryInput | IrrigationInventoryUsageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: IrrigationInventoryUsageCreateManyInventoryInputEnvelope
    set?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    delete?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    update?: IrrigationInventoryUsageUpdateWithWhereUniqueWithoutInventoryInput | IrrigationInventoryUsageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: IrrigationInventoryUsageUpdateManyWithWhereWithoutInventoryInput | IrrigationInventoryUsageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: IrrigationInventoryUsageScalarWhereInput | IrrigationInventoryUsageScalarWhereInput[]
  }

  export type InventoryOwnershipUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryOwnershipCreateWithoutInventoryInput, InventoryOwnershipUncheckedCreateWithoutInventoryInput> | InventoryOwnershipCreateWithoutInventoryInput[] | InventoryOwnershipUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryOwnershipCreateOrConnectWithoutInventoryInput | InventoryOwnershipCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryOwnershipUpsertWithWhereUniqueWithoutInventoryInput | InventoryOwnershipUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryOwnershipCreateManyInventoryInputEnvelope
    set?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    disconnect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    delete?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    connect?: InventoryOwnershipWhereUniqueInput | InventoryOwnershipWhereUniqueInput[]
    update?: InventoryOwnershipUpdateWithWhereUniqueWithoutInventoryInput | InventoryOwnershipUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryOwnershipUpdateManyWithWhereWithoutInventoryInput | InventoryOwnershipUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryOwnershipScalarWhereInput | InventoryOwnershipScalarWhereInput[]
  }

  export type InventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutInventoryInput, InventoryUsageUncheckedCreateWithoutInventoryInput> | InventoryUsageCreateWithoutInventoryInput[] | InventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutInventoryInput | InventoryUsageCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutInventoryInput | InventoryUsageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryUsageCreateManyInventoryInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutInventoryInput | InventoryUsageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutInventoryInput | InventoryUsageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryInput, InventoryTransactionUncheckedCreateWithoutInventoryInput> | InventoryTransactionCreateWithoutInventoryInput[] | InventoryTransactionUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryInput | InventoryTransactionCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutInventoryInput | InventoryTransactionUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryTransactionCreateManyInventoryInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutInventoryInput | InventoryTransactionUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutInventoryInput | InventoryTransactionUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<NotificationCreateWithoutInventoryInput, NotificationUncheckedCreateWithoutInventoryInput> | NotificationCreateWithoutInventoryInput[] | NotificationUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryInput | NotificationCreateOrConnectWithoutInventoryInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutInventoryInput | NotificationUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: NotificationCreateManyInventoryInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutInventoryInput | NotificationUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutInventoryInput | NotificationUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutInventoryInput, IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput> | IrrigationInventoryUsageCreateWithoutInventoryInput[] | IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput | IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput[]
    upsert?: IrrigationInventoryUsageUpsertWithWhereUniqueWithoutInventoryInput | IrrigationInventoryUsageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: IrrigationInventoryUsageCreateManyInventoryInputEnvelope
    set?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    delete?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    update?: IrrigationInventoryUsageUpdateWithWhereUniqueWithoutInventoryInput | IrrigationInventoryUsageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: IrrigationInventoryUsageUpdateManyWithWhereWithoutInventoryInput | IrrigationInventoryUsageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: IrrigationInventoryUsageScalarWhereInput | IrrigationInventoryUsageScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutOwnershipsInput = {
    create?: XOR<InventoryCreateWithoutOwnershipsInput, InventoryUncheckedCreateWithoutOwnershipsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutOwnershipsInput
    connect?: InventoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryOwnershipInput = {
    create?: XOR<UserCreateWithoutInventoryOwnershipInput, UserUncheckedCreateWithoutInventoryOwnershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryOwnershipInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutOwnershipsNestedInput = {
    create?: XOR<InventoryCreateWithoutOwnershipsInput, InventoryUncheckedCreateWithoutOwnershipsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutOwnershipsInput
    upsert?: InventoryUpsertWithoutOwnershipsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutOwnershipsInput, InventoryUpdateWithoutOwnershipsInput>, InventoryUncheckedUpdateWithoutOwnershipsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryOwnershipNestedInput = {
    create?: XOR<UserCreateWithoutInventoryOwnershipInput, UserUncheckedCreateWithoutInventoryOwnershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryOwnershipInput
    upsert?: UserUpsertWithoutInventoryOwnershipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryOwnershipInput, UserUpdateWithoutInventoryOwnershipInput>, UserUncheckedUpdateWithoutInventoryOwnershipInput>
  }

  export type SeasonCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<SeasonCreateWithoutPurchasesInput, SeasonUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutPurchasesInput
    connect?: SeasonWhereUniqueInput
  }

  export type PurchaseContributorCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseContributorCreateWithoutPurchaseInput, PurchaseContributorUncheckedCreateWithoutPurchaseInput> | PurchaseContributorCreateWithoutPurchaseInput[] | PurchaseContributorUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutPurchaseInput | PurchaseContributorCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseContributorCreateManyPurchaseInputEnvelope
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
  }

  export type DebtCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<DebtCreateWithoutPurchaseInput, DebtUncheckedCreateWithoutPurchaseInput> | DebtCreateWithoutPurchaseInput[] | DebtUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutPurchaseInput | DebtCreateOrConnectWithoutPurchaseInput[]
    createMany?: DebtCreateManyPurchaseInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseInput, InvoiceUncheckedCreateWithoutPurchaseInput> | InvoiceCreateWithoutPurchaseInput[] | InvoiceUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseInput | InvoiceCreateOrConnectWithoutPurchaseInput[]
    createMany?: InvoiceCreateManyPurchaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<InventoryTransactionCreateWithoutPurchaseInput, InventoryTransactionUncheckedCreateWithoutPurchaseInput> | InventoryTransactionCreateWithoutPurchaseInput[] | InventoryTransactionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutPurchaseInput | InventoryTransactionCreateOrConnectWithoutPurchaseInput[]
    createMany?: InventoryTransactionCreateManyPurchaseInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseApprovalCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseApprovalCreateWithoutPurchaseInput, PurchaseApprovalUncheckedCreateWithoutPurchaseInput> | PurchaseApprovalCreateWithoutPurchaseInput[] | PurchaseApprovalUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutPurchaseInput | PurchaseApprovalCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseApprovalCreateManyPurchaseInputEnvelope
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<NotificationCreateWithoutPurchaseInput, NotificationUncheckedCreateWithoutPurchaseInput> | NotificationCreateWithoutPurchaseInput[] | NotificationUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPurchaseInput | NotificationCreateOrConnectWithoutPurchaseInput[]
    createMany?: NotificationCreateManyPurchaseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseContributorCreateWithoutPurchaseInput, PurchaseContributorUncheckedCreateWithoutPurchaseInput> | PurchaseContributorCreateWithoutPurchaseInput[] | PurchaseContributorUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutPurchaseInput | PurchaseContributorCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseContributorCreateManyPurchaseInputEnvelope
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
  }

  export type DebtUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<DebtCreateWithoutPurchaseInput, DebtUncheckedCreateWithoutPurchaseInput> | DebtCreateWithoutPurchaseInput[] | DebtUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutPurchaseInput | DebtCreateOrConnectWithoutPurchaseInput[]
    createMany?: DebtCreateManyPurchaseInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseInput, InvoiceUncheckedCreateWithoutPurchaseInput> | InvoiceCreateWithoutPurchaseInput[] | InvoiceUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseInput | InvoiceCreateOrConnectWithoutPurchaseInput[]
    createMany?: InvoiceCreateManyPurchaseInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<InventoryTransactionCreateWithoutPurchaseInput, InventoryTransactionUncheckedCreateWithoutPurchaseInput> | InventoryTransactionCreateWithoutPurchaseInput[] | InventoryTransactionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutPurchaseInput | InventoryTransactionCreateOrConnectWithoutPurchaseInput[]
    createMany?: InventoryTransactionCreateManyPurchaseInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseApprovalCreateWithoutPurchaseInput, PurchaseApprovalUncheckedCreateWithoutPurchaseInput> | PurchaseApprovalCreateWithoutPurchaseInput[] | PurchaseApprovalUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutPurchaseInput | PurchaseApprovalCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseApprovalCreateManyPurchaseInputEnvelope
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<NotificationCreateWithoutPurchaseInput, NotificationUncheckedCreateWithoutPurchaseInput> | NotificationCreateWithoutPurchaseInput[] | NotificationUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPurchaseInput | NotificationCreateOrConnectWithoutPurchaseInput[]
    createMany?: NotificationCreateManyPurchaseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumProductCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ProductCategory
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type SeasonUpdateOneWithoutPurchasesNestedInput = {
    create?: XOR<SeasonCreateWithoutPurchasesInput, SeasonUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutPurchasesInput
    upsert?: SeasonUpsertWithoutPurchasesInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutPurchasesInput, SeasonUpdateWithoutPurchasesInput>, SeasonUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseContributorUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseContributorCreateWithoutPurchaseInput, PurchaseContributorUncheckedCreateWithoutPurchaseInput> | PurchaseContributorCreateWithoutPurchaseInput[] | PurchaseContributorUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutPurchaseInput | PurchaseContributorCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseContributorUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseContributorUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseContributorCreateManyPurchaseInputEnvelope
    set?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    disconnect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    delete?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    update?: PurchaseContributorUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseContributorUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseContributorUpdateManyWithWhereWithoutPurchaseInput | PurchaseContributorUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseContributorScalarWhereInput | PurchaseContributorScalarWhereInput[]
  }

  export type DebtUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<DebtCreateWithoutPurchaseInput, DebtUncheckedCreateWithoutPurchaseInput> | DebtCreateWithoutPurchaseInput[] | DebtUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutPurchaseInput | DebtCreateOrConnectWithoutPurchaseInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutPurchaseInput | DebtUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: DebtCreateManyPurchaseInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutPurchaseInput | DebtUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutPurchaseInput | DebtUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseInput, InvoiceUncheckedCreateWithoutPurchaseInput> | InvoiceCreateWithoutPurchaseInput[] | InvoiceUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseInput | InvoiceCreateOrConnectWithoutPurchaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPurchaseInput | InvoiceUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: InvoiceCreateManyPurchaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPurchaseInput | InvoiceUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPurchaseInput | InvoiceUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutPurchaseInput, InventoryTransactionUncheckedCreateWithoutPurchaseInput> | InventoryTransactionCreateWithoutPurchaseInput[] | InventoryTransactionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutPurchaseInput | InventoryTransactionCreateOrConnectWithoutPurchaseInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutPurchaseInput | InventoryTransactionUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: InventoryTransactionCreateManyPurchaseInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutPurchaseInput | InventoryTransactionUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutPurchaseInput | InventoryTransactionUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseApprovalUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseApprovalCreateWithoutPurchaseInput, PurchaseApprovalUncheckedCreateWithoutPurchaseInput> | PurchaseApprovalCreateWithoutPurchaseInput[] | PurchaseApprovalUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutPurchaseInput | PurchaseApprovalCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseApprovalUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseApprovalUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseApprovalCreateManyPurchaseInputEnvelope
    set?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    disconnect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    delete?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    update?: PurchaseApprovalUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseApprovalUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseApprovalUpdateManyWithWhereWithoutPurchaseInput | PurchaseApprovalUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseApprovalScalarWhereInput | PurchaseApprovalScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<NotificationCreateWithoutPurchaseInput, NotificationUncheckedCreateWithoutPurchaseInput> | NotificationCreateWithoutPurchaseInput[] | NotificationUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPurchaseInput | NotificationCreateOrConnectWithoutPurchaseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPurchaseInput | NotificationUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: NotificationCreateManyPurchaseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPurchaseInput | NotificationUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPurchaseInput | NotificationUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseContributorCreateWithoutPurchaseInput, PurchaseContributorUncheckedCreateWithoutPurchaseInput> | PurchaseContributorCreateWithoutPurchaseInput[] | PurchaseContributorUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutPurchaseInput | PurchaseContributorCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseContributorUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseContributorUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseContributorCreateManyPurchaseInputEnvelope
    set?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    disconnect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    delete?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    connect?: PurchaseContributorWhereUniqueInput | PurchaseContributorWhereUniqueInput[]
    update?: PurchaseContributorUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseContributorUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseContributorUpdateManyWithWhereWithoutPurchaseInput | PurchaseContributorUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseContributorScalarWhereInput | PurchaseContributorScalarWhereInput[]
  }

  export type DebtUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<DebtCreateWithoutPurchaseInput, DebtUncheckedCreateWithoutPurchaseInput> | DebtCreateWithoutPurchaseInput[] | DebtUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutPurchaseInput | DebtCreateOrConnectWithoutPurchaseInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutPurchaseInput | DebtUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: DebtCreateManyPurchaseInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutPurchaseInput | DebtUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutPurchaseInput | DebtUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseInput, InvoiceUncheckedCreateWithoutPurchaseInput> | InvoiceCreateWithoutPurchaseInput[] | InvoiceUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseInput | InvoiceCreateOrConnectWithoutPurchaseInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPurchaseInput | InvoiceUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: InvoiceCreateManyPurchaseInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPurchaseInput | InvoiceUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPurchaseInput | InvoiceUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutPurchaseInput, InventoryTransactionUncheckedCreateWithoutPurchaseInput> | InventoryTransactionCreateWithoutPurchaseInput[] | InventoryTransactionUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutPurchaseInput | InventoryTransactionCreateOrConnectWithoutPurchaseInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutPurchaseInput | InventoryTransactionUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: InventoryTransactionCreateManyPurchaseInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutPurchaseInput | InventoryTransactionUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutPurchaseInput | InventoryTransactionUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseApprovalCreateWithoutPurchaseInput, PurchaseApprovalUncheckedCreateWithoutPurchaseInput> | PurchaseApprovalCreateWithoutPurchaseInput[] | PurchaseApprovalUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutPurchaseInput | PurchaseApprovalCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseApprovalUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseApprovalUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseApprovalCreateManyPurchaseInputEnvelope
    set?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    disconnect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    delete?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    connect?: PurchaseApprovalWhereUniqueInput | PurchaseApprovalWhereUniqueInput[]
    update?: PurchaseApprovalUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseApprovalUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseApprovalUpdateManyWithWhereWithoutPurchaseInput | PurchaseApprovalUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseApprovalScalarWhereInput | PurchaseApprovalScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<NotificationCreateWithoutPurchaseInput, NotificationUncheckedCreateWithoutPurchaseInput> | NotificationCreateWithoutPurchaseInput[] | NotificationUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPurchaseInput | NotificationCreateOrConnectWithoutPurchaseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPurchaseInput | NotificationUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: NotificationCreateManyPurchaseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPurchaseInput | NotificationUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPurchaseInput | NotificationUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PurchaseCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<PurchaseCreateWithoutApprovalsInput, PurchaseUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutApprovalsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseApprovalsInput = {
    create?: XOR<UserCreateWithoutPurchaseApprovalsInput, UserUncheckedCreateWithoutPurchaseApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutApprovalInput = {
    create?: XOR<NotificationCreateWithoutApprovalInput, NotificationUncheckedCreateWithoutApprovalInput> | NotificationCreateWithoutApprovalInput[] | NotificationUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutApprovalInput | NotificationCreateOrConnectWithoutApprovalInput[]
    createMany?: NotificationCreateManyApprovalInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutApprovalInput = {
    create?: XOR<NotificationCreateWithoutApprovalInput, NotificationUncheckedCreateWithoutApprovalInput> | NotificationCreateWithoutApprovalInput[] | NotificationUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutApprovalInput | NotificationCreateOrConnectWithoutApprovalInput[]
    createMany?: NotificationCreateManyApprovalInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PurchaseUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<PurchaseCreateWithoutApprovalsInput, PurchaseUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutApprovalsInput
    upsert?: PurchaseUpsertWithoutApprovalsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutApprovalsInput, PurchaseUpdateWithoutApprovalsInput>, PurchaseUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseApprovalsInput, UserUncheckedCreateWithoutPurchaseApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseApprovalsInput
    upsert?: UserUpsertWithoutPurchaseApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseApprovalsInput, UserUpdateWithoutPurchaseApprovalsInput>, UserUncheckedUpdateWithoutPurchaseApprovalsInput>
  }

  export type NotificationUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<NotificationCreateWithoutApprovalInput, NotificationUncheckedCreateWithoutApprovalInput> | NotificationCreateWithoutApprovalInput[] | NotificationUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutApprovalInput | NotificationCreateOrConnectWithoutApprovalInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutApprovalInput | NotificationUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: NotificationCreateManyApprovalInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutApprovalInput | NotificationUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutApprovalInput | NotificationUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<NotificationCreateWithoutApprovalInput, NotificationUncheckedCreateWithoutApprovalInput> | NotificationCreateWithoutApprovalInput[] | NotificationUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutApprovalInput | NotificationCreateOrConnectWithoutApprovalInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutApprovalInput | NotificationUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: NotificationCreateManyApprovalInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutApprovalInput | NotificationUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutApprovalInput | NotificationUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PurchaseCreateNestedOneWithoutContributorsInput = {
    create?: XOR<PurchaseCreateWithoutContributorsInput, PurchaseUncheckedCreateWithoutContributorsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutContributorsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseContributionsInput = {
    create?: XOR<UserCreateWithoutPurchaseContributionsInput, UserUncheckedCreateWithoutPurchaseContributionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseContributionsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentHistoryCreateNestedManyWithoutContributorInput = {
    create?: XOR<PaymentHistoryCreateWithoutContributorInput, PaymentHistoryUncheckedCreateWithoutContributorInput> | PaymentHistoryCreateWithoutContributorInput[] | PaymentHistoryUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutContributorInput | PaymentHistoryCreateOrConnectWithoutContributorInput[]
    createMany?: PaymentHistoryCreateManyContributorInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutContributorInput = {
    create?: XOR<NotificationCreateWithoutContributorInput, NotificationUncheckedCreateWithoutContributorInput> | NotificationCreateWithoutContributorInput[] | NotificationUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutContributorInput | NotificationCreateOrConnectWithoutContributorInput[]
    createMany?: NotificationCreateManyContributorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentHistoryUncheckedCreateNestedManyWithoutContributorInput = {
    create?: XOR<PaymentHistoryCreateWithoutContributorInput, PaymentHistoryUncheckedCreateWithoutContributorInput> | PaymentHistoryCreateWithoutContributorInput[] | PaymentHistoryUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutContributorInput | PaymentHistoryCreateOrConnectWithoutContributorInput[]
    createMany?: PaymentHistoryCreateManyContributorInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutContributorInput = {
    create?: XOR<NotificationCreateWithoutContributorInput, NotificationUncheckedCreateWithoutContributorInput> | NotificationCreateWithoutContributorInput[] | NotificationUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutContributorInput | NotificationCreateOrConnectWithoutContributorInput[]
    createMany?: NotificationCreateManyContributorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PurchaseUpdateOneRequiredWithoutContributorsNestedInput = {
    create?: XOR<PurchaseCreateWithoutContributorsInput, PurchaseUncheckedCreateWithoutContributorsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutContributorsInput
    upsert?: PurchaseUpsertWithoutContributorsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutContributorsInput, PurchaseUpdateWithoutContributorsInput>, PurchaseUncheckedUpdateWithoutContributorsInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseContributionsNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseContributionsInput, UserUncheckedCreateWithoutPurchaseContributionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseContributionsInput
    upsert?: UserUpsertWithoutPurchaseContributionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseContributionsInput, UserUpdateWithoutPurchaseContributionsInput>, UserUncheckedUpdateWithoutPurchaseContributionsInput>
  }

  export type PaymentHistoryUpdateManyWithoutContributorNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutContributorInput, PaymentHistoryUncheckedCreateWithoutContributorInput> | PaymentHistoryCreateWithoutContributorInput[] | PaymentHistoryUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutContributorInput | PaymentHistoryCreateOrConnectWithoutContributorInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutContributorInput | PaymentHistoryUpsertWithWhereUniqueWithoutContributorInput[]
    createMany?: PaymentHistoryCreateManyContributorInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutContributorInput | PaymentHistoryUpdateWithWhereUniqueWithoutContributorInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutContributorInput | PaymentHistoryUpdateManyWithWhereWithoutContributorInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutContributorNestedInput = {
    create?: XOR<NotificationCreateWithoutContributorInput, NotificationUncheckedCreateWithoutContributorInput> | NotificationCreateWithoutContributorInput[] | NotificationUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutContributorInput | NotificationCreateOrConnectWithoutContributorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutContributorInput | NotificationUpsertWithWhereUniqueWithoutContributorInput[]
    createMany?: NotificationCreateManyContributorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutContributorInput | NotificationUpdateWithWhereUniqueWithoutContributorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutContributorInput | NotificationUpdateManyWithWhereWithoutContributorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutContributorNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutContributorInput, PaymentHistoryUncheckedCreateWithoutContributorInput> | PaymentHistoryCreateWithoutContributorInput[] | PaymentHistoryUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutContributorInput | PaymentHistoryCreateOrConnectWithoutContributorInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutContributorInput | PaymentHistoryUpsertWithWhereUniqueWithoutContributorInput[]
    createMany?: PaymentHistoryCreateManyContributorInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutContributorInput | PaymentHistoryUpdateWithWhereUniqueWithoutContributorInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutContributorInput | PaymentHistoryUpdateManyWithWhereWithoutContributorInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutContributorNestedInput = {
    create?: XOR<NotificationCreateWithoutContributorInput, NotificationUncheckedCreateWithoutContributorInput> | NotificationCreateWithoutContributorInput[] | NotificationUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutContributorInput | NotificationCreateOrConnectWithoutContributorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutContributorInput | NotificationUpsertWithWhereUniqueWithoutContributorInput[]
    createMany?: NotificationCreateManyContributorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutContributorInput | NotificationUpdateWithWhereUniqueWithoutContributorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutContributorInput | NotificationUpdateManyWithWhereWithoutContributorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DebtCreateNestedOneWithoutPaymentHistoryInput = {
    create?: XOR<DebtCreateWithoutPaymentHistoryInput, DebtUncheckedCreateWithoutPaymentHistoryInput>
    connectOrCreate?: DebtCreateOrConnectWithoutPaymentHistoryInput
    connect?: DebtWhereUniqueInput
  }

  export type PurchaseContributorCreateNestedOneWithoutPaymentHistoryInput = {
    create?: XOR<PurchaseContributorCreateWithoutPaymentHistoryInput, PurchaseContributorUncheckedCreateWithoutPaymentHistoryInput>
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutPaymentHistoryInput
    connect?: PurchaseContributorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsMadeInput = {
    create?: XOR<UserCreateWithoutPaymentsMadeInput, UserUncheckedCreateWithoutPaymentsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsReceivedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutPaymentInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput> | NotificationCreateWithoutPaymentInput[] | NotificationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput | NotificationCreateOrConnectWithoutPaymentInput[]
    createMany?: NotificationCreateManyPaymentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput> | NotificationCreateWithoutPaymentInput[] | NotificationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput | NotificationCreateOrConnectWithoutPaymentInput[]
    createMany?: NotificationCreateManyPaymentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DebtUpdateOneWithoutPaymentHistoryNestedInput = {
    create?: XOR<DebtCreateWithoutPaymentHistoryInput, DebtUncheckedCreateWithoutPaymentHistoryInput>
    connectOrCreate?: DebtCreateOrConnectWithoutPaymentHistoryInput
    upsert?: DebtUpsertWithoutPaymentHistoryInput
    disconnect?: boolean
    delete?: DebtWhereInput | boolean
    connect?: DebtWhereUniqueInput
    update?: XOR<XOR<DebtUpdateToOneWithWhereWithoutPaymentHistoryInput, DebtUpdateWithoutPaymentHistoryInput>, DebtUncheckedUpdateWithoutPaymentHistoryInput>
  }

  export type PurchaseContributorUpdateOneWithoutPaymentHistoryNestedInput = {
    create?: XOR<PurchaseContributorCreateWithoutPaymentHistoryInput, PurchaseContributorUncheckedCreateWithoutPaymentHistoryInput>
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutPaymentHistoryInput
    upsert?: PurchaseContributorUpsertWithoutPaymentHistoryInput
    disconnect?: boolean
    delete?: PurchaseContributorWhereInput | boolean
    connect?: PurchaseContributorWhereUniqueInput
    update?: XOR<XOR<PurchaseContributorUpdateToOneWithWhereWithoutPaymentHistoryInput, PurchaseContributorUpdateWithoutPaymentHistoryInput>, PurchaseContributorUncheckedUpdateWithoutPaymentHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsMadeNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsMadeInput, UserUncheckedCreateWithoutPaymentsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsMadeInput
    upsert?: UserUpsertWithoutPaymentsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsMadeInput, UserUpdateWithoutPaymentsMadeInput>, UserUncheckedUpdateWithoutPaymentsMadeInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    upsert?: UserUpsertWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsReceivedInput, UserUpdateWithoutPaymentsReceivedInput>, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type NotificationUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput> | NotificationCreateWithoutPaymentInput[] | NotificationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput | NotificationCreateOrConnectWithoutPaymentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPaymentInput | NotificationUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: NotificationCreateManyPaymentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPaymentInput | NotificationUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPaymentInput | NotificationUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput> | NotificationCreateWithoutPaymentInput[] | NotificationUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput | NotificationCreateOrConnectWithoutPaymentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPaymentInput | NotificationUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: NotificationCreateManyPaymentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPaymentInput | NotificationUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPaymentInput | NotificationUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SeasonCreateNestedOneWithoutInventoryTransactionsInput = {
    create?: XOR<SeasonCreateWithoutInventoryTransactionsInput, SeasonUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutInventoryTransactionsInput
    connect?: SeasonWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryTransactionsInput = {
    create?: XOR<InventoryCreateWithoutInventoryTransactionsInput, InventoryUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryTransactionsInput
    connect?: InventoryWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutInventoryTransactionsInput = {
    create?: XOR<PurchaseCreateWithoutInventoryTransactionsInput, PurchaseUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutInventoryTransactionsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryTransactionsInput = {
    create?: XOR<UserCreateWithoutInventoryTransactionsInput, UserUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutTransactionInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type SeasonUpdateOneWithoutInventoryTransactionsNestedInput = {
    create?: XOR<SeasonCreateWithoutInventoryTransactionsInput, SeasonUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutInventoryTransactionsInput
    upsert?: SeasonUpsertWithoutInventoryTransactionsInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutInventoryTransactionsInput, SeasonUpdateWithoutInventoryTransactionsInput>, SeasonUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryTransactionsNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryTransactionsInput, InventoryUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryTransactionsInput
    upsert?: InventoryUpsertWithoutInventoryTransactionsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventoryTransactionsInput, InventoryUpdateWithoutInventoryTransactionsInput>, InventoryUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type PurchaseUpdateOneWithoutInventoryTransactionsNestedInput = {
    create?: XOR<PurchaseCreateWithoutInventoryTransactionsInput, PurchaseUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutInventoryTransactionsInput
    upsert?: PurchaseUpsertWithoutInventoryTransactionsInput
    disconnect?: boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutInventoryTransactionsInput, PurchaseUpdateWithoutInventoryTransactionsInput>, PurchaseUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryTransactionsInput, UserUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryTransactionsInput
    upsert?: UserUpsertWithoutInventoryTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryTransactionsInput, UserUpdateWithoutInventoryTransactionsInput>, UserUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type NotificationUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTransactionInput | NotificationUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTransactionInput | NotificationUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTransactionInput | NotificationUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTransactionInput | NotificationUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTransactionInput | NotificationUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTransactionInput | NotificationUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDebtsAsCreditorInput = {
    create?: XOR<UserCreateWithoutDebtsAsCreditorInput, UserUncheckedCreateWithoutDebtsAsCreditorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtsAsCreditorInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDebtsAsDebtorInput = {
    create?: XOR<UserCreateWithoutDebtsAsDebtorInput, UserUncheckedCreateWithoutDebtsAsDebtorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtsAsDebtorInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutDebtsInput = {
    create?: XOR<InvoiceCreateWithoutDebtsInput, InvoiceUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutDebtsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutDebtsInput = {
    create?: XOR<PurchaseCreateWithoutDebtsInput, PurchaseUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutDebtsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type PaymentHistoryCreateNestedManyWithoutDebtInput = {
    create?: XOR<PaymentHistoryCreateWithoutDebtInput, PaymentHistoryUncheckedCreateWithoutDebtInput> | PaymentHistoryCreateWithoutDebtInput[] | PaymentHistoryUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutDebtInput | PaymentHistoryCreateOrConnectWithoutDebtInput[]
    createMany?: PaymentHistoryCreateManyDebtInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type WellBillDistributionCreateNestedManyWithoutDebtInput = {
    create?: XOR<WellBillDistributionCreateWithoutDebtInput, WellBillDistributionUncheckedCreateWithoutDebtInput> | WellBillDistributionCreateWithoutDebtInput[] | WellBillDistributionUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutDebtInput | WellBillDistributionCreateOrConnectWithoutDebtInput[]
    createMany?: WellBillDistributionCreateManyDebtInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutDebtInput = {
    create?: XOR<NotificationCreateWithoutDebtInput, NotificationUncheckedCreateWithoutDebtInput> | NotificationCreateWithoutDebtInput[] | NotificationUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDebtInput | NotificationCreateOrConnectWithoutDebtInput[]
    createMany?: NotificationCreateManyDebtInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<PaymentHistoryCreateWithoutDebtInput, PaymentHistoryUncheckedCreateWithoutDebtInput> | PaymentHistoryCreateWithoutDebtInput[] | PaymentHistoryUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutDebtInput | PaymentHistoryCreateOrConnectWithoutDebtInput[]
    createMany?: PaymentHistoryCreateManyDebtInputEnvelope
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
  }

  export type WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<WellBillDistributionCreateWithoutDebtInput, WellBillDistributionUncheckedCreateWithoutDebtInput> | WellBillDistributionCreateWithoutDebtInput[] | WellBillDistributionUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutDebtInput | WellBillDistributionCreateOrConnectWithoutDebtInput[]
    createMany?: WellBillDistributionCreateManyDebtInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<NotificationCreateWithoutDebtInput, NotificationUncheckedCreateWithoutDebtInput> | NotificationCreateWithoutDebtInput[] | NotificationUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDebtInput | NotificationCreateOrConnectWithoutDebtInput[]
    createMany?: NotificationCreateManyDebtInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumDebtStatusFieldUpdateOperationsInput = {
    set?: $Enums.DebtStatus
  }

  export type UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput = {
    create?: XOR<UserCreateWithoutDebtsAsCreditorInput, UserUncheckedCreateWithoutDebtsAsCreditorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtsAsCreditorInput
    upsert?: UserUpsertWithoutDebtsAsCreditorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtsAsCreditorInput, UserUpdateWithoutDebtsAsCreditorInput>, UserUncheckedUpdateWithoutDebtsAsCreditorInput>
  }

  export type UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput = {
    create?: XOR<UserCreateWithoutDebtsAsDebtorInput, UserUncheckedCreateWithoutDebtsAsDebtorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtsAsDebtorInput
    upsert?: UserUpsertWithoutDebtsAsDebtorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtsAsDebtorInput, UserUpdateWithoutDebtsAsDebtorInput>, UserUncheckedUpdateWithoutDebtsAsDebtorInput>
  }

  export type InvoiceUpdateOneWithoutDebtsNestedInput = {
    create?: XOR<InvoiceCreateWithoutDebtsInput, InvoiceUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutDebtsInput
    upsert?: InvoiceUpsertWithoutDebtsInput
    disconnect?: boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutDebtsInput, InvoiceUpdateWithoutDebtsInput>, InvoiceUncheckedUpdateWithoutDebtsInput>
  }

  export type PurchaseUpdateOneWithoutDebtsNestedInput = {
    create?: XOR<PurchaseCreateWithoutDebtsInput, PurchaseUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutDebtsInput
    upsert?: PurchaseUpsertWithoutDebtsInput
    disconnect?: boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutDebtsInput, PurchaseUpdateWithoutDebtsInput>, PurchaseUncheckedUpdateWithoutDebtsInput>
  }

  export type PaymentHistoryUpdateManyWithoutDebtNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutDebtInput, PaymentHistoryUncheckedCreateWithoutDebtInput> | PaymentHistoryCreateWithoutDebtInput[] | PaymentHistoryUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutDebtInput | PaymentHistoryCreateOrConnectWithoutDebtInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutDebtInput | PaymentHistoryUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: PaymentHistoryCreateManyDebtInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutDebtInput | PaymentHistoryUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutDebtInput | PaymentHistoryUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type WellBillDistributionUpdateManyWithoutDebtNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutDebtInput, WellBillDistributionUncheckedCreateWithoutDebtInput> | WellBillDistributionCreateWithoutDebtInput[] | WellBillDistributionUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutDebtInput | WellBillDistributionCreateOrConnectWithoutDebtInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutDebtInput | WellBillDistributionUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: WellBillDistributionCreateManyDebtInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutDebtInput | WellBillDistributionUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutDebtInput | WellBillDistributionUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutDebtNestedInput = {
    create?: XOR<NotificationCreateWithoutDebtInput, NotificationUncheckedCreateWithoutDebtInput> | NotificationCreateWithoutDebtInput[] | NotificationUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDebtInput | NotificationCreateOrConnectWithoutDebtInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDebtInput | NotificationUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: NotificationCreateManyDebtInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDebtInput | NotificationUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDebtInput | NotificationUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutDebtInput, PaymentHistoryUncheckedCreateWithoutDebtInput> | PaymentHistoryCreateWithoutDebtInput[] | PaymentHistoryUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutDebtInput | PaymentHistoryCreateOrConnectWithoutDebtInput[]
    upsert?: PaymentHistoryUpsertWithWhereUniqueWithoutDebtInput | PaymentHistoryUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: PaymentHistoryCreateManyDebtInputEnvelope
    set?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    disconnect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    delete?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    connect?: PaymentHistoryWhereUniqueInput | PaymentHistoryWhereUniqueInput[]
    update?: PaymentHistoryUpdateWithWhereUniqueWithoutDebtInput | PaymentHistoryUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: PaymentHistoryUpdateManyWithWhereWithoutDebtInput | PaymentHistoryUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutDebtInput, WellBillDistributionUncheckedCreateWithoutDebtInput> | WellBillDistributionCreateWithoutDebtInput[] | WellBillDistributionUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutDebtInput | WellBillDistributionCreateOrConnectWithoutDebtInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutDebtInput | WellBillDistributionUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: WellBillDistributionCreateManyDebtInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutDebtInput | WellBillDistributionUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutDebtInput | WellBillDistributionUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<NotificationCreateWithoutDebtInput, NotificationUncheckedCreateWithoutDebtInput> | NotificationCreateWithoutDebtInput[] | NotificationUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDebtInput | NotificationCreateOrConnectWithoutDebtInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDebtInput | NotificationUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: NotificationCreateManyDebtInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDebtInput | NotificationUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDebtInput | NotificationUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesPurchasedInput = {
    create?: XOR<UserCreateWithoutInvoicesPurchasedInput, UserUncheckedCreateWithoutInvoicesPurchasedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesPurchasedInput
    connect?: UserWhereUniqueInput
  }

  export type DebtCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<DebtCreateWithoutInvoiceInput, DebtUncheckedCreateWithoutInvoiceInput> | DebtCreateWithoutInvoiceInput[] | DebtUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutInvoiceInput | DebtCreateOrConnectWithoutInvoiceInput[]
    createMany?: DebtCreateManyInvoiceInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type PurchaseCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PurchaseCreateWithoutInvoicesInput, PurchaseUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutInvoicesInput
    connect?: PurchaseWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<NotificationCreateWithoutInvoiceInput, NotificationUncheckedCreateWithoutInvoiceInput> | NotificationCreateWithoutInvoiceInput[] | NotificationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInvoiceInput | NotificationCreateOrConnectWithoutInvoiceInput[]
    createMany?: NotificationCreateManyInvoiceInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DebtUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<DebtCreateWithoutInvoiceInput, DebtUncheckedCreateWithoutInvoiceInput> | DebtCreateWithoutInvoiceInput[] | DebtUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutInvoiceInput | DebtCreateOrConnectWithoutInvoiceInput[]
    createMany?: DebtCreateManyInvoiceInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<NotificationCreateWithoutInvoiceInput, NotificationUncheckedCreateWithoutInvoiceInput> | NotificationCreateWithoutInvoiceInput[] | NotificationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInvoiceInput | NotificationCreateOrConnectWithoutInvoiceInput[]
    createMany?: NotificationCreateManyInvoiceInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutInvoicesPurchasedNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesPurchasedInput, UserUncheckedCreateWithoutInvoicesPurchasedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesPurchasedInput
    upsert?: UserUpsertWithoutInvoicesPurchasedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesPurchasedInput, UserUpdateWithoutInvoicesPurchasedInput>, UserUncheckedUpdateWithoutInvoicesPurchasedInput>
  }

  export type DebtUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<DebtCreateWithoutInvoiceInput, DebtUncheckedCreateWithoutInvoiceInput> | DebtCreateWithoutInvoiceInput[] | DebtUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutInvoiceInput | DebtCreateOrConnectWithoutInvoiceInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutInvoiceInput | DebtUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: DebtCreateManyInvoiceInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutInvoiceInput | DebtUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutInvoiceInput | DebtUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type PurchaseUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PurchaseCreateWithoutInvoicesInput, PurchaseUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutInvoicesInput
    upsert?: PurchaseUpsertWithoutInvoicesInput
    disconnect?: boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutInvoicesInput, PurchaseUpdateWithoutInvoicesInput>, PurchaseUncheckedUpdateWithoutInvoicesInput>
  }

  export type NotificationUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<NotificationCreateWithoutInvoiceInput, NotificationUncheckedCreateWithoutInvoiceInput> | NotificationCreateWithoutInvoiceInput[] | NotificationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInvoiceInput | NotificationCreateOrConnectWithoutInvoiceInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutInvoiceInput | NotificationUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: NotificationCreateManyInvoiceInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutInvoiceInput | NotificationUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutInvoiceInput | NotificationUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DebtUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<DebtCreateWithoutInvoiceInput, DebtUncheckedCreateWithoutInvoiceInput> | DebtCreateWithoutInvoiceInput[] | DebtUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutInvoiceInput | DebtCreateOrConnectWithoutInvoiceInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutInvoiceInput | DebtUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: DebtCreateManyInvoiceInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutInvoiceInput | DebtUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutInvoiceInput | DebtUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<NotificationCreateWithoutInvoiceInput, NotificationUncheckedCreateWithoutInvoiceInput> | NotificationCreateWithoutInvoiceInput[] | NotificationUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInvoiceInput | NotificationCreateOrConnectWithoutInvoiceInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutInvoiceInput | NotificationUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: NotificationCreateManyInvoiceInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutInvoiceInput | NotificationUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutInvoiceInput | NotificationUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutUsagesInput = {
    create?: XOR<InventoryCreateWithoutUsagesInput, InventoryUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutUsagesInput
    connect?: InventoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryUsagesInput = {
    create?: XOR<UserCreateWithoutInventoryUsagesInput, UserUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutInventoryUsagesInput = {
    create?: XOR<FieldCreateWithoutInventoryUsagesInput, FieldUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutInventoryUsagesInput
    connect?: FieldWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutInventoryUsagesInput = {
    create?: XOR<ProcessCreateWithoutInventoryUsagesInput, ProcessUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutInventoryUsagesInput
    connect?: ProcessWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutInventoryUsageInput = {
    create?: XOR<NotificationCreateWithoutInventoryUsageInput, NotificationUncheckedCreateWithoutInventoryUsageInput> | NotificationCreateWithoutInventoryUsageInput[] | NotificationUncheckedCreateWithoutInventoryUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryUsageInput | NotificationCreateOrConnectWithoutInventoryUsageInput[]
    createMany?: NotificationCreateManyInventoryUsageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutInventoryUsageInput = {
    create?: XOR<NotificationCreateWithoutInventoryUsageInput, NotificationUncheckedCreateWithoutInventoryUsageInput> | NotificationCreateWithoutInventoryUsageInput[] | NotificationUncheckedCreateWithoutInventoryUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryUsageInput | NotificationCreateOrConnectWithoutInventoryUsageInput[]
    createMany?: NotificationCreateManyInventoryUsageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumUsageTypeFieldUpdateOperationsInput = {
    set?: $Enums.UsageType
  }

  export type InventoryUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<InventoryCreateWithoutUsagesInput, InventoryUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutUsagesInput
    upsert?: InventoryUpsertWithoutUsagesInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutUsagesInput, InventoryUpdateWithoutUsagesInput>, InventoryUncheckedUpdateWithoutUsagesInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryUsagesNestedInput = {
    create?: XOR<UserCreateWithoutInventoryUsagesInput, UserUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUsagesInput
    upsert?: UserUpsertWithoutInventoryUsagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryUsagesInput, UserUpdateWithoutInventoryUsagesInput>, UserUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type FieldUpdateOneWithoutInventoryUsagesNestedInput = {
    create?: XOR<FieldCreateWithoutInventoryUsagesInput, FieldUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutInventoryUsagesInput
    upsert?: FieldUpsertWithoutInventoryUsagesInput
    disconnect?: boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutInventoryUsagesInput, FieldUpdateWithoutInventoryUsagesInput>, FieldUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type ProcessUpdateOneWithoutInventoryUsagesNestedInput = {
    create?: XOR<ProcessCreateWithoutInventoryUsagesInput, ProcessUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutInventoryUsagesInput
    upsert?: ProcessUpsertWithoutInventoryUsagesInput
    disconnect?: boolean
    delete?: ProcessWhereInput | boolean
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutInventoryUsagesInput, ProcessUpdateWithoutInventoryUsagesInput>, ProcessUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type NotificationUpdateManyWithoutInventoryUsageNestedInput = {
    create?: XOR<NotificationCreateWithoutInventoryUsageInput, NotificationUncheckedCreateWithoutInventoryUsageInput> | NotificationCreateWithoutInventoryUsageInput[] | NotificationUncheckedCreateWithoutInventoryUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryUsageInput | NotificationCreateOrConnectWithoutInventoryUsageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutInventoryUsageInput | NotificationUpsertWithWhereUniqueWithoutInventoryUsageInput[]
    createMany?: NotificationCreateManyInventoryUsageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutInventoryUsageInput | NotificationUpdateWithWhereUniqueWithoutInventoryUsageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutInventoryUsageInput | NotificationUpdateManyWithWhereWithoutInventoryUsageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutInventoryUsageNestedInput = {
    create?: XOR<NotificationCreateWithoutInventoryUsageInput, NotificationUncheckedCreateWithoutInventoryUsageInput> | NotificationCreateWithoutInventoryUsageInput[] | NotificationUncheckedCreateWithoutInventoryUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutInventoryUsageInput | NotificationCreateOrConnectWithoutInventoryUsageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutInventoryUsageInput | NotificationUpsertWithWhereUniqueWithoutInventoryUsageInput[]
    createMany?: NotificationCreateManyInventoryUsageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutInventoryUsageInput | NotificationUpdateWithWhereUniqueWithoutInventoryUsageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutInventoryUsageInput | NotificationUpdateManyWithWhereWithoutInventoryUsageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FieldCreateNestedOneWithoutProcessesInput = {
    create?: XOR<FieldCreateWithoutProcessesInput, FieldUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutProcessesInput
    connect?: FieldWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessesInput = {
    create?: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessesInput
    connect?: UserWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutProcessesInput = {
    create?: XOR<SeasonCreateWithoutProcessesInput, SeasonUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutProcessesInput
    connect?: SeasonWhereUniqueInput
  }

  export type InventoryUsageCreateNestedManyWithoutProcessInput = {
    create?: XOR<InventoryUsageCreateWithoutProcessInput, InventoryUsageUncheckedCreateWithoutProcessInput> | InventoryUsageCreateWithoutProcessInput[] | InventoryUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutProcessInput | InventoryUsageCreateOrConnectWithoutProcessInput[]
    createMany?: InventoryUsageCreateManyProcessInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type EquipmentUsageCreateNestedManyWithoutProcessInput = {
    create?: XOR<EquipmentUsageCreateWithoutProcessInput, EquipmentUsageUncheckedCreateWithoutProcessInput> | EquipmentUsageCreateWithoutProcessInput[] | EquipmentUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutProcessInput | EquipmentUsageCreateOrConnectWithoutProcessInput[]
    createMany?: EquipmentUsageCreateManyProcessInputEnvelope
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
  }

  export type ProcessCostCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessCostCreateWithoutProcessInput, ProcessCostUncheckedCreateWithoutProcessInput> | ProcessCostCreateWithoutProcessInput[] | ProcessCostUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutProcessInput | ProcessCostCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessCostCreateManyProcessInputEnvelope
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutProcessInput = {
    create?: XOR<NotificationCreateWithoutProcessInput, NotificationUncheckedCreateWithoutProcessInput> | NotificationCreateWithoutProcessInput[] | NotificationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessInput | NotificationCreateOrConnectWithoutProcessInput[]
    createMany?: NotificationCreateManyProcessInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InventoryUsageUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<InventoryUsageCreateWithoutProcessInput, InventoryUsageUncheckedCreateWithoutProcessInput> | InventoryUsageCreateWithoutProcessInput[] | InventoryUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutProcessInput | InventoryUsageCreateOrConnectWithoutProcessInput[]
    createMany?: InventoryUsageCreateManyProcessInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<EquipmentUsageCreateWithoutProcessInput, EquipmentUsageUncheckedCreateWithoutProcessInput> | EquipmentUsageCreateWithoutProcessInput[] | EquipmentUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutProcessInput | EquipmentUsageCreateOrConnectWithoutProcessInput[]
    createMany?: EquipmentUsageCreateManyProcessInputEnvelope
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
  }

  export type ProcessCostUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessCostCreateWithoutProcessInput, ProcessCostUncheckedCreateWithoutProcessInput> | ProcessCostCreateWithoutProcessInput[] | ProcessCostUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutProcessInput | ProcessCostCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessCostCreateManyProcessInputEnvelope
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<NotificationCreateWithoutProcessInput, NotificationUncheckedCreateWithoutProcessInput> | NotificationCreateWithoutProcessInput[] | NotificationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessInput | NotificationCreateOrConnectWithoutProcessInput[]
    createMany?: NotificationCreateManyProcessInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumProcessStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessStatus
  }

  export type FieldUpdateOneWithoutProcessesNestedInput = {
    create?: XOR<FieldCreateWithoutProcessesInput, FieldUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutProcessesInput
    upsert?: FieldUpsertWithoutProcessesInput
    disconnect?: boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutProcessesInput, FieldUpdateWithoutProcessesInput>, FieldUncheckedUpdateWithoutProcessesInput>
  }

  export type UserUpdateOneRequiredWithoutProcessesNestedInput = {
    create?: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessesInput
    upsert?: UserUpsertWithoutProcessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessesInput, UserUpdateWithoutProcessesInput>, UserUncheckedUpdateWithoutProcessesInput>
  }

  export type SeasonUpdateOneWithoutProcessesNestedInput = {
    create?: XOR<SeasonCreateWithoutProcessesInput, SeasonUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutProcessesInput
    upsert?: SeasonUpsertWithoutProcessesInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutProcessesInput, SeasonUpdateWithoutProcessesInput>, SeasonUncheckedUpdateWithoutProcessesInput>
  }

  export type InventoryUsageUpdateManyWithoutProcessNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutProcessInput, InventoryUsageUncheckedCreateWithoutProcessInput> | InventoryUsageCreateWithoutProcessInput[] | InventoryUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutProcessInput | InventoryUsageCreateOrConnectWithoutProcessInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutProcessInput | InventoryUsageUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: InventoryUsageCreateManyProcessInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutProcessInput | InventoryUsageUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutProcessInput | InventoryUsageUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type EquipmentUsageUpdateManyWithoutProcessNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutProcessInput, EquipmentUsageUncheckedCreateWithoutProcessInput> | EquipmentUsageCreateWithoutProcessInput[] | EquipmentUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutProcessInput | EquipmentUsageCreateOrConnectWithoutProcessInput[]
    upsert?: EquipmentUsageUpsertWithWhereUniqueWithoutProcessInput | EquipmentUsageUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: EquipmentUsageCreateManyProcessInputEnvelope
    set?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    disconnect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    delete?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    update?: EquipmentUsageUpdateWithWhereUniqueWithoutProcessInput | EquipmentUsageUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: EquipmentUsageUpdateManyWithWhereWithoutProcessInput | EquipmentUsageUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
  }

  export type ProcessCostUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessCostCreateWithoutProcessInput, ProcessCostUncheckedCreateWithoutProcessInput> | ProcessCostCreateWithoutProcessInput[] | ProcessCostUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutProcessInput | ProcessCostCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessCostUpsertWithWhereUniqueWithoutProcessInput | ProcessCostUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessCostCreateManyProcessInputEnvelope
    set?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    disconnect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    delete?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    update?: ProcessCostUpdateWithWhereUniqueWithoutProcessInput | ProcessCostUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessCostUpdateManyWithWhereWithoutProcessInput | ProcessCostUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessCostScalarWhereInput | ProcessCostScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutProcessNestedInput = {
    create?: XOR<NotificationCreateWithoutProcessInput, NotificationUncheckedCreateWithoutProcessInput> | NotificationCreateWithoutProcessInput[] | NotificationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessInput | NotificationCreateOrConnectWithoutProcessInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProcessInput | NotificationUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: NotificationCreateManyProcessInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProcessInput | NotificationUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProcessInput | NotificationUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutProcessInput, InventoryUsageUncheckedCreateWithoutProcessInput> | InventoryUsageCreateWithoutProcessInput[] | InventoryUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutProcessInput | InventoryUsageCreateOrConnectWithoutProcessInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutProcessInput | InventoryUsageUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: InventoryUsageCreateManyProcessInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutProcessInput | InventoryUsageUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutProcessInput | InventoryUsageUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutProcessInput, EquipmentUsageUncheckedCreateWithoutProcessInput> | EquipmentUsageCreateWithoutProcessInput[] | EquipmentUsageUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutProcessInput | EquipmentUsageCreateOrConnectWithoutProcessInput[]
    upsert?: EquipmentUsageUpsertWithWhereUniqueWithoutProcessInput | EquipmentUsageUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: EquipmentUsageCreateManyProcessInputEnvelope
    set?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    disconnect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    delete?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    update?: EquipmentUsageUpdateWithWhereUniqueWithoutProcessInput | EquipmentUsageUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: EquipmentUsageUpdateManyWithWhereWithoutProcessInput | EquipmentUsageUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
  }

  export type ProcessCostUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessCostCreateWithoutProcessInput, ProcessCostUncheckedCreateWithoutProcessInput> | ProcessCostCreateWithoutProcessInput[] | ProcessCostUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessCostCreateOrConnectWithoutProcessInput | ProcessCostCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessCostUpsertWithWhereUniqueWithoutProcessInput | ProcessCostUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessCostCreateManyProcessInputEnvelope
    set?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    disconnect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    delete?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    connect?: ProcessCostWhereUniqueInput | ProcessCostWhereUniqueInput[]
    update?: ProcessCostUpdateWithWhereUniqueWithoutProcessInput | ProcessCostUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessCostUpdateManyWithWhereWithoutProcessInput | ProcessCostUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessCostScalarWhereInput | ProcessCostScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<NotificationCreateWithoutProcessInput, NotificationUncheckedCreateWithoutProcessInput> | NotificationCreateWithoutProcessInput[] | NotificationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessInput | NotificationCreateOrConnectWithoutProcessInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProcessInput | NotificationUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: NotificationCreateManyProcessInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProcessInput | NotificationUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProcessInput | NotificationUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationCreatetargetRolesInput = {
    set: $Enums.Role[]
  }

  export type UserCreateNestedOneWithoutReceivedNotificationsInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProcessCreateWithoutNotificationsInput, ProcessUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutNotificationsInput
    connect?: ProcessWhereUniqueInput
  }

  export type DebtCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<DebtCreateWithoutNotificationsInput, DebtUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutNotificationsInput
    connect?: DebtWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PurchaseCreateWithoutNotificationsInput, PurchaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutNotificationsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<InventoryCreateWithoutNotificationsInput, InventoryUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutNotificationsInput
    connect?: InventoryWhereUniqueInput
  }

  export type IrrigationLogCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<IrrigationLogCreateWithoutNotificationsInput, IrrigationLogUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutNotificationsInput
    connect?: IrrigationLogWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<FieldCreateWithoutNotificationsInput, FieldUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutNotificationsInput
    connect?: FieldWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<SeasonCreateWithoutNotificationsInput, SeasonUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutNotificationsInput
    connect?: SeasonWhereUniqueInput
  }

  export type CropCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CropCreateWithoutNotificationsInput, CropUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CropCreateOrConnectWithoutNotificationsInput
    connect?: CropWhereUniqueInput
  }

  export type WellCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<WellCreateWithoutNotificationsInput, WellUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: WellCreateOrConnectWithoutNotificationsInput
    connect?: WellWhereUniqueInput
  }

  export type ProcessingLogCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProcessingLogCreateWithoutNotificationsInput, ProcessingLogUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProcessingLogCreateOrConnectWithoutNotificationsInput
    connect?: ProcessingLogWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<InvoiceCreateWithoutNotificationsInput, InvoiceUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutNotificationsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InventoryUsageCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<InventoryUsageCreateWithoutNotificationsInput, InventoryUsageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutNotificationsInput
    connect?: InventoryUsageWhereUniqueInput
  }

  export type InventoryTransactionCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<InventoryTransactionCreateWithoutNotificationsInput, InventoryTransactionUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutNotificationsInput
    connect?: InventoryTransactionWhereUniqueInput
  }

  export type PaymentHistoryCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PaymentHistoryCreateWithoutNotificationsInput, PaymentHistoryUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutNotificationsInput
    connect?: PaymentHistoryWhereUniqueInput
  }

  export type PurchaseContributorCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PurchaseContributorCreateWithoutNotificationsInput, PurchaseContributorUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutNotificationsInput
    connect?: PurchaseContributorWhereUniqueInput
  }

  export type PurchaseApprovalCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PurchaseApprovalCreateWithoutNotificationsInput, PurchaseApprovalUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutNotificationsInput
    connect?: PurchaseApprovalWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<EquipmentCreateWithoutNotificationsInput, EquipmentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutNotificationsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentUsageCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<EquipmentUsageCreateWithoutNotificationsInput, EquipmentUsageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutNotificationsInput
    connect?: EquipmentUsageWhereUniqueInput
  }

  export type ProcessCostCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProcessCostCreateWithoutNotificationsInput, ProcessCostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProcessCostCreateOrConnectWithoutNotificationsInput
    connect?: ProcessCostWhereUniqueInput
  }

  export type FieldExpenseCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<FieldExpenseCreateWithoutNotificationsInput, FieldExpenseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutNotificationsInput
    connect?: FieldExpenseWhereUniqueInput
  }

  export type FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutNotificationsInput, FieldOwnerExpenseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutNotificationsInput
    connect?: FieldOwnerExpenseWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type NotificationUpdatetargetRolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    upsert?: UserUpsertWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedNotificationsInput, UserUpdateWithoutReceivedNotificationsInput>, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserUpdateOneWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type ProcessUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ProcessCreateWithoutNotificationsInput, ProcessUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutNotificationsInput
    upsert?: ProcessUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: ProcessWhereInput | boolean
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutNotificationsInput, ProcessUpdateWithoutNotificationsInput>, ProcessUncheckedUpdateWithoutNotificationsInput>
  }

  export type DebtUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<DebtCreateWithoutNotificationsInput, DebtUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutNotificationsInput
    upsert?: DebtUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: DebtWhereInput | boolean
    connect?: DebtWhereUniqueInput
    update?: XOR<XOR<DebtUpdateToOneWithWhereWithoutNotificationsInput, DebtUpdateWithoutNotificationsInput>, DebtUncheckedUpdateWithoutNotificationsInput>
  }

  export type PurchaseUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PurchaseCreateWithoutNotificationsInput, PurchaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutNotificationsInput
    upsert?: PurchaseUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutNotificationsInput, PurchaseUpdateWithoutNotificationsInput>, PurchaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type InventoryUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<InventoryCreateWithoutNotificationsInput, InventoryUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutNotificationsInput
    upsert?: InventoryUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutNotificationsInput, InventoryUpdateWithoutNotificationsInput>, InventoryUncheckedUpdateWithoutNotificationsInput>
  }

  export type IrrigationLogUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutNotificationsInput, IrrigationLogUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutNotificationsInput
    upsert?: IrrigationLogUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: IrrigationLogWhereInput | boolean
    connect?: IrrigationLogWhereUniqueInput
    update?: XOR<XOR<IrrigationLogUpdateToOneWithWhereWithoutNotificationsInput, IrrigationLogUpdateWithoutNotificationsInput>, IrrigationLogUncheckedUpdateWithoutNotificationsInput>
  }

  export type FieldUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<FieldCreateWithoutNotificationsInput, FieldUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutNotificationsInput
    upsert?: FieldUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutNotificationsInput, FieldUpdateWithoutNotificationsInput>, FieldUncheckedUpdateWithoutNotificationsInput>
  }

  export type SeasonUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<SeasonCreateWithoutNotificationsInput, SeasonUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutNotificationsInput
    upsert?: SeasonUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutNotificationsInput, SeasonUpdateWithoutNotificationsInput>, SeasonUncheckedUpdateWithoutNotificationsInput>
  }

  export type CropUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CropCreateWithoutNotificationsInput, CropUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CropCreateOrConnectWithoutNotificationsInput
    upsert?: CropUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: CropWhereInput | boolean
    connect?: CropWhereUniqueInput
    update?: XOR<XOR<CropUpdateToOneWithWhereWithoutNotificationsInput, CropUpdateWithoutNotificationsInput>, CropUncheckedUpdateWithoutNotificationsInput>
  }

  export type WellUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<WellCreateWithoutNotificationsInput, WellUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: WellCreateOrConnectWithoutNotificationsInput
    upsert?: WellUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: WellWhereInput | boolean
    connect?: WellWhereUniqueInput
    update?: XOR<XOR<WellUpdateToOneWithWhereWithoutNotificationsInput, WellUpdateWithoutNotificationsInput>, WellUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProcessingLogUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ProcessingLogCreateWithoutNotificationsInput, ProcessingLogUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProcessingLogCreateOrConnectWithoutNotificationsInput
    upsert?: ProcessingLogUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: ProcessingLogWhereInput | boolean
    connect?: ProcessingLogWhereUniqueInput
    update?: XOR<XOR<ProcessingLogUpdateToOneWithWhereWithoutNotificationsInput, ProcessingLogUpdateWithoutNotificationsInput>, ProcessingLogUncheckedUpdateWithoutNotificationsInput>
  }

  export type InvoiceUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<InvoiceCreateWithoutNotificationsInput, InvoiceUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutNotificationsInput
    upsert?: InvoiceUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutNotificationsInput, InvoiceUpdateWithoutNotificationsInput>, InvoiceUncheckedUpdateWithoutNotificationsInput>
  }

  export type InventoryUsageUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutNotificationsInput, InventoryUsageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutNotificationsInput
    upsert?: InventoryUsageUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: InventoryUsageWhereInput | boolean
    connect?: InventoryUsageWhereUniqueInput
    update?: XOR<XOR<InventoryUsageUpdateToOneWithWhereWithoutNotificationsInput, InventoryUsageUpdateWithoutNotificationsInput>, InventoryUsageUncheckedUpdateWithoutNotificationsInput>
  }

  export type InventoryTransactionUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutNotificationsInput, InventoryTransactionUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutNotificationsInput
    upsert?: InventoryTransactionUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: InventoryTransactionWhereInput | boolean
    connect?: InventoryTransactionWhereUniqueInput
    update?: XOR<XOR<InventoryTransactionUpdateToOneWithWhereWithoutNotificationsInput, InventoryTransactionUpdateWithoutNotificationsInput>, InventoryTransactionUncheckedUpdateWithoutNotificationsInput>
  }

  export type PaymentHistoryUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PaymentHistoryCreateWithoutNotificationsInput, PaymentHistoryUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PaymentHistoryCreateOrConnectWithoutNotificationsInput
    upsert?: PaymentHistoryUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: PaymentHistoryWhereInput | boolean
    connect?: PaymentHistoryWhereUniqueInput
    update?: XOR<XOR<PaymentHistoryUpdateToOneWithWhereWithoutNotificationsInput, PaymentHistoryUpdateWithoutNotificationsInput>, PaymentHistoryUncheckedUpdateWithoutNotificationsInput>
  }

  export type PurchaseContributorUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PurchaseContributorCreateWithoutNotificationsInput, PurchaseContributorUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PurchaseContributorCreateOrConnectWithoutNotificationsInput
    upsert?: PurchaseContributorUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: PurchaseContributorWhereInput | boolean
    connect?: PurchaseContributorWhereUniqueInput
    update?: XOR<XOR<PurchaseContributorUpdateToOneWithWhereWithoutNotificationsInput, PurchaseContributorUpdateWithoutNotificationsInput>, PurchaseContributorUncheckedUpdateWithoutNotificationsInput>
  }

  export type PurchaseApprovalUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PurchaseApprovalCreateWithoutNotificationsInput, PurchaseApprovalUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PurchaseApprovalCreateOrConnectWithoutNotificationsInput
    upsert?: PurchaseApprovalUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: PurchaseApprovalWhereInput | boolean
    connect?: PurchaseApprovalWhereUniqueInput
    update?: XOR<XOR<PurchaseApprovalUpdateToOneWithWhereWithoutNotificationsInput, PurchaseApprovalUpdateWithoutNotificationsInput>, PurchaseApprovalUncheckedUpdateWithoutNotificationsInput>
  }

  export type EquipmentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<EquipmentCreateWithoutNotificationsInput, EquipmentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutNotificationsInput
    upsert?: EquipmentUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutNotificationsInput, EquipmentUpdateWithoutNotificationsInput>, EquipmentUncheckedUpdateWithoutNotificationsInput>
  }

  export type EquipmentUsageUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutNotificationsInput, EquipmentUsageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutNotificationsInput
    upsert?: EquipmentUsageUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: EquipmentUsageWhereInput | boolean
    connect?: EquipmentUsageWhereUniqueInput
    update?: XOR<XOR<EquipmentUsageUpdateToOneWithWhereWithoutNotificationsInput, EquipmentUsageUpdateWithoutNotificationsInput>, EquipmentUsageUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProcessCostUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ProcessCostCreateWithoutNotificationsInput, ProcessCostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProcessCostCreateOrConnectWithoutNotificationsInput
    upsert?: ProcessCostUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: ProcessCostWhereInput | boolean
    connect?: ProcessCostWhereUniqueInput
    update?: XOR<XOR<ProcessCostUpdateToOneWithWhereWithoutNotificationsInput, ProcessCostUpdateWithoutNotificationsInput>, ProcessCostUncheckedUpdateWithoutNotificationsInput>
  }

  export type FieldExpenseUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<FieldExpenseCreateWithoutNotificationsInput, FieldExpenseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FieldExpenseCreateOrConnectWithoutNotificationsInput
    upsert?: FieldExpenseUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: FieldExpenseWhereInput | boolean
    connect?: FieldExpenseWhereUniqueInput
    update?: XOR<XOR<FieldExpenseUpdateToOneWithWhereWithoutNotificationsInput, FieldExpenseUpdateWithoutNotificationsInput>, FieldExpenseUncheckedUpdateWithoutNotificationsInput>
  }

  export type FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutNotificationsInput, FieldOwnerExpenseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutNotificationsInput
    upsert?: FieldOwnerExpenseUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: FieldOwnerExpenseWhereInput | boolean
    connect?: FieldOwnerExpenseWhereUniqueInput
    update?: XOR<XOR<FieldOwnerExpenseUpdateToOneWithWhereWithoutNotificationsInput, FieldOwnerExpenseUpdateWithoutNotificationsInput>, FieldOwnerExpenseUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: UserUpsertWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferencesInput, UserUpdateWithoutNotificationPreferencesInput>, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type EquipmentOwnershipCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutEquipmentInput, EquipmentOwnershipUncheckedCreateWithoutEquipmentInput> | EquipmentOwnershipCreateWithoutEquipmentInput[] | EquipmentOwnershipUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutEquipmentInput | EquipmentOwnershipCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentOwnershipCreateManyEquipmentInputEnvelope
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
  }

  export type EquipmentCapabilityCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentCapabilityCreateWithoutEquipmentInput, EquipmentCapabilityUncheckedCreateWithoutEquipmentInput> | EquipmentCapabilityCreateWithoutEquipmentInput[] | EquipmentCapabilityUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCapabilityCreateOrConnectWithoutEquipmentInput | EquipmentCapabilityCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentCapabilityCreateManyEquipmentInputEnvelope
    connect?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
  }

  export type EquipmentUsageCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentUsageCreateWithoutEquipmentInput, EquipmentUsageUncheckedCreateWithoutEquipmentInput> | EquipmentUsageCreateWithoutEquipmentInput[] | EquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutEquipmentInput | EquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentUsageCreateManyEquipmentInputEnvelope
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<NotificationCreateWithoutEquipmentInput, NotificationUncheckedCreateWithoutEquipmentInput> | NotificationCreateWithoutEquipmentInput[] | NotificationUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentInput | NotificationCreateOrConnectWithoutEquipmentInput[]
    createMany?: NotificationCreateManyEquipmentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EquipmentOwnershipUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutEquipmentInput, EquipmentOwnershipUncheckedCreateWithoutEquipmentInput> | EquipmentOwnershipCreateWithoutEquipmentInput[] | EquipmentOwnershipUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutEquipmentInput | EquipmentOwnershipCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentOwnershipCreateManyEquipmentInputEnvelope
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
  }

  export type EquipmentCapabilityUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentCapabilityCreateWithoutEquipmentInput, EquipmentCapabilityUncheckedCreateWithoutEquipmentInput> | EquipmentCapabilityCreateWithoutEquipmentInput[] | EquipmentCapabilityUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCapabilityCreateOrConnectWithoutEquipmentInput | EquipmentCapabilityCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentCapabilityCreateManyEquipmentInputEnvelope
    connect?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
  }

  export type EquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentUsageCreateWithoutEquipmentInput, EquipmentUsageUncheckedCreateWithoutEquipmentInput> | EquipmentUsageCreateWithoutEquipmentInput[] | EquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutEquipmentInput | EquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentUsageCreateManyEquipmentInputEnvelope
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<NotificationCreateWithoutEquipmentInput, NotificationUncheckedCreateWithoutEquipmentInput> | NotificationCreateWithoutEquipmentInput[] | NotificationUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentInput | NotificationCreateOrConnectWithoutEquipmentInput[]
    createMany?: NotificationCreateManyEquipmentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumEquipmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentType
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type EquipmentOwnershipUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutEquipmentInput, EquipmentOwnershipUncheckedCreateWithoutEquipmentInput> | EquipmentOwnershipCreateWithoutEquipmentInput[] | EquipmentOwnershipUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutEquipmentInput | EquipmentOwnershipCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentOwnershipUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentOwnershipUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentOwnershipCreateManyEquipmentInputEnvelope
    set?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    disconnect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    delete?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    update?: EquipmentOwnershipUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentOwnershipUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentOwnershipUpdateManyWithWhereWithoutEquipmentInput | EquipmentOwnershipUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentOwnershipScalarWhereInput | EquipmentOwnershipScalarWhereInput[]
  }

  export type EquipmentCapabilityUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentCapabilityCreateWithoutEquipmentInput, EquipmentCapabilityUncheckedCreateWithoutEquipmentInput> | EquipmentCapabilityCreateWithoutEquipmentInput[] | EquipmentCapabilityUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCapabilityCreateOrConnectWithoutEquipmentInput | EquipmentCapabilityCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentCapabilityUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentCapabilityUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentCapabilityCreateManyEquipmentInputEnvelope
    set?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    disconnect?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    delete?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    connect?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    update?: EquipmentCapabilityUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentCapabilityUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentCapabilityUpdateManyWithWhereWithoutEquipmentInput | EquipmentCapabilityUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentCapabilityScalarWhereInput | EquipmentCapabilityScalarWhereInput[]
  }

  export type EquipmentUsageUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutEquipmentInput, EquipmentUsageUncheckedCreateWithoutEquipmentInput> | EquipmentUsageCreateWithoutEquipmentInput[] | EquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutEquipmentInput | EquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentUsageCreateManyEquipmentInputEnvelope
    set?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    disconnect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    delete?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    update?: EquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentUsageUpdateManyWithWhereWithoutEquipmentInput | EquipmentUsageUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<NotificationCreateWithoutEquipmentInput, NotificationUncheckedCreateWithoutEquipmentInput> | NotificationCreateWithoutEquipmentInput[] | NotificationUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentInput | NotificationCreateOrConnectWithoutEquipmentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEquipmentInput | NotificationUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: NotificationCreateManyEquipmentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEquipmentInput | NotificationUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEquipmentInput | NotificationUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentOwnershipCreateWithoutEquipmentInput, EquipmentOwnershipUncheckedCreateWithoutEquipmentInput> | EquipmentOwnershipCreateWithoutEquipmentInput[] | EquipmentOwnershipUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentOwnershipCreateOrConnectWithoutEquipmentInput | EquipmentOwnershipCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentOwnershipUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentOwnershipUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentOwnershipCreateManyEquipmentInputEnvelope
    set?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    disconnect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    delete?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    connect?: EquipmentOwnershipWhereUniqueInput | EquipmentOwnershipWhereUniqueInput[]
    update?: EquipmentOwnershipUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentOwnershipUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentOwnershipUpdateManyWithWhereWithoutEquipmentInput | EquipmentOwnershipUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentOwnershipScalarWhereInput | EquipmentOwnershipScalarWhereInput[]
  }

  export type EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentCapabilityCreateWithoutEquipmentInput, EquipmentCapabilityUncheckedCreateWithoutEquipmentInput> | EquipmentCapabilityCreateWithoutEquipmentInput[] | EquipmentCapabilityUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentCapabilityCreateOrConnectWithoutEquipmentInput | EquipmentCapabilityCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentCapabilityUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentCapabilityUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentCapabilityCreateManyEquipmentInputEnvelope
    set?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    disconnect?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    delete?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    connect?: EquipmentCapabilityWhereUniqueInput | EquipmentCapabilityWhereUniqueInput[]
    update?: EquipmentCapabilityUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentCapabilityUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentCapabilityUpdateManyWithWhereWithoutEquipmentInput | EquipmentCapabilityUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentCapabilityScalarWhereInput | EquipmentCapabilityScalarWhereInput[]
  }

  export type EquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentUsageCreateWithoutEquipmentInput, EquipmentUsageUncheckedCreateWithoutEquipmentInput> | EquipmentUsageCreateWithoutEquipmentInput[] | EquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentUsageCreateOrConnectWithoutEquipmentInput | EquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentUsageCreateManyEquipmentInputEnvelope
    set?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    disconnect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    delete?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    connect?: EquipmentUsageWhereUniqueInput | EquipmentUsageWhereUniqueInput[]
    update?: EquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentUsageUpdateManyWithWhereWithoutEquipmentInput | EquipmentUsageUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<NotificationCreateWithoutEquipmentInput, NotificationUncheckedCreateWithoutEquipmentInput> | NotificationCreateWithoutEquipmentInput[] | NotificationUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentInput | NotificationCreateOrConnectWithoutEquipmentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEquipmentInput | NotificationUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: NotificationCreateManyEquipmentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEquipmentInput | NotificationUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEquipmentInput | NotificationUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EquipmentCreateNestedOneWithoutOwnershipsInput = {
    create?: XOR<EquipmentCreateWithoutOwnershipsInput, EquipmentUncheckedCreateWithoutOwnershipsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutOwnershipsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEquipmentOwnershipsInput = {
    create?: XOR<UserCreateWithoutEquipmentOwnershipsInput, UserUncheckedCreateWithoutEquipmentOwnershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEquipmentOwnershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutOwnershipsNestedInput = {
    create?: XOR<EquipmentCreateWithoutOwnershipsInput, EquipmentUncheckedCreateWithoutOwnershipsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutOwnershipsInput
    upsert?: EquipmentUpsertWithoutOwnershipsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutOwnershipsInput, EquipmentUpdateWithoutOwnershipsInput>, EquipmentUncheckedUpdateWithoutOwnershipsInput>
  }

  export type UserUpdateOneRequiredWithoutEquipmentOwnershipsNestedInput = {
    create?: XOR<UserCreateWithoutEquipmentOwnershipsInput, UserUncheckedCreateWithoutEquipmentOwnershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEquipmentOwnershipsInput
    upsert?: UserUpsertWithoutEquipmentOwnershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEquipmentOwnershipsInput, UserUpdateWithoutEquipmentOwnershipsInput>, UserUncheckedUpdateWithoutEquipmentOwnershipsInput>
  }

  export type EquipmentCreateNestedOneWithoutCapabilitiesInput = {
    create?: XOR<EquipmentCreateWithoutCapabilitiesInput, EquipmentUncheckedCreateWithoutCapabilitiesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutCapabilitiesInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutCapabilitiesNestedInput = {
    create?: XOR<EquipmentCreateWithoutCapabilitiesInput, EquipmentUncheckedCreateWithoutCapabilitiesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutCapabilitiesInput
    upsert?: EquipmentUpsertWithoutCapabilitiesInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutCapabilitiesInput, EquipmentUpdateWithoutCapabilitiesInput>, EquipmentUncheckedUpdateWithoutCapabilitiesInput>
  }

  export type ProcessCreateNestedOneWithoutEquipmentUsagesInput = {
    create?: XOR<ProcessCreateWithoutEquipmentUsagesInput, ProcessUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutEquipmentUsagesInput
    connect?: ProcessWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutUsagesInput = {
    create?: XOR<EquipmentCreateWithoutUsagesInput, EquipmentUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsagesInput
    connect?: EquipmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEquipmentUsagesInput = {
    create?: XOR<UserCreateWithoutEquipmentUsagesInput, UserUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEquipmentUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutEquipmentUsageInput = {
    create?: XOR<NotificationCreateWithoutEquipmentUsageInput, NotificationUncheckedCreateWithoutEquipmentUsageInput> | NotificationCreateWithoutEquipmentUsageInput[] | NotificationUncheckedCreateWithoutEquipmentUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentUsageInput | NotificationCreateOrConnectWithoutEquipmentUsageInput[]
    createMany?: NotificationCreateManyEquipmentUsageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutEquipmentUsageInput = {
    create?: XOR<NotificationCreateWithoutEquipmentUsageInput, NotificationUncheckedCreateWithoutEquipmentUsageInput> | NotificationCreateWithoutEquipmentUsageInput[] | NotificationUncheckedCreateWithoutEquipmentUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentUsageInput | NotificationCreateOrConnectWithoutEquipmentUsageInput[]
    createMany?: NotificationCreateManyEquipmentUsageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProcessUpdateOneRequiredWithoutEquipmentUsagesNestedInput = {
    create?: XOR<ProcessCreateWithoutEquipmentUsagesInput, ProcessUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutEquipmentUsagesInput
    upsert?: ProcessUpsertWithoutEquipmentUsagesInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutEquipmentUsagesInput, ProcessUpdateWithoutEquipmentUsagesInput>, ProcessUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type EquipmentUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<EquipmentCreateWithoutUsagesInput, EquipmentUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsagesInput
    upsert?: EquipmentUpsertWithoutUsagesInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutUsagesInput, EquipmentUpdateWithoutUsagesInput>, EquipmentUncheckedUpdateWithoutUsagesInput>
  }

  export type UserUpdateOneRequiredWithoutEquipmentUsagesNestedInput = {
    create?: XOR<UserCreateWithoutEquipmentUsagesInput, UserUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEquipmentUsagesInput
    upsert?: UserUpsertWithoutEquipmentUsagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEquipmentUsagesInput, UserUpdateWithoutEquipmentUsagesInput>, UserUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type NotificationUpdateManyWithoutEquipmentUsageNestedInput = {
    create?: XOR<NotificationCreateWithoutEquipmentUsageInput, NotificationUncheckedCreateWithoutEquipmentUsageInput> | NotificationCreateWithoutEquipmentUsageInput[] | NotificationUncheckedCreateWithoutEquipmentUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentUsageInput | NotificationCreateOrConnectWithoutEquipmentUsageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEquipmentUsageInput | NotificationUpsertWithWhereUniqueWithoutEquipmentUsageInput[]
    createMany?: NotificationCreateManyEquipmentUsageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEquipmentUsageInput | NotificationUpdateWithWhereUniqueWithoutEquipmentUsageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEquipmentUsageInput | NotificationUpdateManyWithWhereWithoutEquipmentUsageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutEquipmentUsageNestedInput = {
    create?: XOR<NotificationCreateWithoutEquipmentUsageInput, NotificationUncheckedCreateWithoutEquipmentUsageInput> | NotificationCreateWithoutEquipmentUsageInput[] | NotificationUncheckedCreateWithoutEquipmentUsageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEquipmentUsageInput | NotificationCreateOrConnectWithoutEquipmentUsageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEquipmentUsageInput | NotificationUpsertWithWhereUniqueWithoutEquipmentUsageInput[]
    createMany?: NotificationCreateManyEquipmentUsageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEquipmentUsageInput | NotificationUpdateWithWhereUniqueWithoutEquipmentUsageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEquipmentUsageInput | NotificationUpdateManyWithWhereWithoutEquipmentUsageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProcessCreateNestedOneWithoutProcessCostsInput = {
    create?: XOR<ProcessCreateWithoutProcessCostsInput, ProcessUncheckedCreateWithoutProcessCostsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessCostsInput
    connect?: ProcessWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutProcessCostsInput = {
    create?: XOR<FieldCreateWithoutProcessCostsInput, FieldUncheckedCreateWithoutProcessCostsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutProcessCostsInput
    connect?: FieldWhereUniqueInput
  }

  export type FieldOwnerExpenseCreateNestedManyWithoutProcessCostInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutProcessCostInput, FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput> | FieldOwnerExpenseCreateWithoutProcessCostInput[] | FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput | FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput[]
    createMany?: FieldOwnerExpenseCreateManyProcessCostInputEnvelope
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutProcessCostInput = {
    create?: XOR<NotificationCreateWithoutProcessCostInput, NotificationUncheckedCreateWithoutProcessCostInput> | NotificationCreateWithoutProcessCostInput[] | NotificationUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessCostInput | NotificationCreateOrConnectWithoutProcessCostInput[]
    createMany?: NotificationCreateManyProcessCostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FieldOwnerExpenseUncheckedCreateNestedManyWithoutProcessCostInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutProcessCostInput, FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput> | FieldOwnerExpenseCreateWithoutProcessCostInput[] | FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput | FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput[]
    createMany?: FieldOwnerExpenseCreateManyProcessCostInputEnvelope
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutProcessCostInput = {
    create?: XOR<NotificationCreateWithoutProcessCostInput, NotificationUncheckedCreateWithoutProcessCostInput> | NotificationCreateWithoutProcessCostInput[] | NotificationUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessCostInput | NotificationCreateOrConnectWithoutProcessCostInput[]
    createMany?: NotificationCreateManyProcessCostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProcessUpdateOneRequiredWithoutProcessCostsNestedInput = {
    create?: XOR<ProcessCreateWithoutProcessCostsInput, ProcessUncheckedCreateWithoutProcessCostsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessCostsInput
    upsert?: ProcessUpsertWithoutProcessCostsInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutProcessCostsInput, ProcessUpdateWithoutProcessCostsInput>, ProcessUncheckedUpdateWithoutProcessCostsInput>
  }

  export type FieldUpdateOneRequiredWithoutProcessCostsNestedInput = {
    create?: XOR<FieldCreateWithoutProcessCostsInput, FieldUncheckedCreateWithoutProcessCostsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutProcessCostsInput
    upsert?: FieldUpsertWithoutProcessCostsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutProcessCostsInput, FieldUpdateWithoutProcessCostsInput>, FieldUncheckedUpdateWithoutProcessCostsInput>
  }

  export type FieldOwnerExpenseUpdateManyWithoutProcessCostNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutProcessCostInput, FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput> | FieldOwnerExpenseCreateWithoutProcessCostInput[] | FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput | FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput[]
    upsert?: FieldOwnerExpenseUpsertWithWhereUniqueWithoutProcessCostInput | FieldOwnerExpenseUpsertWithWhereUniqueWithoutProcessCostInput[]
    createMany?: FieldOwnerExpenseCreateManyProcessCostInputEnvelope
    set?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    disconnect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    delete?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    update?: FieldOwnerExpenseUpdateWithWhereUniqueWithoutProcessCostInput | FieldOwnerExpenseUpdateWithWhereUniqueWithoutProcessCostInput[]
    updateMany?: FieldOwnerExpenseUpdateManyWithWhereWithoutProcessCostInput | FieldOwnerExpenseUpdateManyWithWhereWithoutProcessCostInput[]
    deleteMany?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutProcessCostNestedInput = {
    create?: XOR<NotificationCreateWithoutProcessCostInput, NotificationUncheckedCreateWithoutProcessCostInput> | NotificationCreateWithoutProcessCostInput[] | NotificationUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessCostInput | NotificationCreateOrConnectWithoutProcessCostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProcessCostInput | NotificationUpsertWithWhereUniqueWithoutProcessCostInput[]
    createMany?: NotificationCreateManyProcessCostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProcessCostInput | NotificationUpdateWithWhereUniqueWithoutProcessCostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProcessCostInput | NotificationUpdateManyWithWhereWithoutProcessCostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostNestedInput = {
    create?: XOR<FieldOwnerExpenseCreateWithoutProcessCostInput, FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput> | FieldOwnerExpenseCreateWithoutProcessCostInput[] | FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput | FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput[]
    upsert?: FieldOwnerExpenseUpsertWithWhereUniqueWithoutProcessCostInput | FieldOwnerExpenseUpsertWithWhereUniqueWithoutProcessCostInput[]
    createMany?: FieldOwnerExpenseCreateManyProcessCostInputEnvelope
    set?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    disconnect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    delete?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    connect?: FieldOwnerExpenseWhereUniqueInput | FieldOwnerExpenseWhereUniqueInput[]
    update?: FieldOwnerExpenseUpdateWithWhereUniqueWithoutProcessCostInput | FieldOwnerExpenseUpdateWithWhereUniqueWithoutProcessCostInput[]
    updateMany?: FieldOwnerExpenseUpdateManyWithWhereWithoutProcessCostInput | FieldOwnerExpenseUpdateManyWithWhereWithoutProcessCostInput[]
    deleteMany?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutProcessCostNestedInput = {
    create?: XOR<NotificationCreateWithoutProcessCostInput, NotificationUncheckedCreateWithoutProcessCostInput> | NotificationCreateWithoutProcessCostInput[] | NotificationUncheckedCreateWithoutProcessCostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProcessCostInput | NotificationCreateOrConnectWithoutProcessCostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProcessCostInput | NotificationUpsertWithWhereUniqueWithoutProcessCostInput[]
    createMany?: NotificationCreateManyProcessCostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProcessCostInput | NotificationUpdateWithWhereUniqueWithoutProcessCostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProcessCostInput | NotificationUpdateManyWithWhereWithoutProcessCostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FieldCreateNestedOneWithoutFieldExpensesInput = {
    create?: XOR<FieldCreateWithoutFieldExpensesInput, FieldUncheckedCreateWithoutFieldExpensesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldExpensesInput
    connect?: FieldWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutFieldExpensesInput = {
    create?: XOR<SeasonCreateWithoutFieldExpensesInput, SeasonUncheckedCreateWithoutFieldExpensesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutFieldExpensesInput
    connect?: SeasonWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutFieldExpenseInput = {
    create?: XOR<NotificationCreateWithoutFieldExpenseInput, NotificationUncheckedCreateWithoutFieldExpenseInput> | NotificationCreateWithoutFieldExpenseInput[] | NotificationUncheckedCreateWithoutFieldExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldExpenseInput | NotificationCreateOrConnectWithoutFieldExpenseInput[]
    createMany?: NotificationCreateManyFieldExpenseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutFieldExpenseInput = {
    create?: XOR<NotificationCreateWithoutFieldExpenseInput, NotificationUncheckedCreateWithoutFieldExpenseInput> | NotificationCreateWithoutFieldExpenseInput[] | NotificationUncheckedCreateWithoutFieldExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldExpenseInput | NotificationCreateOrConnectWithoutFieldExpenseInput[]
    createMany?: NotificationCreateManyFieldExpenseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FieldUpdateOneRequiredWithoutFieldExpensesNestedInput = {
    create?: XOR<FieldCreateWithoutFieldExpensesInput, FieldUncheckedCreateWithoutFieldExpensesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFieldExpensesInput
    upsert?: FieldUpsertWithoutFieldExpensesInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFieldExpensesInput, FieldUpdateWithoutFieldExpensesInput>, FieldUncheckedUpdateWithoutFieldExpensesInput>
  }

  export type SeasonUpdateOneRequiredWithoutFieldExpensesNestedInput = {
    create?: XOR<SeasonCreateWithoutFieldExpensesInput, SeasonUncheckedCreateWithoutFieldExpensesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutFieldExpensesInput
    upsert?: SeasonUpsertWithoutFieldExpensesInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutFieldExpensesInput, SeasonUpdateWithoutFieldExpensesInput>, SeasonUncheckedUpdateWithoutFieldExpensesInput>
  }

  export type NotificationUpdateManyWithoutFieldExpenseNestedInput = {
    create?: XOR<NotificationCreateWithoutFieldExpenseInput, NotificationUncheckedCreateWithoutFieldExpenseInput> | NotificationCreateWithoutFieldExpenseInput[] | NotificationUncheckedCreateWithoutFieldExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldExpenseInput | NotificationCreateOrConnectWithoutFieldExpenseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutFieldExpenseInput | NotificationUpsertWithWhereUniqueWithoutFieldExpenseInput[]
    createMany?: NotificationCreateManyFieldExpenseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutFieldExpenseInput | NotificationUpdateWithWhereUniqueWithoutFieldExpenseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutFieldExpenseInput | NotificationUpdateManyWithWhereWithoutFieldExpenseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutFieldExpenseNestedInput = {
    create?: XOR<NotificationCreateWithoutFieldExpenseInput, NotificationUncheckedCreateWithoutFieldExpenseInput> | NotificationCreateWithoutFieldExpenseInput[] | NotificationUncheckedCreateWithoutFieldExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutFieldExpenseInput | NotificationCreateOrConnectWithoutFieldExpenseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutFieldExpenseInput | NotificationUpsertWithWhereUniqueWithoutFieldExpenseInput[]
    createMany?: NotificationCreateManyFieldExpenseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutFieldExpenseInput | NotificationUpdateWithWhereUniqueWithoutFieldExpenseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutFieldExpenseInput | NotificationUpdateManyWithWhereWithoutFieldExpenseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FieldOwnershipCreateNestedOneWithoutOwnerExpensesInput = {
    create?: XOR<FieldOwnershipCreateWithoutOwnerExpensesInput, FieldOwnershipUncheckedCreateWithoutOwnerExpensesInput>
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutOwnerExpensesInput
    connect?: FieldOwnershipWhereUniqueInput
  }

  export type ProcessCostCreateNestedOneWithoutOwnerExpensesInput = {
    create?: XOR<ProcessCostCreateWithoutOwnerExpensesInput, ProcessCostUncheckedCreateWithoutOwnerExpensesInput>
    connectOrCreate?: ProcessCostCreateOrConnectWithoutOwnerExpensesInput
    connect?: ProcessCostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFieldOwnerExpensesInput = {
    create?: XOR<UserCreateWithoutFieldOwnerExpensesInput, UserUncheckedCreateWithoutFieldOwnerExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFieldOwnerExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutOwnerExpenseInput = {
    create?: XOR<NotificationCreateWithoutOwnerExpenseInput, NotificationUncheckedCreateWithoutOwnerExpenseInput> | NotificationCreateWithoutOwnerExpenseInput[] | NotificationUncheckedCreateWithoutOwnerExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOwnerExpenseInput | NotificationCreateOrConnectWithoutOwnerExpenseInput[]
    createMany?: NotificationCreateManyOwnerExpenseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutOwnerExpenseInput = {
    create?: XOR<NotificationCreateWithoutOwnerExpenseInput, NotificationUncheckedCreateWithoutOwnerExpenseInput> | NotificationCreateWithoutOwnerExpenseInput[] | NotificationUncheckedCreateWithoutOwnerExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOwnerExpenseInput | NotificationCreateOrConnectWithoutOwnerExpenseInput[]
    createMany?: NotificationCreateManyOwnerExpenseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FieldOwnershipUpdateOneRequiredWithoutOwnerExpensesNestedInput = {
    create?: XOR<FieldOwnershipCreateWithoutOwnerExpensesInput, FieldOwnershipUncheckedCreateWithoutOwnerExpensesInput>
    connectOrCreate?: FieldOwnershipCreateOrConnectWithoutOwnerExpensesInput
    upsert?: FieldOwnershipUpsertWithoutOwnerExpensesInput
    connect?: FieldOwnershipWhereUniqueInput
    update?: XOR<XOR<FieldOwnershipUpdateToOneWithWhereWithoutOwnerExpensesInput, FieldOwnershipUpdateWithoutOwnerExpensesInput>, FieldOwnershipUncheckedUpdateWithoutOwnerExpensesInput>
  }

  export type ProcessCostUpdateOneRequiredWithoutOwnerExpensesNestedInput = {
    create?: XOR<ProcessCostCreateWithoutOwnerExpensesInput, ProcessCostUncheckedCreateWithoutOwnerExpensesInput>
    connectOrCreate?: ProcessCostCreateOrConnectWithoutOwnerExpensesInput
    upsert?: ProcessCostUpsertWithoutOwnerExpensesInput
    connect?: ProcessCostWhereUniqueInput
    update?: XOR<XOR<ProcessCostUpdateToOneWithWhereWithoutOwnerExpensesInput, ProcessCostUpdateWithoutOwnerExpensesInput>, ProcessCostUncheckedUpdateWithoutOwnerExpensesInput>
  }

  export type UserUpdateOneRequiredWithoutFieldOwnerExpensesNestedInput = {
    create?: XOR<UserCreateWithoutFieldOwnerExpensesInput, UserUncheckedCreateWithoutFieldOwnerExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFieldOwnerExpensesInput
    upsert?: UserUpsertWithoutFieldOwnerExpensesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFieldOwnerExpensesInput, UserUpdateWithoutFieldOwnerExpensesInput>, UserUncheckedUpdateWithoutFieldOwnerExpensesInput>
  }

  export type NotificationUpdateManyWithoutOwnerExpenseNestedInput = {
    create?: XOR<NotificationCreateWithoutOwnerExpenseInput, NotificationUncheckedCreateWithoutOwnerExpenseInput> | NotificationCreateWithoutOwnerExpenseInput[] | NotificationUncheckedCreateWithoutOwnerExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOwnerExpenseInput | NotificationCreateOrConnectWithoutOwnerExpenseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOwnerExpenseInput | NotificationUpsertWithWhereUniqueWithoutOwnerExpenseInput[]
    createMany?: NotificationCreateManyOwnerExpenseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOwnerExpenseInput | NotificationUpdateWithWhereUniqueWithoutOwnerExpenseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOwnerExpenseInput | NotificationUpdateManyWithWhereWithoutOwnerExpenseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutOwnerExpenseNestedInput = {
    create?: XOR<NotificationCreateWithoutOwnerExpenseInput, NotificationUncheckedCreateWithoutOwnerExpenseInput> | NotificationCreateWithoutOwnerExpenseInput[] | NotificationUncheckedCreateWithoutOwnerExpenseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOwnerExpenseInput | NotificationCreateOrConnectWithoutOwnerExpenseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOwnerExpenseInput | NotificationUpsertWithWhereUniqueWithoutOwnerExpenseInput[]
    createMany?: NotificationCreateManyOwnerExpenseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOwnerExpenseInput | NotificationUpdateWithWhereUniqueWithoutOwnerExpenseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOwnerExpenseInput | NotificationUpdateManyWithWhereWithoutOwnerExpenseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WellCreateNestedOneWithoutIrrigationLogsInput = {
    create?: XOR<WellCreateWithoutIrrigationLogsInput, WellUncheckedCreateWithoutIrrigationLogsInput>
    connectOrCreate?: WellCreateOrConnectWithoutIrrigationLogsInput
    connect?: WellWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIrrigationLogsInput = {
    create?: XOR<UserCreateWithoutIrrigationLogsInput, UserUncheckedCreateWithoutIrrigationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationLogsInput
    connect?: UserWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutIrrigationLogsInput = {
    create?: XOR<SeasonCreateWithoutIrrigationLogsInput, SeasonUncheckedCreateWithoutIrrigationLogsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutIrrigationLogsInput
    connect?: SeasonWhereUniqueInput
  }

  export type IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationFieldUsageCreateWithoutIrrigationLogInput[] | IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: IrrigationFieldUsageCreateManyIrrigationLogInputEnvelope
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
  }

  export type IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationInventoryUsageCreateWithoutIrrigationLogInput[] | IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: IrrigationInventoryUsageCreateManyIrrigationLogInputEnvelope
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
  }

  export type WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput> | WellBillingIrrigationUsageCreateWithoutIrrigationLogInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput | WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: WellBillingIrrigationUsageCreateManyIrrigationLogInputEnvelope
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
  }

  export type IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput> | IrrigationOwnerSummaryCreateWithoutIrrigationLogInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput | IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: IrrigationOwnerSummaryCreateManyIrrigationLogInputEnvelope
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutIrrigationInput = {
    create?: XOR<NotificationCreateWithoutIrrigationInput, NotificationUncheckedCreateWithoutIrrigationInput> | NotificationCreateWithoutIrrigationInput[] | NotificationUncheckedCreateWithoutIrrigationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutIrrigationInput | NotificationCreateOrConnectWithoutIrrigationInput[]
    createMany?: NotificationCreateManyIrrigationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationFieldUsageCreateWithoutIrrigationLogInput[] | IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: IrrigationFieldUsageCreateManyIrrigationLogInputEnvelope
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
  }

  export type IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationInventoryUsageCreateWithoutIrrigationLogInput[] | IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: IrrigationInventoryUsageCreateManyIrrigationLogInputEnvelope
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
  }

  export type WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput> | WellBillingIrrigationUsageCreateWithoutIrrigationLogInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput | WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: WellBillingIrrigationUsageCreateManyIrrigationLogInputEnvelope
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
  }

  export type IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput> | IrrigationOwnerSummaryCreateWithoutIrrigationLogInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput | IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput[]
    createMany?: IrrigationOwnerSummaryCreateManyIrrigationLogInputEnvelope
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutIrrigationInput = {
    create?: XOR<NotificationCreateWithoutIrrigationInput, NotificationUncheckedCreateWithoutIrrigationInput> | NotificationCreateWithoutIrrigationInput[] | NotificationUncheckedCreateWithoutIrrigationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutIrrigationInput | NotificationCreateOrConnectWithoutIrrigationInput[]
    createMany?: NotificationCreateManyIrrigationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WellUpdateOneRequiredWithoutIrrigationLogsNestedInput = {
    create?: XOR<WellCreateWithoutIrrigationLogsInput, WellUncheckedCreateWithoutIrrigationLogsInput>
    connectOrCreate?: WellCreateOrConnectWithoutIrrigationLogsInput
    upsert?: WellUpsertWithoutIrrigationLogsInput
    connect?: WellWhereUniqueInput
    update?: XOR<XOR<WellUpdateToOneWithWhereWithoutIrrigationLogsInput, WellUpdateWithoutIrrigationLogsInput>, WellUncheckedUpdateWithoutIrrigationLogsInput>
  }

  export type UserUpdateOneRequiredWithoutIrrigationLogsNestedInput = {
    create?: XOR<UserCreateWithoutIrrigationLogsInput, UserUncheckedCreateWithoutIrrigationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationLogsInput
    upsert?: UserUpsertWithoutIrrigationLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIrrigationLogsInput, UserUpdateWithoutIrrigationLogsInput>, UserUncheckedUpdateWithoutIrrigationLogsInput>
  }

  export type SeasonUpdateOneWithoutIrrigationLogsNestedInput = {
    create?: XOR<SeasonCreateWithoutIrrigationLogsInput, SeasonUncheckedCreateWithoutIrrigationLogsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutIrrigationLogsInput
    upsert?: SeasonUpsertWithoutIrrigationLogsInput
    disconnect?: boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutIrrigationLogsInput, SeasonUpdateWithoutIrrigationLogsInput>, SeasonUncheckedUpdateWithoutIrrigationLogsInput>
  }

  export type IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationFieldUsageCreateWithoutIrrigationLogInput[] | IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: IrrigationFieldUsageUpsertWithWhereUniqueWithoutIrrigationLogInput | IrrigationFieldUsageUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: IrrigationFieldUsageCreateManyIrrigationLogInputEnvelope
    set?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    disconnect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    delete?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    update?: IrrigationFieldUsageUpdateWithWhereUniqueWithoutIrrigationLogInput | IrrigationFieldUsageUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: IrrigationFieldUsageUpdateManyWithWhereWithoutIrrigationLogInput | IrrigationFieldUsageUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: IrrigationFieldUsageScalarWhereInput | IrrigationFieldUsageScalarWhereInput[]
  }

  export type IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationInventoryUsageCreateWithoutIrrigationLogInput[] | IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: IrrigationInventoryUsageUpsertWithWhereUniqueWithoutIrrigationLogInput | IrrigationInventoryUsageUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: IrrigationInventoryUsageCreateManyIrrigationLogInputEnvelope
    set?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    delete?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    update?: IrrigationInventoryUsageUpdateWithWhereUniqueWithoutIrrigationLogInput | IrrigationInventoryUsageUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: IrrigationInventoryUsageUpdateManyWithWhereWithoutIrrigationLogInput | IrrigationInventoryUsageUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: IrrigationInventoryUsageScalarWhereInput | IrrigationInventoryUsageScalarWhereInput[]
  }

  export type WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput> | WellBillingIrrigationUsageCreateWithoutIrrigationLogInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput | WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutIrrigationLogInput | WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: WellBillingIrrigationUsageCreateManyIrrigationLogInputEnvelope
    set?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    disconnect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    delete?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    update?: WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutIrrigationLogInput | WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: WellBillingIrrigationUsageUpdateManyWithWhereWithoutIrrigationLogInput | WellBillingIrrigationUsageUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: WellBillingIrrigationUsageScalarWhereInput | WellBillingIrrigationUsageScalarWhereInput[]
  }

  export type IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput> | IrrigationOwnerSummaryCreateWithoutIrrigationLogInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput | IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutIrrigationLogInput | IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: IrrigationOwnerSummaryCreateManyIrrigationLogInputEnvelope
    set?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    disconnect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    delete?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    update?: IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutIrrigationLogInput | IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: IrrigationOwnerSummaryUpdateManyWithWhereWithoutIrrigationLogInput | IrrigationOwnerSummaryUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: IrrigationOwnerSummaryScalarWhereInput | IrrigationOwnerSummaryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutIrrigationNestedInput = {
    create?: XOR<NotificationCreateWithoutIrrigationInput, NotificationUncheckedCreateWithoutIrrigationInput> | NotificationCreateWithoutIrrigationInput[] | NotificationUncheckedCreateWithoutIrrigationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutIrrigationInput | NotificationCreateOrConnectWithoutIrrigationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutIrrigationInput | NotificationUpsertWithWhereUniqueWithoutIrrigationInput[]
    createMany?: NotificationCreateManyIrrigationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutIrrigationInput | NotificationUpdateWithWhereUniqueWithoutIrrigationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutIrrigationInput | NotificationUpdateManyWithWhereWithoutIrrigationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationFieldUsageCreateWithoutIrrigationLogInput[] | IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: IrrigationFieldUsageUpsertWithWhereUniqueWithoutIrrigationLogInput | IrrigationFieldUsageUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: IrrigationFieldUsageCreateManyIrrigationLogInputEnvelope
    set?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    disconnect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    delete?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    connect?: IrrigationFieldUsageWhereUniqueInput | IrrigationFieldUsageWhereUniqueInput[]
    update?: IrrigationFieldUsageUpdateWithWhereUniqueWithoutIrrigationLogInput | IrrigationFieldUsageUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: IrrigationFieldUsageUpdateManyWithWhereWithoutIrrigationLogInput | IrrigationFieldUsageUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: IrrigationFieldUsageScalarWhereInput | IrrigationFieldUsageScalarWhereInput[]
  }

  export type IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput> | IrrigationInventoryUsageCreateWithoutIrrigationLogInput[] | IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput | IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: IrrigationInventoryUsageUpsertWithWhereUniqueWithoutIrrigationLogInput | IrrigationInventoryUsageUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: IrrigationInventoryUsageCreateManyIrrigationLogInputEnvelope
    set?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    delete?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    connect?: IrrigationInventoryUsageWhereUniqueInput | IrrigationInventoryUsageWhereUniqueInput[]
    update?: IrrigationInventoryUsageUpdateWithWhereUniqueWithoutIrrigationLogInput | IrrigationInventoryUsageUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: IrrigationInventoryUsageUpdateManyWithWhereWithoutIrrigationLogInput | IrrigationInventoryUsageUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: IrrigationInventoryUsageScalarWhereInput | IrrigationInventoryUsageScalarWhereInput[]
  }

  export type WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput> | WellBillingIrrigationUsageCreateWithoutIrrigationLogInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput | WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutIrrigationLogInput | WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: WellBillingIrrigationUsageCreateManyIrrigationLogInputEnvelope
    set?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    disconnect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    delete?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    update?: WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutIrrigationLogInput | WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: WellBillingIrrigationUsageUpdateManyWithWhereWithoutIrrigationLogInput | WellBillingIrrigationUsageUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: WellBillingIrrigationUsageScalarWhereInput | WellBillingIrrigationUsageScalarWhereInput[]
  }

  export type IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput = {
    create?: XOR<IrrigationOwnerSummaryCreateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput> | IrrigationOwnerSummaryCreateWithoutIrrigationLogInput[] | IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput[]
    connectOrCreate?: IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput | IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput[]
    upsert?: IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutIrrigationLogInput | IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutIrrigationLogInput[]
    createMany?: IrrigationOwnerSummaryCreateManyIrrigationLogInputEnvelope
    set?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    disconnect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    delete?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    connect?: IrrigationOwnerSummaryWhereUniqueInput | IrrigationOwnerSummaryWhereUniqueInput[]
    update?: IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutIrrigationLogInput | IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutIrrigationLogInput[]
    updateMany?: IrrigationOwnerSummaryUpdateManyWithWhereWithoutIrrigationLogInput | IrrigationOwnerSummaryUpdateManyWithWhereWithoutIrrigationLogInput[]
    deleteMany?: IrrigationOwnerSummaryScalarWhereInput | IrrigationOwnerSummaryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutIrrigationNestedInput = {
    create?: XOR<NotificationCreateWithoutIrrigationInput, NotificationUncheckedCreateWithoutIrrigationInput> | NotificationCreateWithoutIrrigationInput[] | NotificationUncheckedCreateWithoutIrrigationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutIrrigationInput | NotificationCreateOrConnectWithoutIrrigationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutIrrigationInput | NotificationUpsertWithWhereUniqueWithoutIrrigationInput[]
    createMany?: NotificationCreateManyIrrigationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutIrrigationInput | NotificationUpdateWithWhereUniqueWithoutIrrigationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutIrrigationInput | NotificationUpdateManyWithWhereWithoutIrrigationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IrrigationLogCreateNestedOneWithoutFieldUsagesInput = {
    create?: XOR<IrrigationLogCreateWithoutFieldUsagesInput, IrrigationLogUncheckedCreateWithoutFieldUsagesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutFieldUsagesInput
    connect?: IrrigationLogWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutIrrigationFieldUsagesInput = {
    create?: XOR<FieldCreateWithoutIrrigationFieldUsagesInput, FieldUncheckedCreateWithoutIrrigationFieldUsagesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutIrrigationFieldUsagesInput
    connect?: FieldWhereUniqueInput
  }

  export type IrrigationOwnerUsageCreateNestedManyWithoutIrrigationFieldUsageInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput> | IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput[] | IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput[]
    createMany?: IrrigationOwnerUsageCreateManyIrrigationFieldUsageInputEnvelope
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationOwnerUsageUncheckedCreateNestedManyWithoutIrrigationFieldUsageInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput> | IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput[] | IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput[]
    createMany?: IrrigationOwnerUsageCreateManyIrrigationFieldUsageInputEnvelope
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationLogUpdateOneRequiredWithoutFieldUsagesNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutFieldUsagesInput, IrrigationLogUncheckedCreateWithoutFieldUsagesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutFieldUsagesInput
    upsert?: IrrigationLogUpsertWithoutFieldUsagesInput
    connect?: IrrigationLogWhereUniqueInput
    update?: XOR<XOR<IrrigationLogUpdateToOneWithWhereWithoutFieldUsagesInput, IrrigationLogUpdateWithoutFieldUsagesInput>, IrrigationLogUncheckedUpdateWithoutFieldUsagesInput>
  }

  export type FieldUpdateOneRequiredWithoutIrrigationFieldUsagesNestedInput = {
    create?: XOR<FieldCreateWithoutIrrigationFieldUsagesInput, FieldUncheckedCreateWithoutIrrigationFieldUsagesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutIrrigationFieldUsagesInput
    upsert?: FieldUpsertWithoutIrrigationFieldUsagesInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutIrrigationFieldUsagesInput, FieldUpdateWithoutIrrigationFieldUsagesInput>, FieldUncheckedUpdateWithoutIrrigationFieldUsagesInput>
  }

  export type IrrigationOwnerUsageUpdateManyWithoutIrrigationFieldUsageNestedInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput> | IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput[] | IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput[]
    upsert?: IrrigationOwnerUsageUpsertWithWhereUniqueWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageUpsertWithWhereUniqueWithoutIrrigationFieldUsageInput[]
    createMany?: IrrigationOwnerUsageCreateManyIrrigationFieldUsageInputEnvelope
    set?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    delete?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    update?: IrrigationOwnerUsageUpdateWithWhereUniqueWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageUpdateWithWhereUniqueWithoutIrrigationFieldUsageInput[]
    updateMany?: IrrigationOwnerUsageUpdateManyWithWhereWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageUpdateManyWithWhereWithoutIrrigationFieldUsageInput[]
    deleteMany?: IrrigationOwnerUsageScalarWhereInput | IrrigationOwnerUsageScalarWhereInput[]
  }

  export type IrrigationOwnerUsageUncheckedUpdateManyWithoutIrrigationFieldUsageNestedInput = {
    create?: XOR<IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput> | IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput[] | IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput[]
    connectOrCreate?: IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput[]
    upsert?: IrrigationOwnerUsageUpsertWithWhereUniqueWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageUpsertWithWhereUniqueWithoutIrrigationFieldUsageInput[]
    createMany?: IrrigationOwnerUsageCreateManyIrrigationFieldUsageInputEnvelope
    set?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    delete?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    connect?: IrrigationOwnerUsageWhereUniqueInput | IrrigationOwnerUsageWhereUniqueInput[]
    update?: IrrigationOwnerUsageUpdateWithWhereUniqueWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageUpdateWithWhereUniqueWithoutIrrigationFieldUsageInput[]
    updateMany?: IrrigationOwnerUsageUpdateManyWithWhereWithoutIrrigationFieldUsageInput | IrrigationOwnerUsageUpdateManyWithWhereWithoutIrrigationFieldUsageInput[]
    deleteMany?: IrrigationOwnerUsageScalarWhereInput | IrrigationOwnerUsageScalarWhereInput[]
  }

  export type IrrigationFieldUsageCreateNestedOneWithoutOwnerUsagesInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutOwnerUsagesInput, IrrigationFieldUsageUncheckedCreateWithoutOwnerUsagesInput>
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutOwnerUsagesInput
    connect?: IrrigationFieldUsageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIrrigationOwnerUsagesInput = {
    create?: XOR<UserCreateWithoutIrrigationOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationOwnerUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationOwnerUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type IrrigationFieldUsageUpdateOneRequiredWithoutOwnerUsagesNestedInput = {
    create?: XOR<IrrigationFieldUsageCreateWithoutOwnerUsagesInput, IrrigationFieldUsageUncheckedCreateWithoutOwnerUsagesInput>
    connectOrCreate?: IrrigationFieldUsageCreateOrConnectWithoutOwnerUsagesInput
    upsert?: IrrigationFieldUsageUpsertWithoutOwnerUsagesInput
    connect?: IrrigationFieldUsageWhereUniqueInput
    update?: XOR<XOR<IrrigationFieldUsageUpdateToOneWithWhereWithoutOwnerUsagesInput, IrrigationFieldUsageUpdateWithoutOwnerUsagesInput>, IrrigationFieldUsageUncheckedUpdateWithoutOwnerUsagesInput>
  }

  export type UserUpdateOneRequiredWithoutIrrigationOwnerUsagesNestedInput = {
    create?: XOR<UserCreateWithoutIrrigationOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationOwnerUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationOwnerUsagesInput
    upsert?: UserUpsertWithoutIrrigationOwnerUsagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIrrigationOwnerUsagesInput, UserUpdateWithoutIrrigationOwnerUsagesInput>, UserUncheckedUpdateWithoutIrrigationOwnerUsagesInput>
  }

  export type IrrigationLogCreateNestedOneWithoutOwnerSummariesInput = {
    create?: XOR<IrrigationLogCreateWithoutOwnerSummariesInput, IrrigationLogUncheckedCreateWithoutOwnerSummariesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutOwnerSummariesInput
    connect?: IrrigationLogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIrrigationOwnerSummariesInput = {
    create?: XOR<UserCreateWithoutIrrigationOwnerSummariesInput, UserUncheckedCreateWithoutIrrigationOwnerSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationOwnerSummariesInput
    connect?: UserWhereUniqueInput
  }

  export type IrrigationLogUpdateOneRequiredWithoutOwnerSummariesNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutOwnerSummariesInput, IrrigationLogUncheckedCreateWithoutOwnerSummariesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutOwnerSummariesInput
    upsert?: IrrigationLogUpsertWithoutOwnerSummariesInput
    connect?: IrrigationLogWhereUniqueInput
    update?: XOR<XOR<IrrigationLogUpdateToOneWithWhereWithoutOwnerSummariesInput, IrrigationLogUpdateWithoutOwnerSummariesInput>, IrrigationLogUncheckedUpdateWithoutOwnerSummariesInput>
  }

  export type UserUpdateOneRequiredWithoutIrrigationOwnerSummariesNestedInput = {
    create?: XOR<UserCreateWithoutIrrigationOwnerSummariesInput, UserUncheckedCreateWithoutIrrigationOwnerSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationOwnerSummariesInput
    upsert?: UserUpsertWithoutIrrigationOwnerSummariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIrrigationOwnerSummariesInput, UserUpdateWithoutIrrigationOwnerSummariesInput>, UserUncheckedUpdateWithoutIrrigationOwnerSummariesInput>
  }

  export type IrrigationLogCreateNestedOneWithoutInventoryUsagesInput = {
    create?: XOR<IrrigationLogCreateWithoutInventoryUsagesInput, IrrigationLogUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutInventoryUsagesInput
    connect?: IrrigationLogWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutIrrigationInventoryUsagesInput = {
    create?: XOR<InventoryCreateWithoutIrrigationInventoryUsagesInput, InventoryUncheckedCreateWithoutIrrigationInventoryUsagesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutIrrigationInventoryUsagesInput
    connect?: InventoryWhereUniqueInput
  }

  export type IrrigationInventoryOwnerUsageCreateNestedManyWithoutIrrigationInventoryUsageInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput> | IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInputEnvelope
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutIrrigationInventoryUsageInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput> | IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInputEnvelope
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
  }

  export type IrrigationLogUpdateOneRequiredWithoutInventoryUsagesNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutInventoryUsagesInput, IrrigationLogUncheckedCreateWithoutInventoryUsagesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutInventoryUsagesInput
    upsert?: IrrigationLogUpsertWithoutInventoryUsagesInput
    connect?: IrrigationLogWhereUniqueInput
    update?: XOR<XOR<IrrigationLogUpdateToOneWithWhereWithoutInventoryUsagesInput, IrrigationLogUpdateWithoutInventoryUsagesInput>, IrrigationLogUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type InventoryUpdateOneRequiredWithoutIrrigationInventoryUsagesNestedInput = {
    create?: XOR<InventoryCreateWithoutIrrigationInventoryUsagesInput, InventoryUncheckedCreateWithoutIrrigationInventoryUsagesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutIrrigationInventoryUsagesInput
    upsert?: InventoryUpsertWithoutIrrigationInventoryUsagesInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutIrrigationInventoryUsagesInput, InventoryUpdateWithoutIrrigationInventoryUsagesInput>, InventoryUncheckedUpdateWithoutIrrigationInventoryUsagesInput>
  }

  export type IrrigationInventoryOwnerUsageUpdateManyWithoutIrrigationInventoryUsageNestedInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput> | IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput[]
    upsert?: IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutIrrigationInventoryUsageInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInputEnvelope
    set?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    delete?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    update?: IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutIrrigationInventoryUsageInput[]
    updateMany?: IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutIrrigationInventoryUsageInput[]
    deleteMany?: IrrigationInventoryOwnerUsageScalarWhereInput | IrrigationInventoryOwnerUsageScalarWhereInput[]
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutIrrigationInventoryUsageNestedInput = {
    create?: XOR<IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput> | IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput[] | IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput[]
    connectOrCreate?: IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput[]
    upsert?: IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutIrrigationInventoryUsageInput[]
    createMany?: IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInputEnvelope
    set?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    disconnect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    delete?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    connect?: IrrigationInventoryOwnerUsageWhereUniqueInput | IrrigationInventoryOwnerUsageWhereUniqueInput[]
    update?: IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutIrrigationInventoryUsageInput[]
    updateMany?: IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutIrrigationInventoryUsageInput[]
    deleteMany?: IrrigationInventoryOwnerUsageScalarWhereInput | IrrigationInventoryOwnerUsageScalarWhereInput[]
  }

  export type IrrigationInventoryUsageCreateNestedOneWithoutOwnerUsagesInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutOwnerUsagesInput, IrrigationInventoryUsageUncheckedCreateWithoutOwnerUsagesInput>
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutOwnerUsagesInput
    connect?: IrrigationInventoryUsageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIrrigationInventoryOwnerUsagesInput = {
    create?: XOR<UserCreateWithoutIrrigationInventoryOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationInventoryOwnerUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationInventoryOwnerUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type IrrigationInventoryUsageUpdateOneRequiredWithoutOwnerUsagesNestedInput = {
    create?: XOR<IrrigationInventoryUsageCreateWithoutOwnerUsagesInput, IrrigationInventoryUsageUncheckedCreateWithoutOwnerUsagesInput>
    connectOrCreate?: IrrigationInventoryUsageCreateOrConnectWithoutOwnerUsagesInput
    upsert?: IrrigationInventoryUsageUpsertWithoutOwnerUsagesInput
    connect?: IrrigationInventoryUsageWhereUniqueInput
    update?: XOR<XOR<IrrigationInventoryUsageUpdateToOneWithWhereWithoutOwnerUsagesInput, IrrigationInventoryUsageUpdateWithoutOwnerUsagesInput>, IrrigationInventoryUsageUncheckedUpdateWithoutOwnerUsagesInput>
  }

  export type UserUpdateOneRequiredWithoutIrrigationInventoryOwnerUsagesNestedInput = {
    create?: XOR<UserCreateWithoutIrrigationInventoryOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationInventoryOwnerUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIrrigationInventoryOwnerUsagesInput
    upsert?: UserUpsertWithoutIrrigationInventoryOwnerUsagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIrrigationInventoryOwnerUsagesInput, UserUpdateWithoutIrrigationInventoryOwnerUsagesInput>, UserUncheckedUpdateWithoutIrrigationInventoryOwnerUsagesInput>
  }

  export type WellCreateNestedOneWithoutWellBillingPeriodsInput = {
    create?: XOR<WellCreateWithoutWellBillingPeriodsInput, WellUncheckedCreateWithoutWellBillingPeriodsInput>
    connectOrCreate?: WellCreateOrConnectWithoutWellBillingPeriodsInput
    connect?: WellWhereUniqueInput
  }

  export type WellBillingIrrigationUsageCreateNestedManyWithoutWellBillingPeriodInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput> | WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput | WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput[]
    createMany?: WellBillingIrrigationUsageCreateManyWellBillingPeriodInputEnvelope
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
  }

  export type WellBillDistributionCreateNestedManyWithoutWellBillingPeriodInput = {
    create?: XOR<WellBillDistributionCreateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput> | WellBillDistributionCreateWithoutWellBillingPeriodInput[] | WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput | WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput[]
    createMany?: WellBillDistributionCreateManyWellBillingPeriodInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutWellBillingPeriodInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput> | WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput | WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput[]
    createMany?: WellBillingIrrigationUsageCreateManyWellBillingPeriodInputEnvelope
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
  }

  export type WellBillDistributionUncheckedCreateNestedManyWithoutWellBillingPeriodInput = {
    create?: XOR<WellBillDistributionCreateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput> | WellBillDistributionCreateWithoutWellBillingPeriodInput[] | WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput | WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput[]
    createMany?: WellBillDistributionCreateManyWellBillingPeriodInputEnvelope
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
  }

  export type WellUpdateOneRequiredWithoutWellBillingPeriodsNestedInput = {
    create?: XOR<WellCreateWithoutWellBillingPeriodsInput, WellUncheckedCreateWithoutWellBillingPeriodsInput>
    connectOrCreate?: WellCreateOrConnectWithoutWellBillingPeriodsInput
    upsert?: WellUpsertWithoutWellBillingPeriodsInput
    connect?: WellWhereUniqueInput
    update?: XOR<XOR<WellUpdateToOneWithWhereWithoutWellBillingPeriodsInput, WellUpdateWithoutWellBillingPeriodsInput>, WellUncheckedUpdateWithoutWellBillingPeriodsInput>
  }

  export type WellBillingIrrigationUsageUpdateManyWithoutWellBillingPeriodNestedInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput> | WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput | WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput[]
    upsert?: WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutWellBillingPeriodInput | WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutWellBillingPeriodInput[]
    createMany?: WellBillingIrrigationUsageCreateManyWellBillingPeriodInputEnvelope
    set?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    disconnect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    delete?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    update?: WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutWellBillingPeriodInput | WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutWellBillingPeriodInput[]
    updateMany?: WellBillingIrrigationUsageUpdateManyWithWhereWithoutWellBillingPeriodInput | WellBillingIrrigationUsageUpdateManyWithWhereWithoutWellBillingPeriodInput[]
    deleteMany?: WellBillingIrrigationUsageScalarWhereInput | WellBillingIrrigationUsageScalarWhereInput[]
  }

  export type WellBillDistributionUpdateManyWithoutWellBillingPeriodNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput> | WellBillDistributionCreateWithoutWellBillingPeriodInput[] | WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput | WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutWellBillingPeriodInput | WellBillDistributionUpsertWithWhereUniqueWithoutWellBillingPeriodInput[]
    createMany?: WellBillDistributionCreateManyWellBillingPeriodInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutWellBillingPeriodInput | WellBillDistributionUpdateWithWhereUniqueWithoutWellBillingPeriodInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutWellBillingPeriodInput | WellBillDistributionUpdateManyWithWhereWithoutWellBillingPeriodInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type WellBillingIrrigationUsageUncheckedUpdateManyWithoutWellBillingPeriodNestedInput = {
    create?: XOR<WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput> | WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput[] | WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput | WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput[]
    upsert?: WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutWellBillingPeriodInput | WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutWellBillingPeriodInput[]
    createMany?: WellBillingIrrigationUsageCreateManyWellBillingPeriodInputEnvelope
    set?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    disconnect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    delete?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    connect?: WellBillingIrrigationUsageWhereUniqueInput | WellBillingIrrigationUsageWhereUniqueInput[]
    update?: WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutWellBillingPeriodInput | WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutWellBillingPeriodInput[]
    updateMany?: WellBillingIrrigationUsageUpdateManyWithWhereWithoutWellBillingPeriodInput | WellBillingIrrigationUsageUpdateManyWithWhereWithoutWellBillingPeriodInput[]
    deleteMany?: WellBillingIrrigationUsageScalarWhereInput | WellBillingIrrigationUsageScalarWhereInput[]
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutWellBillingPeriodNestedInput = {
    create?: XOR<WellBillDistributionCreateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput> | WellBillDistributionCreateWithoutWellBillingPeriodInput[] | WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput[]
    connectOrCreate?: WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput | WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput[]
    upsert?: WellBillDistributionUpsertWithWhereUniqueWithoutWellBillingPeriodInput | WellBillDistributionUpsertWithWhereUniqueWithoutWellBillingPeriodInput[]
    createMany?: WellBillDistributionCreateManyWellBillingPeriodInputEnvelope
    set?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    disconnect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    delete?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    connect?: WellBillDistributionWhereUniqueInput | WellBillDistributionWhereUniqueInput[]
    update?: WellBillDistributionUpdateWithWhereUniqueWithoutWellBillingPeriodInput | WellBillDistributionUpdateWithWhereUniqueWithoutWellBillingPeriodInput[]
    updateMany?: WellBillDistributionUpdateManyWithWhereWithoutWellBillingPeriodInput | WellBillDistributionUpdateManyWithWhereWithoutWellBillingPeriodInput[]
    deleteMany?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
  }

  export type WellBillingPeriodCreateNestedOneWithoutIrrigationUsagesInput = {
    create?: XOR<WellBillingPeriodCreateWithoutIrrigationUsagesInput, WellBillingPeriodUncheckedCreateWithoutIrrigationUsagesInput>
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutIrrigationUsagesInput
    connect?: WellBillingPeriodWhereUniqueInput
  }

  export type IrrigationLogCreateNestedOneWithoutBillingUsagesInput = {
    create?: XOR<IrrigationLogCreateWithoutBillingUsagesInput, IrrigationLogUncheckedCreateWithoutBillingUsagesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutBillingUsagesInput
    connect?: IrrigationLogWhereUniqueInput
  }

  export type WellBillingPeriodUpdateOneRequiredWithoutIrrigationUsagesNestedInput = {
    create?: XOR<WellBillingPeriodCreateWithoutIrrigationUsagesInput, WellBillingPeriodUncheckedCreateWithoutIrrigationUsagesInput>
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutIrrigationUsagesInput
    upsert?: WellBillingPeriodUpsertWithoutIrrigationUsagesInput
    connect?: WellBillingPeriodWhereUniqueInput
    update?: XOR<XOR<WellBillingPeriodUpdateToOneWithWhereWithoutIrrigationUsagesInput, WellBillingPeriodUpdateWithoutIrrigationUsagesInput>, WellBillingPeriodUncheckedUpdateWithoutIrrigationUsagesInput>
  }

  export type IrrigationLogUpdateOneRequiredWithoutBillingUsagesNestedInput = {
    create?: XOR<IrrigationLogCreateWithoutBillingUsagesInput, IrrigationLogUncheckedCreateWithoutBillingUsagesInput>
    connectOrCreate?: IrrigationLogCreateOrConnectWithoutBillingUsagesInput
    upsert?: IrrigationLogUpsertWithoutBillingUsagesInput
    connect?: IrrigationLogWhereUniqueInput
    update?: XOR<XOR<IrrigationLogUpdateToOneWithWhereWithoutBillingUsagesInput, IrrigationLogUpdateWithoutBillingUsagesInput>, IrrigationLogUncheckedUpdateWithoutBillingUsagesInput>
  }

  export type WellBillingPeriodCreateNestedOneWithoutDistributionsInput = {
    create?: XOR<WellBillingPeriodCreateWithoutDistributionsInput, WellBillingPeriodUncheckedCreateWithoutDistributionsInput>
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutDistributionsInput
    connect?: WellBillingPeriodWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutWellBillDistributionsInput = {
    create?: XOR<FieldCreateWithoutWellBillDistributionsInput, FieldUncheckedCreateWithoutWellBillDistributionsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutWellBillDistributionsInput
    connect?: FieldWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWellBillDistributionsInput = {
    create?: XOR<UserCreateWithoutWellBillDistributionsInput, UserUncheckedCreateWithoutWellBillDistributionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellBillDistributionsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtCreateNestedOneWithoutWellBillDistributionsInput = {
    create?: XOR<DebtCreateWithoutWellBillDistributionsInput, DebtUncheckedCreateWithoutWellBillDistributionsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutWellBillDistributionsInput
    connect?: DebtWhereUniqueInput
  }

  export type WellBillingPeriodUpdateOneRequiredWithoutDistributionsNestedInput = {
    create?: XOR<WellBillingPeriodCreateWithoutDistributionsInput, WellBillingPeriodUncheckedCreateWithoutDistributionsInput>
    connectOrCreate?: WellBillingPeriodCreateOrConnectWithoutDistributionsInput
    upsert?: WellBillingPeriodUpsertWithoutDistributionsInput
    connect?: WellBillingPeriodWhereUniqueInput
    update?: XOR<XOR<WellBillingPeriodUpdateToOneWithWhereWithoutDistributionsInput, WellBillingPeriodUpdateWithoutDistributionsInput>, WellBillingPeriodUncheckedUpdateWithoutDistributionsInput>
  }

  export type FieldUpdateOneRequiredWithoutWellBillDistributionsNestedInput = {
    create?: XOR<FieldCreateWithoutWellBillDistributionsInput, FieldUncheckedCreateWithoutWellBillDistributionsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutWellBillDistributionsInput
    upsert?: FieldUpsertWithoutWellBillDistributionsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutWellBillDistributionsInput, FieldUpdateWithoutWellBillDistributionsInput>, FieldUncheckedUpdateWithoutWellBillDistributionsInput>
  }

  export type UserUpdateOneRequiredWithoutWellBillDistributionsNestedInput = {
    create?: XOR<UserCreateWithoutWellBillDistributionsInput, UserUncheckedCreateWithoutWellBillDistributionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellBillDistributionsInput
    upsert?: UserUpsertWithoutWellBillDistributionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWellBillDistributionsInput, UserUpdateWithoutWellBillDistributionsInput>, UserUncheckedUpdateWithoutWellBillDistributionsInput>
  }

  export type DebtUpdateOneWithoutWellBillDistributionsNestedInput = {
    create?: XOR<DebtCreateWithoutWellBillDistributionsInput, DebtUncheckedCreateWithoutWellBillDistributionsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutWellBillDistributionsInput
    upsert?: DebtUpsertWithoutWellBillDistributionsInput
    disconnect?: boolean
    delete?: DebtWhereInput | boolean
    connect?: DebtWhereUniqueInput
    update?: XOR<XOR<DebtUpdateToOneWithWhereWithoutWellBillDistributionsInput, DebtUpdateWithoutWellBillDistributionsInput>, DebtUncheckedUpdateWithoutWellBillDistributionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumCropStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CropStatus | EnumCropStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCropStatusFilter<$PrismaModel> | $Enums.CropStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumCropStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CropStatus | EnumCropStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CropStatus[] | ListEnumCropStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCropStatusWithAggregatesFilter<$PrismaModel> | $Enums.CropStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCropStatusFilter<$PrismaModel>
    _max?: NestedEnumCropStatusFilter<$PrismaModel>
  }

  export type NestedEnumProcessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeFilter<$PrismaModel> | $Enums.ProcessType
  }

  export type NestedEnumProcessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProcessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessTypeFilter<$PrismaModel>
    _max?: NestedEnumProcessTypeFilter<$PrismaModel>
  }

  export type NestedEnumInventoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryFilter<$PrismaModel> | $Enums.InventoryCategory
  }

  export type NestedEnumUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.Unit | EnumUnitFieldRefInput<$PrismaModel>
    in?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitFilter<$PrismaModel> | $Enums.Unit
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type NestedEnumInventoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InventoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumInventoryCategoryFilter<$PrismaModel>
  }

  export type NestedEnumUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Unit | EnumUnitFieldRefInput<$PrismaModel>
    in?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unit[] | ListEnumUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitWithAggregatesFilter<$PrismaModel> | $Enums.Unit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitFilter<$PrismaModel>
    _max?: NestedEnumUnitFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type NestedEnumProductCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProductCategoryFilter<$PrismaModel> | $Enums.ProductCategory
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCategory | EnumProductCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCategory[] | ListEnumProductCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProductCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProductCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductCategoryFilter<$PrismaModel>
    _max?: NestedEnumProductCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumDebtStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtStatus | EnumDebtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtStatusFilter<$PrismaModel> | $Enums.DebtStatus
  }

  export type NestedEnumDebtStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtStatus | EnumDebtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtStatus[] | ListEnumDebtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtStatusWithAggregatesFilter<$PrismaModel> | $Enums.DebtStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebtStatusFilter<$PrismaModel>
    _max?: NestedEnumDebtStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumUsageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeFilter<$PrismaModel> | $Enums.UsageType
  }

  export type NestedEnumUsageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeWithAggregatesFilter<$PrismaModel> | $Enums.UsageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsageTypeFilter<$PrismaModel>
    _max?: NestedEnumUsageTypeFilter<$PrismaModel>
  }

  export type NestedEnumProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusFilter<$PrismaModel> | $Enums.ProcessStatus
  }

  export type NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeFilter<$PrismaModel> | $Enums.EquipmentType
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedEnumEquipmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentType | EnumEquipmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentType[] | ListEnumEquipmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentTypeFilter<$PrismaModel>
    _max?: NestedEnumEquipmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type IrrigationLogCreateWithoutUserInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutUserInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutUserInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutUserInput, IrrigationLogUncheckedCreateWithoutUserInput>
  }

  export type IrrigationLogCreateManyUserInputEnvelope = {
    data: IrrigationLogCreateManyUserInput | IrrigationLogCreateManyUserInput[]
  }

  export type FieldOwnershipCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    field: FieldCreateNestedOneWithoutOwnersInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutFieldOwnershipInput
  }

  export type FieldOwnershipUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    fieldId: string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutFieldOwnershipInput
  }

  export type FieldOwnershipCreateOrConnectWithoutUserInput = {
    where: FieldOwnershipWhereUniqueInput
    create: XOR<FieldOwnershipCreateWithoutUserInput, FieldOwnershipUncheckedCreateWithoutUserInput>
  }

  export type FieldOwnershipCreateManyUserInputEnvelope = {
    data: FieldOwnershipCreateManyUserInput | FieldOwnershipCreateManyUserInput[]
  }

  export type FieldWorkerAssignmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutWorkerAssignmentsInput
  }

  export type FieldWorkerAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type FieldWorkerAssignmentCreateOrConnectWithoutUserInput = {
    where: FieldWorkerAssignmentWhereUniqueInput
    create: XOR<FieldWorkerAssignmentCreateWithoutUserInput, FieldWorkerAssignmentUncheckedCreateWithoutUserInput>
  }

  export type FieldWorkerAssignmentCreateManyUserInputEnvelope = {
    data: FieldWorkerAssignmentCreateManyUserInput | FieldWorkerAssignmentCreateManyUserInput[]
  }

  export type InventoryOwnershipCreateWithoutUserInput = {
    id?: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutOwnershipsInput
  }

  export type InventoryOwnershipUncheckedCreateWithoutUserInput = {
    id?: string
    inventoryId: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryOwnershipCreateOrConnectWithoutUserInput = {
    where: InventoryOwnershipWhereUniqueInput
    create: XOR<InventoryOwnershipCreateWithoutUserInput, InventoryOwnershipUncheckedCreateWithoutUserInput>
  }

  export type InventoryOwnershipCreateManyUserInputEnvelope = {
    data: InventoryOwnershipCreateManyUserInput | InventoryOwnershipCreateManyUserInput[]
  }

  export type DebtCreateWithoutCreditorInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutCreditorInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutCreditorInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutCreditorInput, DebtUncheckedCreateWithoutCreditorInput>
  }

  export type DebtCreateManyCreditorInputEnvelope = {
    data: DebtCreateManyCreditorInput | DebtCreateManyCreditorInput[]
  }

  export type DebtCreateWithoutDebtorInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutDebtorInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    invoiceId?: string | null
    purchaseId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutDebtorInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutDebtorInput, DebtUncheckedCreateWithoutDebtorInput>
  }

  export type DebtCreateManyDebtorInputEnvelope = {
    data: DebtCreateManyDebtorInput | DebtCreateManyDebtorInput[]
  }

  export type PurchaseContributorCreateWithoutUserInput = {
    id?: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutContributorsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutContributorInput
    notifications?: NotificationCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorUncheckedCreateWithoutUserInput = {
    id?: string
    purchaseId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutContributorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorCreateOrConnectWithoutUserInput = {
    where: PurchaseContributorWhereUniqueInput
    create: XOR<PurchaseContributorCreateWithoutUserInput, PurchaseContributorUncheckedCreateWithoutUserInput>
  }

  export type PurchaseContributorCreateManyUserInputEnvelope = {
    data: PurchaseContributorCreateManyUserInput | PurchaseContributorCreateManyUserInput[]
  }

  export type NotificationCreateWithoutReceiverInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutReceiverInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput>
  }

  export type NotificationCreateManyReceiverInputEnvelope = {
    data: NotificationCreateManyReceiverInput | NotificationCreateManyReceiverInput[]
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
  }

  export type InventoryUsageCreateWithoutUsedByInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutUsagesInput
    field?: FieldCreateNestedOneWithoutInventoryUsagesInput
    process?: ProcessCreateNestedOneWithoutInventoryUsagesInput
    notifications?: NotificationCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageUncheckedCreateWithoutUsedByInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageCreateOrConnectWithoutUsedByInput = {
    where: InventoryUsageWhereUniqueInput
    create: XOR<InventoryUsageCreateWithoutUsedByInput, InventoryUsageUncheckedCreateWithoutUsedByInput>
  }

  export type InventoryUsageCreateManyUsedByInputEnvelope = {
    data: InventoryUsageCreateManyUsedByInput | InventoryUsageCreateManyUsedByInput[]
  }

  export type ProcessCreateWithoutWorkerInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutWorkerInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutWorkerInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutWorkerInput, ProcessUncheckedCreateWithoutWorkerInput>
  }

  export type ProcessCreateManyWorkerInputEnvelope = {
    data: ProcessCreateManyWorkerInput | ProcessCreateManyWorkerInput[]
  }

  export type InvoiceCreateWithoutPurchaserInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    debts?: DebtCreateNestedManyWithoutInvoiceInput
    purchase?: PurchaseCreateNestedOneWithoutInvoicesInput
    notifications?: NotificationCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPurchaserInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseId?: string | null
    debts?: DebtUncheckedCreateNestedManyWithoutInvoiceInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPurchaserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPurchaserInput, InvoiceUncheckedCreateWithoutPurchaserInput>
  }

  export type InvoiceCreateManyPurchaserInputEnvelope = {
    data: InvoiceCreateManyPurchaserInput | InvoiceCreateManyPurchaserInput[]
  }

  export type PaymentHistoryCreateWithoutPayerInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debt?: DebtCreateNestedOneWithoutPaymentHistoryInput
    contributor?: PurchaseContributorCreateNestedOneWithoutPaymentHistoryInput
    receiver: UserCreateNestedOneWithoutPaymentsReceivedInput
    notifications?: NotificationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryUncheckedCreateWithoutPayerInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    receiverId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryCreateOrConnectWithoutPayerInput = {
    where: PaymentHistoryWhereUniqueInput
    create: XOR<PaymentHistoryCreateWithoutPayerInput, PaymentHistoryUncheckedCreateWithoutPayerInput>
  }

  export type PaymentHistoryCreateManyPayerInputEnvelope = {
    data: PaymentHistoryCreateManyPayerInput | PaymentHistoryCreateManyPayerInput[]
  }

  export type PaymentHistoryCreateWithoutReceiverInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debt?: DebtCreateNestedOneWithoutPaymentHistoryInput
    contributor?: PurchaseContributorCreateNestedOneWithoutPaymentHistoryInput
    payer: UserCreateNestedOneWithoutPaymentsMadeInput
    notifications?: NotificationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryUncheckedCreateWithoutReceiverInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    payerId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryCreateOrConnectWithoutReceiverInput = {
    where: PaymentHistoryWhereUniqueInput
    create: XOR<PaymentHistoryCreateWithoutReceiverInput, PaymentHistoryUncheckedCreateWithoutReceiverInput>
  }

  export type PaymentHistoryCreateManyReceiverInputEnvelope = {
    data: PaymentHistoryCreateManyReceiverInput | PaymentHistoryCreateManyReceiverInput[]
  }

  export type InventoryTransactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    season?: SeasonCreateNestedOneWithoutInventoryTransactionsInput
    inventory: InventoryCreateNestedOneWithoutInventoryTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutInventoryTransactionsInput
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    purchaseId?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionCreateOrConnectWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput>
  }

  export type InventoryTransactionCreateManyUserInputEnvelope = {
    data: InventoryTransactionCreateManyUserInput | InventoryTransactionCreateManyUserInput[]
  }

  export type SeasonCreateWithoutCreatorInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutCreatorInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutCreatorInput, SeasonUncheckedCreateWithoutCreatorInput>
  }

  export type SeasonCreateManyCreatorInputEnvelope = {
    data: SeasonCreateManyCreatorInput | SeasonCreateManyCreatorInput[]
  }

  export type PurchaseApprovalCreateWithoutApproverInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutApprovalsInput
    notifications?: NotificationCreateNestedManyWithoutApprovalInput
  }

  export type PurchaseApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    purchaseId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type PurchaseApprovalCreateOrConnectWithoutApproverInput = {
    where: PurchaseApprovalWhereUniqueInput
    create: XOR<PurchaseApprovalCreateWithoutApproverInput, PurchaseApprovalUncheckedCreateWithoutApproverInput>
  }

  export type PurchaseApprovalCreateManyApproverInputEnvelope = {
    data: PurchaseApprovalCreateManyApproverInput | PurchaseApprovalCreateManyApproverInput[]
  }

  export type EquipmentOwnershipCreateWithoutUserInput = {
    id?: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment: EquipmentCreateNestedOneWithoutOwnershipsInput
  }

  export type EquipmentOwnershipUncheckedCreateWithoutUserInput = {
    id?: string
    equipmentId: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentOwnershipCreateOrConnectWithoutUserInput = {
    where: EquipmentOwnershipWhereUniqueInput
    create: XOR<EquipmentOwnershipCreateWithoutUserInput, EquipmentOwnershipUncheckedCreateWithoutUserInput>
  }

  export type EquipmentOwnershipCreateManyUserInputEnvelope = {
    data: EquipmentOwnershipCreateManyUserInput | EquipmentOwnershipCreateManyUserInput[]
  }

  export type EquipmentUsageCreateWithoutUserInput = {
    id?: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutEquipmentUsagesInput
    equipment: EquipmentCreateNestedOneWithoutUsagesInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageUncheckedCreateWithoutUserInput = {
    id?: string
    processId: string
    equipmentId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageCreateOrConnectWithoutUserInput = {
    where: EquipmentUsageWhereUniqueInput
    create: XOR<EquipmentUsageCreateWithoutUserInput, EquipmentUsageUncheckedCreateWithoutUserInput>
  }

  export type EquipmentUsageCreateManyUserInputEnvelope = {
    data: EquipmentUsageCreateManyUserInput | EquipmentUsageCreateManyUserInput[]
  }

  export type FieldOwnerExpenseCreateWithoutUserInput = {
    id?: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldOwnership: FieldOwnershipCreateNestedOneWithoutOwnerExpensesInput
    processCost: ProcessCostCreateNestedOneWithoutOwnerExpensesInput
    notifications?: NotificationCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseUncheckedCreateWithoutUserInput = {
    id?: string
    fieldOwnershipId: string
    processCostId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseCreateOrConnectWithoutUserInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    create: XOR<FieldOwnerExpenseCreateWithoutUserInput, FieldOwnerExpenseUncheckedCreateWithoutUserInput>
  }

  export type FieldOwnerExpenseCreateManyUserInputEnvelope = {
    data: FieldOwnerExpenseCreateManyUserInput | FieldOwnerExpenseCreateManyUserInput[]
  }

  export type WorkerWellAssignmentCreateWithoutWorkerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutWorkerAssignmentsInput
  }

  export type WorkerWellAssignmentUncheckedCreateWithoutWorkerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    wellId: string
  }

  export type WorkerWellAssignmentCreateOrConnectWithoutWorkerInput = {
    where: WorkerWellAssignmentWhereUniqueInput
    create: XOR<WorkerWellAssignmentCreateWithoutWorkerInput, WorkerWellAssignmentUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerWellAssignmentCreateManyWorkerInputEnvelope = {
    data: WorkerWellAssignmentCreateManyWorkerInput | WorkerWellAssignmentCreateManyWorkerInput[]
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    inAppNotifications?: boolean
    dailyDigest?: boolean
    notifyOnDebtReminders?: boolean
    notifyOnPayments?: boolean
    notifyOnProcessUpdates?: boolean
    notifyOnInventoryAlerts?: boolean
    notifyOnApprovals?: boolean
    notifyOnIrrigation?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IrrigationOwnerUsageCreateWithoutOwnerInput = {
    id?: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
    irrigationFieldUsage: IrrigationFieldUsageCreateNestedOneWithoutOwnerUsagesInput
  }

  export type IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput = {
    id?: string
    irrigationFieldUsageId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerUsageCreateOrConnectWithoutOwnerInput = {
    where: IrrigationOwnerUsageWhereUniqueInput
    create: XOR<IrrigationOwnerUsageCreateWithoutOwnerInput, IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput>
  }

  export type IrrigationOwnerUsageCreateManyOwnerInputEnvelope = {
    data: IrrigationOwnerUsageCreateManyOwnerInput | IrrigationOwnerUsageCreateManyOwnerInput[]
  }

  export type IrrigationInventoryOwnerUsageCreateWithoutOwnerInput = {
    id?: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
    irrigationInventoryUsage: IrrigationInventoryUsageCreateNestedOneWithoutOwnerUsagesInput
  }

  export type IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput = {
    id?: string
    irrigationInventoryUsageId: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryOwnerUsageCreateOrConnectWithoutOwnerInput = {
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    create: XOR<IrrigationInventoryOwnerUsageCreateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput>
  }

  export type IrrigationInventoryOwnerUsageCreateManyOwnerInputEnvelope = {
    data: IrrigationInventoryOwnerUsageCreateManyOwnerInput | IrrigationInventoryOwnerUsageCreateManyOwnerInput[]
  }

  export type IrrigationOwnerSummaryCreateWithoutOwnerInput = {
    id?: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutOwnerSummariesInput
  }

  export type IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput = {
    id?: string
    irrigationLogId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerSummaryCreateOrConnectWithoutOwnerInput = {
    where: IrrigationOwnerSummaryWhereUniqueInput
    create: XOR<IrrigationOwnerSummaryCreateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput>
  }

  export type IrrigationOwnerSummaryCreateManyOwnerInputEnvelope = {
    data: IrrigationOwnerSummaryCreateManyOwnerInput | IrrigationOwnerSummaryCreateManyOwnerInput[]
  }

  export type WellBillDistributionCreateWithoutOwnerInput = {
    id?: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    wellBillingPeriod: WellBillingPeriodCreateNestedOneWithoutDistributionsInput
    field: FieldCreateNestedOneWithoutWellBillDistributionsInput
    debt?: DebtCreateNestedOneWithoutWellBillDistributionsInput
  }

  export type WellBillDistributionUncheckedCreateWithoutOwnerInput = {
    id?: string
    wellBillingPeriodId: string
    fieldId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type WellBillDistributionCreateOrConnectWithoutOwnerInput = {
    where: WellBillDistributionWhereUniqueInput
    create: XOR<WellBillDistributionCreateWithoutOwnerInput, WellBillDistributionUncheckedCreateWithoutOwnerInput>
  }

  export type WellBillDistributionCreateManyOwnerInputEnvelope = {
    data: WellBillDistributionCreateManyOwnerInput | WellBillDistributionCreateManyOwnerInput[]
  }

  export type IrrigationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: IrrigationLogWhereUniqueInput
    update: XOR<IrrigationLogUpdateWithoutUserInput, IrrigationLogUncheckedUpdateWithoutUserInput>
    create: XOR<IrrigationLogCreateWithoutUserInput, IrrigationLogUncheckedCreateWithoutUserInput>
  }

  export type IrrigationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: IrrigationLogWhereUniqueInput
    data: XOR<IrrigationLogUpdateWithoutUserInput, IrrigationLogUncheckedUpdateWithoutUserInput>
  }

  export type IrrigationLogUpdateManyWithWhereWithoutUserInput = {
    where: IrrigationLogScalarWhereInput
    data: XOR<IrrigationLogUpdateManyMutationInput, IrrigationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type IrrigationLogScalarWhereInput = {
    AND?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
    OR?: IrrigationLogScalarWhereInput[]
    NOT?: IrrigationLogScalarWhereInput | IrrigationLogScalarWhereInput[]
    id?: StringFilter<"IrrigationLog"> | string
    startDateTime?: DateTimeFilter<"IrrigationLog"> | Date | string
    duration?: FloatFilter<"IrrigationLog"> | number
    wellId?: StringFilter<"IrrigationLog"> | string
    notes?: StringNullableFilter<"IrrigationLog"> | string | null
    status?: StringFilter<"IrrigationLog"> | string
    createdBy?: StringFilter<"IrrigationLog"> | string
    createdAt?: DateTimeFilter<"IrrigationLog"> | Date | string
    updatedAt?: DateTimeFilter<"IrrigationLog"> | Date | string
    seasonId?: StringNullableFilter<"IrrigationLog"> | string | null
  }

  export type FieldOwnershipUpsertWithWhereUniqueWithoutUserInput = {
    where: FieldOwnershipWhereUniqueInput
    update: XOR<FieldOwnershipUpdateWithoutUserInput, FieldOwnershipUncheckedUpdateWithoutUserInput>
    create: XOR<FieldOwnershipCreateWithoutUserInput, FieldOwnershipUncheckedCreateWithoutUserInput>
  }

  export type FieldOwnershipUpdateWithWhereUniqueWithoutUserInput = {
    where: FieldOwnershipWhereUniqueInput
    data: XOR<FieldOwnershipUpdateWithoutUserInput, FieldOwnershipUncheckedUpdateWithoutUserInput>
  }

  export type FieldOwnershipUpdateManyWithWhereWithoutUserInput = {
    where: FieldOwnershipScalarWhereInput
    data: XOR<FieldOwnershipUpdateManyMutationInput, FieldOwnershipUncheckedUpdateManyWithoutUserInput>
  }

  export type FieldOwnershipScalarWhereInput = {
    AND?: FieldOwnershipScalarWhereInput | FieldOwnershipScalarWhereInput[]
    OR?: FieldOwnershipScalarWhereInput[]
    NOT?: FieldOwnershipScalarWhereInput | FieldOwnershipScalarWhereInput[]
    id?: StringFilter<"FieldOwnership"> | string
    createdAt?: DateTimeFilter<"FieldOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"FieldOwnership"> | Date | string
    percentage?: FloatFilter<"FieldOwnership"> | number
    fieldId?: StringFilter<"FieldOwnership"> | string
    userId?: StringFilter<"FieldOwnership"> | string
  }

  export type FieldWorkerAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: FieldWorkerAssignmentWhereUniqueInput
    update: XOR<FieldWorkerAssignmentUpdateWithoutUserInput, FieldWorkerAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<FieldWorkerAssignmentCreateWithoutUserInput, FieldWorkerAssignmentUncheckedCreateWithoutUserInput>
  }

  export type FieldWorkerAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: FieldWorkerAssignmentWhereUniqueInput
    data: XOR<FieldWorkerAssignmentUpdateWithoutUserInput, FieldWorkerAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type FieldWorkerAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: FieldWorkerAssignmentScalarWhereInput
    data: XOR<FieldWorkerAssignmentUpdateManyMutationInput, FieldWorkerAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type FieldWorkerAssignmentScalarWhereInput = {
    AND?: FieldWorkerAssignmentScalarWhereInput | FieldWorkerAssignmentScalarWhereInput[]
    OR?: FieldWorkerAssignmentScalarWhereInput[]
    NOT?: FieldWorkerAssignmentScalarWhereInput | FieldWorkerAssignmentScalarWhereInput[]
    id?: StringFilter<"FieldWorkerAssignment"> | string
    createdAt?: DateTimeFilter<"FieldWorkerAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"FieldWorkerAssignment"> | Date | string
    fieldId?: StringFilter<"FieldWorkerAssignment"> | string
    userId?: StringFilter<"FieldWorkerAssignment"> | string
  }

  export type InventoryOwnershipUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryOwnershipWhereUniqueInput
    update: XOR<InventoryOwnershipUpdateWithoutUserInput, InventoryOwnershipUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryOwnershipCreateWithoutUserInput, InventoryOwnershipUncheckedCreateWithoutUserInput>
  }

  export type InventoryOwnershipUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryOwnershipWhereUniqueInput
    data: XOR<InventoryOwnershipUpdateWithoutUserInput, InventoryOwnershipUncheckedUpdateWithoutUserInput>
  }

  export type InventoryOwnershipUpdateManyWithWhereWithoutUserInput = {
    where: InventoryOwnershipScalarWhereInput
    data: XOR<InventoryOwnershipUpdateManyMutationInput, InventoryOwnershipUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryOwnershipScalarWhereInput = {
    AND?: InventoryOwnershipScalarWhereInput | InventoryOwnershipScalarWhereInput[]
    OR?: InventoryOwnershipScalarWhereInput[]
    NOT?: InventoryOwnershipScalarWhereInput | InventoryOwnershipScalarWhereInput[]
    id?: StringFilter<"InventoryOwnership"> | string
    inventoryId?: StringFilter<"InventoryOwnership"> | string
    userId?: StringFilter<"InventoryOwnership"> | string
    shareQuantity?: FloatFilter<"InventoryOwnership"> | number
    createdAt?: DateTimeFilter<"InventoryOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryOwnership"> | Date | string
  }

  export type DebtUpsertWithWhereUniqueWithoutCreditorInput = {
    where: DebtWhereUniqueInput
    update: XOR<DebtUpdateWithoutCreditorInput, DebtUncheckedUpdateWithoutCreditorInput>
    create: XOR<DebtCreateWithoutCreditorInput, DebtUncheckedCreateWithoutCreditorInput>
  }

  export type DebtUpdateWithWhereUniqueWithoutCreditorInput = {
    where: DebtWhereUniqueInput
    data: XOR<DebtUpdateWithoutCreditorInput, DebtUncheckedUpdateWithoutCreditorInput>
  }

  export type DebtUpdateManyWithWhereWithoutCreditorInput = {
    where: DebtScalarWhereInput
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyWithoutCreditorInput>
  }

  export type DebtScalarWhereInput = {
    AND?: DebtScalarWhereInput | DebtScalarWhereInput[]
    OR?: DebtScalarWhereInput[]
    NOT?: DebtScalarWhereInput | DebtScalarWhereInput[]
    id?: StringFilter<"Debt"> | string
    amount?: FloatFilter<"Debt"> | number
    dueDate?: DateTimeFilter<"Debt"> | Date | string
    status?: EnumDebtStatusFilter<"Debt"> | $Enums.DebtStatus
    description?: StringNullableFilter<"Debt"> | string | null
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    paymentDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    reminderSent?: BoolFilter<"Debt"> | boolean
    lastReminderDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    reason?: StringNullableFilter<"Debt"> | string | null
    creditorId?: StringFilter<"Debt"> | string
    debtorId?: StringFilter<"Debt"> | string
    invoiceId?: StringNullableFilter<"Debt"> | string | null
    purchaseId?: StringNullableFilter<"Debt"> | string | null
  }

  export type DebtUpsertWithWhereUniqueWithoutDebtorInput = {
    where: DebtWhereUniqueInput
    update: XOR<DebtUpdateWithoutDebtorInput, DebtUncheckedUpdateWithoutDebtorInput>
    create: XOR<DebtCreateWithoutDebtorInput, DebtUncheckedCreateWithoutDebtorInput>
  }

  export type DebtUpdateWithWhereUniqueWithoutDebtorInput = {
    where: DebtWhereUniqueInput
    data: XOR<DebtUpdateWithoutDebtorInput, DebtUncheckedUpdateWithoutDebtorInput>
  }

  export type DebtUpdateManyWithWhereWithoutDebtorInput = {
    where: DebtScalarWhereInput
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyWithoutDebtorInput>
  }

  export type PurchaseContributorUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseContributorWhereUniqueInput
    update: XOR<PurchaseContributorUpdateWithoutUserInput, PurchaseContributorUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseContributorCreateWithoutUserInput, PurchaseContributorUncheckedCreateWithoutUserInput>
  }

  export type PurchaseContributorUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseContributorWhereUniqueInput
    data: XOR<PurchaseContributorUpdateWithoutUserInput, PurchaseContributorUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseContributorUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseContributorScalarWhereInput
    data: XOR<PurchaseContributorUpdateManyMutationInput, PurchaseContributorUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchaseContributorScalarWhereInput = {
    AND?: PurchaseContributorScalarWhereInput | PurchaseContributorScalarWhereInput[]
    OR?: PurchaseContributorScalarWhereInput[]
    NOT?: PurchaseContributorScalarWhereInput | PurchaseContributorScalarWhereInput[]
    id?: StringFilter<"PurchaseContributor"> | string
    purchaseId?: StringFilter<"PurchaseContributor"> | string
    userId?: StringFilter<"PurchaseContributor"> | string
    sharePercentage?: FloatFilter<"PurchaseContributor"> | number
    contribution?: FloatFilter<"PurchaseContributor"> | number
    expectedContribution?: FloatFilter<"PurchaseContributor"> | number
    actualContribution?: FloatFilter<"PurchaseContributor"> | number
    remainingAmount?: FloatNullableFilter<"PurchaseContributor"> | number | null
    hasPaid?: BoolFilter<"PurchaseContributor"> | boolean
    paymentDate?: DateTimeNullableFilter<"PurchaseContributor"> | Date | string | null
    isCreditor?: BoolFilter<"PurchaseContributor"> | boolean
    createdAt?: DateTimeFilter<"PurchaseContributor"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseContributor"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutReceiverInput, NotificationUncheckedUpdateWithoutReceiverInput>
    create: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutReceiverInput, NotificationUncheckedUpdateWithoutReceiverInput>
  }

  export type NotificationUpdateManyWithWhereWithoutReceiverInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutReceiverInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    isRead?: BoolFilter<"Notification"> | boolean
    isArchived?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    targetRoles?: EnumRoleNullableListFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    receiverId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    processId?: StringNullableFilter<"Notification"> | string | null
    debtId?: StringNullableFilter<"Notification"> | string | null
    purchaseId?: StringNullableFilter<"Notification"> | string | null
    inventoryId?: StringNullableFilter<"Notification"> | string | null
    irrigationId?: StringNullableFilter<"Notification"> | string | null
    fieldId?: StringNullableFilter<"Notification"> | string | null
    seasonId?: StringNullableFilter<"Notification"> | string | null
    cropId?: StringNullableFilter<"Notification"> | string | null
    wellId?: StringNullableFilter<"Notification"> | string | null
    processingLogId?: StringNullableFilter<"Notification"> | string | null
    invoiceId?: StringNullableFilter<"Notification"> | string | null
    inventoryUsageId?: StringNullableFilter<"Notification"> | string | null
    transactionId?: StringNullableFilter<"Notification"> | string | null
    paymentId?: StringNullableFilter<"Notification"> | string | null
    contributorId?: StringNullableFilter<"Notification"> | string | null
    approvalId?: StringNullableFilter<"Notification"> | string | null
    equipmentId?: StringNullableFilter<"Notification"> | string | null
    equipmentUsageId?: StringNullableFilter<"Notification"> | string | null
    processCostId?: StringNullableFilter<"Notification"> | string | null
    fieldExpenseId?: StringNullableFilter<"Notification"> | string | null
    ownerExpenseId?: StringNullableFilter<"Notification"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type InventoryUsageUpsertWithWhereUniqueWithoutUsedByInput = {
    where: InventoryUsageWhereUniqueInput
    update: XOR<InventoryUsageUpdateWithoutUsedByInput, InventoryUsageUncheckedUpdateWithoutUsedByInput>
    create: XOR<InventoryUsageCreateWithoutUsedByInput, InventoryUsageUncheckedCreateWithoutUsedByInput>
  }

  export type InventoryUsageUpdateWithWhereUniqueWithoutUsedByInput = {
    where: InventoryUsageWhereUniqueInput
    data: XOR<InventoryUsageUpdateWithoutUsedByInput, InventoryUsageUncheckedUpdateWithoutUsedByInput>
  }

  export type InventoryUsageUpdateManyWithWhereWithoutUsedByInput = {
    where: InventoryUsageScalarWhereInput
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyWithoutUsedByInput>
  }

  export type InventoryUsageScalarWhereInput = {
    AND?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
    OR?: InventoryUsageScalarWhereInput[]
    NOT?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
    id?: StringFilter<"InventoryUsage"> | string
    inventoryId?: StringFilter<"InventoryUsage"> | string
    usedQuantity?: FloatFilter<"InventoryUsage"> | number
    usageType?: EnumUsageTypeFilter<"InventoryUsage"> | $Enums.UsageType
    usedById?: StringFilter<"InventoryUsage"> | string
    fieldId?: StringNullableFilter<"InventoryUsage"> | string | null
    processId?: StringNullableFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeFilter<"InventoryUsage"> | Date | string
  }

  export type ProcessUpsertWithWhereUniqueWithoutWorkerInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutWorkerInput, ProcessUncheckedUpdateWithoutWorkerInput>
    create: XOR<ProcessCreateWithoutWorkerInput, ProcessUncheckedCreateWithoutWorkerInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutWorkerInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutWorkerInput, ProcessUncheckedUpdateWithoutWorkerInput>
  }

  export type ProcessUpdateManyWithWhereWithoutWorkerInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutWorkerInput>
  }

  export type ProcessScalarWhereInput = {
    AND?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    OR?: ProcessScalarWhereInput[]
    NOT?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    id?: StringFilter<"Process"> | string
    type?: EnumProcessTypeFilter<"Process"> | $Enums.ProcessType
    status?: EnumProcessStatusFilter<"Process"> | $Enums.ProcessStatus
    fieldId?: StringNullableFilter<"Process"> | string | null
    workerId?: StringFilter<"Process"> | string
    date?: DateTimeFilter<"Process"> | Date | string
    description?: StringNullableFilter<"Process"> | string | null
    totalArea?: FloatFilter<"Process"> | number
    processedArea?: FloatFilter<"Process"> | number
    processedPercentage?: FloatFilter<"Process"> | number
    seasonId?: StringNullableFilter<"Process"> | string | null
    inventoryDistribution?: JsonNullableFilter<"Process">
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPurchaserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPurchaserInput, InvoiceUncheckedUpdateWithoutPurchaserInput>
    create: XOR<InvoiceCreateWithoutPurchaserInput, InvoiceUncheckedCreateWithoutPurchaserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPurchaserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPurchaserInput, InvoiceUncheckedUpdateWithoutPurchaserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPurchaserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPurchaserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    purchaserId?: StringFilter<"Invoice"> | string
    purchaseId?: StringNullableFilter<"Invoice"> | string | null
  }

  export type PaymentHistoryUpsertWithWhereUniqueWithoutPayerInput = {
    where: PaymentHistoryWhereUniqueInput
    update: XOR<PaymentHistoryUpdateWithoutPayerInput, PaymentHistoryUncheckedUpdateWithoutPayerInput>
    create: XOR<PaymentHistoryCreateWithoutPayerInput, PaymentHistoryUncheckedCreateWithoutPayerInput>
  }

  export type PaymentHistoryUpdateWithWhereUniqueWithoutPayerInput = {
    where: PaymentHistoryWhereUniqueInput
    data: XOR<PaymentHistoryUpdateWithoutPayerInput, PaymentHistoryUncheckedUpdateWithoutPayerInput>
  }

  export type PaymentHistoryUpdateManyWithWhereWithoutPayerInput = {
    where: PaymentHistoryScalarWhereInput
    data: XOR<PaymentHistoryUpdateManyMutationInput, PaymentHistoryUncheckedUpdateManyWithoutPayerInput>
  }

  export type PaymentHistoryScalarWhereInput = {
    AND?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
    OR?: PaymentHistoryScalarWhereInput[]
    NOT?: PaymentHistoryScalarWhereInput | PaymentHistoryScalarWhereInput[]
    id?: StringFilter<"PaymentHistory"> | string
    amount?: FloatFilter<"PaymentHistory"> | number
    paymentDate?: DateTimeFilter<"PaymentHistory"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"PaymentHistory"> | $Enums.PaymentMethod
    notes?: StringNullableFilter<"PaymentHistory"> | string | null
    createdAt?: DateTimeFilter<"PaymentHistory"> | Date | string
    debtId?: StringNullableFilter<"PaymentHistory"> | string | null
    contributorId?: StringNullableFilter<"PaymentHistory"> | string | null
    payerId?: StringFilter<"PaymentHistory"> | string
    receiverId?: StringFilter<"PaymentHistory"> | string
  }

  export type PaymentHistoryUpsertWithWhereUniqueWithoutReceiverInput = {
    where: PaymentHistoryWhereUniqueInput
    update: XOR<PaymentHistoryUpdateWithoutReceiverInput, PaymentHistoryUncheckedUpdateWithoutReceiverInput>
    create: XOR<PaymentHistoryCreateWithoutReceiverInput, PaymentHistoryUncheckedCreateWithoutReceiverInput>
  }

  export type PaymentHistoryUpdateWithWhereUniqueWithoutReceiverInput = {
    where: PaymentHistoryWhereUniqueInput
    data: XOR<PaymentHistoryUpdateWithoutReceiverInput, PaymentHistoryUncheckedUpdateWithoutReceiverInput>
  }

  export type PaymentHistoryUpdateManyWithWhereWithoutReceiverInput = {
    where: PaymentHistoryScalarWhereInput
    data: XOR<PaymentHistoryUpdateManyMutationInput, PaymentHistoryUncheckedUpdateManyWithoutReceiverInput>
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutUserInput, InventoryTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutUserInput, InventoryTransactionUncheckedUpdateWithoutUserInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutUserInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryTransactionScalarWhereInput = {
    AND?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    OR?: InventoryTransactionScalarWhereInput[]
    NOT?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    type?: EnumTransactionTypeFilter<"InventoryTransaction"> | $Enums.TransactionType
    quantity?: FloatFilter<"InventoryTransaction"> | number
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    createdAt?: DateTimeFilter<"InventoryTransaction"> | Date | string
    seasonId?: StringNullableFilter<"InventoryTransaction"> | string | null
    inventoryId?: StringFilter<"InventoryTransaction"> | string
    purchaseId?: StringNullableFilter<"InventoryTransaction"> | string | null
    userId?: StringFilter<"InventoryTransaction"> | string
  }

  export type SeasonUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SeasonWhereUniqueInput
    update: XOR<SeasonUpdateWithoutCreatorInput, SeasonUncheckedUpdateWithoutCreatorInput>
    create: XOR<SeasonCreateWithoutCreatorInput, SeasonUncheckedCreateWithoutCreatorInput>
  }

  export type SeasonUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SeasonWhereUniqueInput
    data: XOR<SeasonUpdateWithoutCreatorInput, SeasonUncheckedUpdateWithoutCreatorInput>
  }

  export type SeasonUpdateManyWithWhereWithoutCreatorInput = {
    where: SeasonScalarWhereInput
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SeasonScalarWhereInput = {
    AND?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    OR?: SeasonScalarWhereInput[]
    NOT?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    id?: StringFilter<"Season"> | string
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    description?: StringNullableFilter<"Season"> | string | null
    isActive?: BoolFilter<"Season"> | boolean
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    creatorId?: StringFilter<"Season"> | string
  }

  export type PurchaseApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: PurchaseApprovalWhereUniqueInput
    update: XOR<PurchaseApprovalUpdateWithoutApproverInput, PurchaseApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<PurchaseApprovalCreateWithoutApproverInput, PurchaseApprovalUncheckedCreateWithoutApproverInput>
  }

  export type PurchaseApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: PurchaseApprovalWhereUniqueInput
    data: XOR<PurchaseApprovalUpdateWithoutApproverInput, PurchaseApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type PurchaseApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: PurchaseApprovalScalarWhereInput
    data: XOR<PurchaseApprovalUpdateManyMutationInput, PurchaseApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type PurchaseApprovalScalarWhereInput = {
    AND?: PurchaseApprovalScalarWhereInput | PurchaseApprovalScalarWhereInput[]
    OR?: PurchaseApprovalScalarWhereInput[]
    NOT?: PurchaseApprovalScalarWhereInput | PurchaseApprovalScalarWhereInput[]
    id?: StringFilter<"PurchaseApproval"> | string
    purchaseId?: StringFilter<"PurchaseApproval"> | string
    approverId?: StringFilter<"PurchaseApproval"> | string
    status?: EnumApprovalStatusFilter<"PurchaseApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"PurchaseApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"PurchaseApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"PurchaseApproval"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseApproval"> | Date | string
  }

  export type EquipmentOwnershipUpsertWithWhereUniqueWithoutUserInput = {
    where: EquipmentOwnershipWhereUniqueInput
    update: XOR<EquipmentOwnershipUpdateWithoutUserInput, EquipmentOwnershipUncheckedUpdateWithoutUserInput>
    create: XOR<EquipmentOwnershipCreateWithoutUserInput, EquipmentOwnershipUncheckedCreateWithoutUserInput>
  }

  export type EquipmentOwnershipUpdateWithWhereUniqueWithoutUserInput = {
    where: EquipmentOwnershipWhereUniqueInput
    data: XOR<EquipmentOwnershipUpdateWithoutUserInput, EquipmentOwnershipUncheckedUpdateWithoutUserInput>
  }

  export type EquipmentOwnershipUpdateManyWithWhereWithoutUserInput = {
    where: EquipmentOwnershipScalarWhereInput
    data: XOR<EquipmentOwnershipUpdateManyMutationInput, EquipmentOwnershipUncheckedUpdateManyWithoutUserInput>
  }

  export type EquipmentOwnershipScalarWhereInput = {
    AND?: EquipmentOwnershipScalarWhereInput | EquipmentOwnershipScalarWhereInput[]
    OR?: EquipmentOwnershipScalarWhereInput[]
    NOT?: EquipmentOwnershipScalarWhereInput | EquipmentOwnershipScalarWhereInput[]
    id?: StringFilter<"EquipmentOwnership"> | string
    equipmentId?: StringFilter<"EquipmentOwnership"> | string
    userId?: StringFilter<"EquipmentOwnership"> | string
    ownershipPercentage?: FloatFilter<"EquipmentOwnership"> | number
    createdAt?: DateTimeFilter<"EquipmentOwnership"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentOwnership"> | Date | string
  }

  export type EquipmentUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: EquipmentUsageWhereUniqueInput
    update: XOR<EquipmentUsageUpdateWithoutUserInput, EquipmentUsageUncheckedUpdateWithoutUserInput>
    create: XOR<EquipmentUsageCreateWithoutUserInput, EquipmentUsageUncheckedCreateWithoutUserInput>
  }

  export type EquipmentUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: EquipmentUsageWhereUniqueInput
    data: XOR<EquipmentUsageUpdateWithoutUserInput, EquipmentUsageUncheckedUpdateWithoutUserInput>
  }

  export type EquipmentUsageUpdateManyWithWhereWithoutUserInput = {
    where: EquipmentUsageScalarWhereInput
    data: XOR<EquipmentUsageUpdateManyMutationInput, EquipmentUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type EquipmentUsageScalarWhereInput = {
    AND?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
    OR?: EquipmentUsageScalarWhereInput[]
    NOT?: EquipmentUsageScalarWhereInput | EquipmentUsageScalarWhereInput[]
    id?: StringFilter<"EquipmentUsage"> | string
    processId?: StringFilter<"EquipmentUsage"> | string
    equipmentId?: StringFilter<"EquipmentUsage"> | string
    userId?: StringFilter<"EquipmentUsage"> | string
    areaProcessed?: FloatFilter<"EquipmentUsage"> | number
    processedPercentage?: FloatFilter<"EquipmentUsage"> | number
    fuelConsumed?: FloatFilter<"EquipmentUsage"> | number
    unit?: EnumUnitFilter<"EquipmentUsage"> | $Enums.Unit
    createdAt?: DateTimeFilter<"EquipmentUsage"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentUsage"> | Date | string
  }

  export type FieldOwnerExpenseUpsertWithWhereUniqueWithoutUserInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    update: XOR<FieldOwnerExpenseUpdateWithoutUserInput, FieldOwnerExpenseUncheckedUpdateWithoutUserInput>
    create: XOR<FieldOwnerExpenseCreateWithoutUserInput, FieldOwnerExpenseUncheckedCreateWithoutUserInput>
  }

  export type FieldOwnerExpenseUpdateWithWhereUniqueWithoutUserInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    data: XOR<FieldOwnerExpenseUpdateWithoutUserInput, FieldOwnerExpenseUncheckedUpdateWithoutUserInput>
  }

  export type FieldOwnerExpenseUpdateManyWithWhereWithoutUserInput = {
    where: FieldOwnerExpenseScalarWhereInput
    data: XOR<FieldOwnerExpenseUpdateManyMutationInput, FieldOwnerExpenseUncheckedUpdateManyWithoutUserInput>
  }

  export type FieldOwnerExpenseScalarWhereInput = {
    AND?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
    OR?: FieldOwnerExpenseScalarWhereInput[]
    NOT?: FieldOwnerExpenseScalarWhereInput | FieldOwnerExpenseScalarWhereInput[]
    id?: StringFilter<"FieldOwnerExpense"> | string
    fieldOwnershipId?: StringFilter<"FieldOwnerExpense"> | string
    processCostId?: StringFilter<"FieldOwnerExpense"> | string
    userId?: StringFilter<"FieldOwnerExpense"> | string
    amount?: FloatFilter<"FieldOwnerExpense"> | number
    percentage?: FloatFilter<"FieldOwnerExpense"> | number
    periodStart?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    periodEnd?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    createdAt?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FieldOwnerExpense"> | Date | string
  }

  export type WorkerWellAssignmentUpsertWithWhereUniqueWithoutWorkerInput = {
    where: WorkerWellAssignmentWhereUniqueInput
    update: XOR<WorkerWellAssignmentUpdateWithoutWorkerInput, WorkerWellAssignmentUncheckedUpdateWithoutWorkerInput>
    create: XOR<WorkerWellAssignmentCreateWithoutWorkerInput, WorkerWellAssignmentUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerWellAssignmentUpdateWithWhereUniqueWithoutWorkerInput = {
    where: WorkerWellAssignmentWhereUniqueInput
    data: XOR<WorkerWellAssignmentUpdateWithoutWorkerInput, WorkerWellAssignmentUncheckedUpdateWithoutWorkerInput>
  }

  export type WorkerWellAssignmentUpdateManyWithWhereWithoutWorkerInput = {
    where: WorkerWellAssignmentScalarWhereInput
    data: XOR<WorkerWellAssignmentUpdateManyMutationInput, WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerInput>
  }

  export type WorkerWellAssignmentScalarWhereInput = {
    AND?: WorkerWellAssignmentScalarWhereInput | WorkerWellAssignmentScalarWhereInput[]
    OR?: WorkerWellAssignmentScalarWhereInput[]
    NOT?: WorkerWellAssignmentScalarWhereInput | WorkerWellAssignmentScalarWhereInput[]
    id?: StringFilter<"WorkerWellAssignment"> | string
    createdAt?: DateTimeFilter<"WorkerWellAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"WorkerWellAssignment"> | Date | string
    workerId?: StringFilter<"WorkerWellAssignment"> | string
    wellId?: StringFilter<"WorkerWellAssignment"> | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    inAppNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyDigest?: BoolFieldUpdateOperationsInput | boolean
    notifyOnDebtReminders?: BoolFieldUpdateOperationsInput | boolean
    notifyOnPayments?: BoolFieldUpdateOperationsInput | boolean
    notifyOnProcessUpdates?: BoolFieldUpdateOperationsInput | boolean
    notifyOnInventoryAlerts?: BoolFieldUpdateOperationsInput | boolean
    notifyOnApprovals?: BoolFieldUpdateOperationsInput | boolean
    notifyOnIrrigation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    inAppNotifications?: BoolFieldUpdateOperationsInput | boolean
    dailyDigest?: BoolFieldUpdateOperationsInput | boolean
    notifyOnDebtReminders?: BoolFieldUpdateOperationsInput | boolean
    notifyOnPayments?: BoolFieldUpdateOperationsInput | boolean
    notifyOnProcessUpdates?: BoolFieldUpdateOperationsInput | boolean
    notifyOnInventoryAlerts?: BoolFieldUpdateOperationsInput | boolean
    notifyOnApprovals?: BoolFieldUpdateOperationsInput | boolean
    notifyOnIrrigation?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput = {
    where: IrrigationOwnerUsageWhereUniqueInput
    update: XOR<IrrigationOwnerUsageUpdateWithoutOwnerInput, IrrigationOwnerUsageUncheckedUpdateWithoutOwnerInput>
    create: XOR<IrrigationOwnerUsageCreateWithoutOwnerInput, IrrigationOwnerUsageUncheckedCreateWithoutOwnerInput>
  }

  export type IrrigationOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput = {
    where: IrrigationOwnerUsageWhereUniqueInput
    data: XOR<IrrigationOwnerUsageUpdateWithoutOwnerInput, IrrigationOwnerUsageUncheckedUpdateWithoutOwnerInput>
  }

  export type IrrigationOwnerUsageUpdateManyWithWhereWithoutOwnerInput = {
    where: IrrigationOwnerUsageScalarWhereInput
    data: XOR<IrrigationOwnerUsageUpdateManyMutationInput, IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerInput>
  }

  export type IrrigationOwnerUsageScalarWhereInput = {
    AND?: IrrigationOwnerUsageScalarWhereInput | IrrigationOwnerUsageScalarWhereInput[]
    OR?: IrrigationOwnerUsageScalarWhereInput[]
    NOT?: IrrigationOwnerUsageScalarWhereInput | IrrigationOwnerUsageScalarWhereInput[]
    id?: StringFilter<"IrrigationOwnerUsage"> | string
    irrigationFieldUsageId?: StringFilter<"IrrigationOwnerUsage"> | string
    ownerId?: StringFilter<"IrrigationOwnerUsage"> | string
    ownershipPercentage?: FloatFilter<"IrrigationOwnerUsage"> | number
    usagePercentage?: FloatFilter<"IrrigationOwnerUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationOwnerUsage"> | Date | string
  }

  export type IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutOwnerInput = {
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    update: XOR<IrrigationInventoryOwnerUsageUpdateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedUpdateWithoutOwnerInput>
    create: XOR<IrrigationInventoryOwnerUsageCreateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutOwnerInput>
  }

  export type IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutOwnerInput = {
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    data: XOR<IrrigationInventoryOwnerUsageUpdateWithoutOwnerInput, IrrigationInventoryOwnerUsageUncheckedUpdateWithoutOwnerInput>
  }

  export type IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutOwnerInput = {
    where: IrrigationInventoryOwnerUsageScalarWhereInput
    data: XOR<IrrigationInventoryOwnerUsageUpdateManyMutationInput, IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerInput>
  }

  export type IrrigationInventoryOwnerUsageScalarWhereInput = {
    AND?: IrrigationInventoryOwnerUsageScalarWhereInput | IrrigationInventoryOwnerUsageScalarWhereInput[]
    OR?: IrrigationInventoryOwnerUsageScalarWhereInput[]
    NOT?: IrrigationInventoryOwnerUsageScalarWhereInput | IrrigationInventoryOwnerUsageScalarWhereInput[]
    id?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    irrigationInventoryUsageId?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    ownerId?: StringFilter<"IrrigationInventoryOwnerUsage"> | string
    percentage?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    quantity?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    cost?: FloatFilter<"IrrigationInventoryOwnerUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationInventoryOwnerUsage"> | Date | string
  }

  export type IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutOwnerInput = {
    where: IrrigationOwnerSummaryWhereUniqueInput
    update: XOR<IrrigationOwnerSummaryUpdateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedUpdateWithoutOwnerInput>
    create: XOR<IrrigationOwnerSummaryCreateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedCreateWithoutOwnerInput>
  }

  export type IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutOwnerInput = {
    where: IrrigationOwnerSummaryWhereUniqueInput
    data: XOR<IrrigationOwnerSummaryUpdateWithoutOwnerInput, IrrigationOwnerSummaryUncheckedUpdateWithoutOwnerInput>
  }

  export type IrrigationOwnerSummaryUpdateManyWithWhereWithoutOwnerInput = {
    where: IrrigationOwnerSummaryScalarWhereInput
    data: XOR<IrrigationOwnerSummaryUpdateManyMutationInput, IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerInput>
  }

  export type IrrigationOwnerSummaryScalarWhereInput = {
    AND?: IrrigationOwnerSummaryScalarWhereInput | IrrigationOwnerSummaryScalarWhereInput[]
    OR?: IrrigationOwnerSummaryScalarWhereInput[]
    NOT?: IrrigationOwnerSummaryScalarWhereInput | IrrigationOwnerSummaryScalarWhereInput[]
    id?: StringFilter<"IrrigationOwnerSummary"> | string
    irrigationLogId?: StringFilter<"IrrigationOwnerSummary"> | string
    ownerId?: StringFilter<"IrrigationOwnerSummary"> | string
    totalIrrigatedArea?: FloatFilter<"IrrigationOwnerSummary"> | number
    totalAllocatedDuration?: FloatFilter<"IrrigationOwnerSummary"> | number
    createdAt?: DateTimeFilter<"IrrigationOwnerSummary"> | Date | string
  }

  export type WellBillDistributionUpsertWithWhereUniqueWithoutOwnerInput = {
    where: WellBillDistributionWhereUniqueInput
    update: XOR<WellBillDistributionUpdateWithoutOwnerInput, WellBillDistributionUncheckedUpdateWithoutOwnerInput>
    create: XOR<WellBillDistributionCreateWithoutOwnerInput, WellBillDistributionUncheckedCreateWithoutOwnerInput>
  }

  export type WellBillDistributionUpdateWithWhereUniqueWithoutOwnerInput = {
    where: WellBillDistributionWhereUniqueInput
    data: XOR<WellBillDistributionUpdateWithoutOwnerInput, WellBillDistributionUncheckedUpdateWithoutOwnerInput>
  }

  export type WellBillDistributionUpdateManyWithWhereWithoutOwnerInput = {
    where: WellBillDistributionScalarWhereInput
    data: XOR<WellBillDistributionUpdateManyMutationInput, WellBillDistributionUncheckedUpdateManyWithoutOwnerInput>
  }

  export type WellBillDistributionScalarWhereInput = {
    AND?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
    OR?: WellBillDistributionScalarWhereInput[]
    NOT?: WellBillDistributionScalarWhereInput | WellBillDistributionScalarWhereInput[]
    id?: StringFilter<"WellBillDistribution"> | string
    wellBillingPeriodId?: StringFilter<"WellBillDistribution"> | string
    fieldId?: StringFilter<"WellBillDistribution"> | string
    ownerId?: StringFilter<"WellBillDistribution"> | string
    basisDuration?: FloatFilter<"WellBillDistribution"> | number
    basisArea?: FloatNullableFilter<"WellBillDistribution"> | number | null
    basisWeight?: FloatFilter<"WellBillDistribution"> | number
    sharePercentage?: FloatFilter<"WellBillDistribution"> | number
    amount?: FloatFilter<"WellBillDistribution"> | number
    createdAt?: DateTimeFilter<"WellBillDistribution"> | Date | string
    debtId?: StringNullableFilter<"WellBillDistribution"> | string | null
  }

  export type UserCreateWithoutSeasonsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutSeasonsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutSeasonsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSeasonsInput, UserUncheckedCreateWithoutSeasonsInput>
  }

  export type FieldCreateWithoutSeasonInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutSeasonInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutSeasonInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutSeasonInput, FieldUncheckedCreateWithoutSeasonInput>
  }

  export type FieldCreateManySeasonInputEnvelope = {
    data: FieldCreateManySeasonInput | FieldCreateManySeasonInput[]
  }

  export type CropCreateWithoutSeasonInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutCropsInput
    notifications?: NotificationCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutSeasonInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutSeasonInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutSeasonInput, CropUncheckedCreateWithoutSeasonInput>
  }

  export type CropCreateManySeasonInputEnvelope = {
    data: CropCreateManySeasonInput | CropCreateManySeasonInput[]
  }

  export type PurchaseCreateWithoutSeasonInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutSeasonInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutSeasonInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutSeasonInput, PurchaseUncheckedCreateWithoutSeasonInput>
  }

  export type PurchaseCreateManySeasonInputEnvelope = {
    data: PurchaseCreateManySeasonInput | PurchaseCreateManySeasonInput[]
  }

  export type InventoryTransactionCreateWithoutSeasonInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutInventoryTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutInventoryTransactionsInput
    user: UserCreateNestedOneWithoutInventoryTransactionsInput
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutSeasonInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    inventoryId: string
    purchaseId?: string | null
    userId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionCreateOrConnectWithoutSeasonInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutSeasonInput, InventoryTransactionUncheckedCreateWithoutSeasonInput>
  }

  export type InventoryTransactionCreateManySeasonInputEnvelope = {
    data: InventoryTransactionCreateManySeasonInput | InventoryTransactionCreateManySeasonInput[]
  }

  export type ProcessCreateWithoutSeasonInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    worker: UserCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutSeasonInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutSeasonInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutSeasonInput, ProcessUncheckedCreateWithoutSeasonInput>
  }

  export type ProcessCreateManySeasonInputEnvelope = {
    data: ProcessCreateManySeasonInput | ProcessCreateManySeasonInput[]
  }

  export type IrrigationLogCreateWithoutSeasonInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutSeasonInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutSeasonInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutSeasonInput, IrrigationLogUncheckedCreateWithoutSeasonInput>
  }

  export type IrrigationLogCreateManySeasonInputEnvelope = {
    data: IrrigationLogCreateManySeasonInput | IrrigationLogCreateManySeasonInput[]
  }

  export type FieldExpenseCreateWithoutSeasonInput = {
    id?: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutFieldExpensesInput
    notifications?: NotificationCreateNestedManyWithoutFieldExpenseInput
  }

  export type FieldExpenseUncheckedCreateWithoutSeasonInput = {
    id?: string
    fieldId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldExpenseInput
  }

  export type FieldExpenseCreateOrConnectWithoutSeasonInput = {
    where: FieldExpenseWhereUniqueInput
    create: XOR<FieldExpenseCreateWithoutSeasonInput, FieldExpenseUncheckedCreateWithoutSeasonInput>
  }

  export type FieldExpenseCreateManySeasonInputEnvelope = {
    data: FieldExpenseCreateManySeasonInput | FieldExpenseCreateManySeasonInput[]
  }

  export type NotificationCreateWithoutSeasonInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSeasonInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutSeasonInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSeasonInput, NotificationUncheckedCreateWithoutSeasonInput>
  }

  export type NotificationCreateManySeasonInputEnvelope = {
    data: NotificationCreateManySeasonInput | NotificationCreateManySeasonInput[]
  }

  export type UserUpsertWithoutSeasonsInput = {
    update: XOR<UserUpdateWithoutSeasonsInput, UserUncheckedUpdateWithoutSeasonsInput>
    create: XOR<UserCreateWithoutSeasonsInput, UserUncheckedCreateWithoutSeasonsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSeasonsInput, UserUncheckedUpdateWithoutSeasonsInput>
  }

  export type UserUpdateWithoutSeasonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSeasonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type FieldUpsertWithWhereUniqueWithoutSeasonInput = {
    where: FieldWhereUniqueInput
    update: XOR<FieldUpdateWithoutSeasonInput, FieldUncheckedUpdateWithoutSeasonInput>
    create: XOR<FieldCreateWithoutSeasonInput, FieldUncheckedCreateWithoutSeasonInput>
  }

  export type FieldUpdateWithWhereUniqueWithoutSeasonInput = {
    where: FieldWhereUniqueInput
    data: XOR<FieldUpdateWithoutSeasonInput, FieldUncheckedUpdateWithoutSeasonInput>
  }

  export type FieldUpdateManyWithWhereWithoutSeasonInput = {
    where: FieldScalarWhereInput
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyWithoutSeasonInput>
  }

  export type FieldScalarWhereInput = {
    AND?: FieldScalarWhereInput | FieldScalarWhereInput[]
    OR?: FieldScalarWhereInput[]
    NOT?: FieldScalarWhereInput | FieldScalarWhereInput[]
    id?: StringFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    location?: StringFilter<"Field"> | string
    size?: FloatFilter<"Field"> | number
    coordinates?: StringNullableFilter<"Field"> | string | null
    status?: StringFilter<"Field"> | string
    createdAt?: DateTimeFilter<"Field"> | Date | string
    updatedAt?: DateTimeFilter<"Field"> | Date | string
    seasonId?: StringNullableFilter<"Field"> | string | null
  }

  export type CropUpsertWithWhereUniqueWithoutSeasonInput = {
    where: CropWhereUniqueInput
    update: XOR<CropUpdateWithoutSeasonInput, CropUncheckedUpdateWithoutSeasonInput>
    create: XOR<CropCreateWithoutSeasonInput, CropUncheckedCreateWithoutSeasonInput>
  }

  export type CropUpdateWithWhereUniqueWithoutSeasonInput = {
    where: CropWhereUniqueInput
    data: XOR<CropUpdateWithoutSeasonInput, CropUncheckedUpdateWithoutSeasonInput>
  }

  export type CropUpdateManyWithWhereWithoutSeasonInput = {
    where: CropScalarWhereInput
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyWithoutSeasonInput>
  }

  export type CropScalarWhereInput = {
    AND?: CropScalarWhereInput | CropScalarWhereInput[]
    OR?: CropScalarWhereInput[]
    NOT?: CropScalarWhereInput | CropScalarWhereInput[]
    id?: StringFilter<"Crop"> | string
    name?: StringFilter<"Crop"> | string
    plantedDate?: DateTimeFilter<"Crop"> | Date | string
    harvestDate?: DateTimeNullableFilter<"Crop"> | Date | string | null
    status?: EnumCropStatusFilter<"Crop"> | $Enums.CropStatus
    notes?: StringNullableFilter<"Crop"> | string | null
    createdAt?: DateTimeFilter<"Crop"> | Date | string
    updatedAt?: DateTimeFilter<"Crop"> | Date | string
    seasonId?: StringNullableFilter<"Crop"> | string | null
    fieldId?: StringFilter<"Crop"> | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutSeasonInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutSeasonInput, PurchaseUncheckedUpdateWithoutSeasonInput>
    create: XOR<PurchaseCreateWithoutSeasonInput, PurchaseUncheckedCreateWithoutSeasonInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutSeasonInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutSeasonInput, PurchaseUncheckedUpdateWithoutSeasonInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutSeasonInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutSeasonInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    product?: StringFilter<"Purchase"> | string
    category?: EnumProductCategoryFilter<"Purchase"> | $Enums.ProductCategory
    quantity?: FloatFilter<"Purchase"> | number
    unit?: EnumUnitFilter<"Purchase"> | $Enums.Unit
    unitPrice?: FloatFilter<"Purchase"> | number
    totalCost?: FloatFilter<"Purchase"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Purchase"> | $Enums.PaymentMethod
    creditorPaymentDueDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Purchase"> | Date | string | null
    description?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    isTemplate?: BoolFilter<"Purchase"> | boolean
    templateName?: StringNullableFilter<"Purchase"> | string | null
    approvalStatus?: EnumApprovalStatusFilter<"Purchase"> | $Enums.ApprovalStatus
    approvalRequired?: BoolFilter<"Purchase"> | boolean
    approvalThreshold?: FloatFilter<"Purchase"> | number
    seasonId?: StringNullableFilter<"Purchase"> | string | null
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutSeasonInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutSeasonInput, InventoryTransactionUncheckedUpdateWithoutSeasonInput>
    create: XOR<InventoryTransactionCreateWithoutSeasonInput, InventoryTransactionUncheckedCreateWithoutSeasonInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutSeasonInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutSeasonInput, InventoryTransactionUncheckedUpdateWithoutSeasonInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutSeasonInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutSeasonInput>
  }

  export type ProcessUpsertWithWhereUniqueWithoutSeasonInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutSeasonInput, ProcessUncheckedUpdateWithoutSeasonInput>
    create: XOR<ProcessCreateWithoutSeasonInput, ProcessUncheckedCreateWithoutSeasonInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutSeasonInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutSeasonInput, ProcessUncheckedUpdateWithoutSeasonInput>
  }

  export type ProcessUpdateManyWithWhereWithoutSeasonInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutSeasonInput>
  }

  export type IrrigationLogUpsertWithWhereUniqueWithoutSeasonInput = {
    where: IrrigationLogWhereUniqueInput
    update: XOR<IrrigationLogUpdateWithoutSeasonInput, IrrigationLogUncheckedUpdateWithoutSeasonInput>
    create: XOR<IrrigationLogCreateWithoutSeasonInput, IrrigationLogUncheckedCreateWithoutSeasonInput>
  }

  export type IrrigationLogUpdateWithWhereUniqueWithoutSeasonInput = {
    where: IrrigationLogWhereUniqueInput
    data: XOR<IrrigationLogUpdateWithoutSeasonInput, IrrigationLogUncheckedUpdateWithoutSeasonInput>
  }

  export type IrrigationLogUpdateManyWithWhereWithoutSeasonInput = {
    where: IrrigationLogScalarWhereInput
    data: XOR<IrrigationLogUpdateManyMutationInput, IrrigationLogUncheckedUpdateManyWithoutSeasonInput>
  }

  export type FieldExpenseUpsertWithWhereUniqueWithoutSeasonInput = {
    where: FieldExpenseWhereUniqueInput
    update: XOR<FieldExpenseUpdateWithoutSeasonInput, FieldExpenseUncheckedUpdateWithoutSeasonInput>
    create: XOR<FieldExpenseCreateWithoutSeasonInput, FieldExpenseUncheckedCreateWithoutSeasonInput>
  }

  export type FieldExpenseUpdateWithWhereUniqueWithoutSeasonInput = {
    where: FieldExpenseWhereUniqueInput
    data: XOR<FieldExpenseUpdateWithoutSeasonInput, FieldExpenseUncheckedUpdateWithoutSeasonInput>
  }

  export type FieldExpenseUpdateManyWithWhereWithoutSeasonInput = {
    where: FieldExpenseScalarWhereInput
    data: XOR<FieldExpenseUpdateManyMutationInput, FieldExpenseUncheckedUpdateManyWithoutSeasonInput>
  }

  export type FieldExpenseScalarWhereInput = {
    AND?: FieldExpenseScalarWhereInput | FieldExpenseScalarWhereInput[]
    OR?: FieldExpenseScalarWhereInput[]
    NOT?: FieldExpenseScalarWhereInput | FieldExpenseScalarWhereInput[]
    id?: StringFilter<"FieldExpense"> | string
    fieldId?: StringFilter<"FieldExpense"> | string
    seasonId?: StringFilter<"FieldExpense"> | string
    totalCost?: FloatFilter<"FieldExpense"> | number
    description?: StringFilter<"FieldExpense"> | string
    expenseDate?: DateTimeFilter<"FieldExpense"> | Date | string
    sourceType?: StringFilter<"FieldExpense"> | string
    sourceId?: StringFilter<"FieldExpense"> | string
    createdAt?: DateTimeFilter<"FieldExpense"> | Date | string
    updatedAt?: DateTimeFilter<"FieldExpense"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSeasonInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSeasonInput, NotificationUncheckedUpdateWithoutSeasonInput>
    create: XOR<NotificationCreateWithoutSeasonInput, NotificationUncheckedCreateWithoutSeasonInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSeasonInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSeasonInput, NotificationUncheckedUpdateWithoutSeasonInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSeasonInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSeasonInput>
  }

  export type SeasonCreateWithoutFieldsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutFieldsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutFieldsInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutFieldsInput, SeasonUncheckedCreateWithoutFieldsInput>
  }

  export type FieldOwnershipCreateWithoutFieldInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    user: UserCreateNestedOneWithoutOwnedFieldsInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutFieldOwnershipInput
  }

  export type FieldOwnershipUncheckedCreateWithoutFieldInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    userId: string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutFieldOwnershipInput
  }

  export type FieldOwnershipCreateOrConnectWithoutFieldInput = {
    where: FieldOwnershipWhereUniqueInput
    create: XOR<FieldOwnershipCreateWithoutFieldInput, FieldOwnershipUncheckedCreateWithoutFieldInput>
  }

  export type FieldOwnershipCreateManyFieldInputEnvelope = {
    data: FieldOwnershipCreateManyFieldInput | FieldOwnershipCreateManyFieldInput[]
  }

  export type FieldWorkerAssignmentCreateWithoutFieldInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAssignedFieldsInput
  }

  export type FieldWorkerAssignmentUncheckedCreateWithoutFieldInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type FieldWorkerAssignmentCreateOrConnectWithoutFieldInput = {
    where: FieldWorkerAssignmentWhereUniqueInput
    create: XOR<FieldWorkerAssignmentCreateWithoutFieldInput, FieldWorkerAssignmentUncheckedCreateWithoutFieldInput>
  }

  export type FieldWorkerAssignmentCreateManyFieldInputEnvelope = {
    data: FieldWorkerAssignmentCreateManyFieldInput | FieldWorkerAssignmentCreateManyFieldInput[]
  }

  export type CropCreateWithoutFieldInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutCropsInput
    notifications?: NotificationCreateNestedManyWithoutCropInput
  }

  export type CropUncheckedCreateWithoutFieldInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutCropInput
  }

  export type CropCreateOrConnectWithoutFieldInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutFieldInput, CropUncheckedCreateWithoutFieldInput>
  }

  export type CropCreateManyFieldInputEnvelope = {
    data: CropCreateManyFieldInput | CropCreateManyFieldInput[]
  }

  export type FieldWellCreateWithoutFieldInput = {
    id?: string
    createdAt?: Date | string
    well: WellCreateNestedOneWithoutFieldWellsInput
  }

  export type FieldWellUncheckedCreateWithoutFieldInput = {
    id?: string
    wellId: string
    createdAt?: Date | string
  }

  export type FieldWellCreateOrConnectWithoutFieldInput = {
    where: FieldWellWhereUniqueInput
    create: XOR<FieldWellCreateWithoutFieldInput, FieldWellUncheckedCreateWithoutFieldInput>
  }

  export type FieldWellCreateManyFieldInputEnvelope = {
    data: FieldWellCreateManyFieldInput | FieldWellCreateManyFieldInput[]
  }

  export type ProcessingLogCreateWithoutFieldInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutProcessingLogInput
  }

  export type ProcessingLogUncheckedCreateWithoutFieldInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessingLogInput
  }

  export type ProcessingLogCreateOrConnectWithoutFieldInput = {
    where: ProcessingLogWhereUniqueInput
    create: XOR<ProcessingLogCreateWithoutFieldInput, ProcessingLogUncheckedCreateWithoutFieldInput>
  }

  export type ProcessingLogCreateManyFieldInputEnvelope = {
    data: ProcessingLogCreateManyFieldInput | ProcessingLogCreateManyFieldInput[]
  }

  export type ProcessCostCreateWithoutFieldInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutProcessCostsInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutProcessCostInput
    notifications?: NotificationCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostUncheckedCreateWithoutFieldInput = {
    id?: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutProcessCostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostCreateOrConnectWithoutFieldInput = {
    where: ProcessCostWhereUniqueInput
    create: XOR<ProcessCostCreateWithoutFieldInput, ProcessCostUncheckedCreateWithoutFieldInput>
  }

  export type ProcessCostCreateManyFieldInputEnvelope = {
    data: ProcessCostCreateManyFieldInput | ProcessCostCreateManyFieldInput[]
  }

  export type InventoryUsageCreateWithoutFieldInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutUsagesInput
    usedBy: UserCreateNestedOneWithoutInventoryUsagesInput
    process?: ProcessCreateNestedOneWithoutInventoryUsagesInput
    notifications?: NotificationCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageUncheckedCreateWithoutFieldInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    processId?: string | null
    createdAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageCreateOrConnectWithoutFieldInput = {
    where: InventoryUsageWhereUniqueInput
    create: XOR<InventoryUsageCreateWithoutFieldInput, InventoryUsageUncheckedCreateWithoutFieldInput>
  }

  export type InventoryUsageCreateManyFieldInputEnvelope = {
    data: InventoryUsageCreateManyFieldInput | InventoryUsageCreateManyFieldInput[]
  }

  export type ProcessCreateWithoutFieldInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    worker: UserCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutFieldInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutFieldInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutFieldInput, ProcessUncheckedCreateWithoutFieldInput>
  }

  export type ProcessCreateManyFieldInputEnvelope = {
    data: ProcessCreateManyFieldInput | ProcessCreateManyFieldInput[]
  }

  export type FieldExpenseCreateWithoutFieldInput = {
    id?: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season: SeasonCreateNestedOneWithoutFieldExpensesInput
    notifications?: NotificationCreateNestedManyWithoutFieldExpenseInput
  }

  export type FieldExpenseUncheckedCreateWithoutFieldInput = {
    id?: string
    seasonId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldExpenseInput
  }

  export type FieldExpenseCreateOrConnectWithoutFieldInput = {
    where: FieldExpenseWhereUniqueInput
    create: XOR<FieldExpenseCreateWithoutFieldInput, FieldExpenseUncheckedCreateWithoutFieldInput>
  }

  export type FieldExpenseCreateManyFieldInputEnvelope = {
    data: FieldExpenseCreateManyFieldInput | FieldExpenseCreateManyFieldInput[]
  }

  export type NotificationCreateWithoutFieldInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutFieldInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutFieldInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutFieldInput, NotificationUncheckedCreateWithoutFieldInput>
  }

  export type NotificationCreateManyFieldInputEnvelope = {
    data: NotificationCreateManyFieldInput | NotificationCreateManyFieldInput[]
  }

  export type IrrigationFieldUsageCreateWithoutFieldInput = {
    id?: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutFieldUsagesInput
    ownerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutIrrigationFieldUsageInput
  }

  export type IrrigationFieldUsageUncheckedCreateWithoutFieldInput = {
    id?: string
    irrigationLogId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    ownerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutIrrigationFieldUsageInput
  }

  export type IrrigationFieldUsageCreateOrConnectWithoutFieldInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    create: XOR<IrrigationFieldUsageCreateWithoutFieldInput, IrrigationFieldUsageUncheckedCreateWithoutFieldInput>
  }

  export type IrrigationFieldUsageCreateManyFieldInputEnvelope = {
    data: IrrigationFieldUsageCreateManyFieldInput | IrrigationFieldUsageCreateManyFieldInput[]
  }

  export type WellBillDistributionCreateWithoutFieldInput = {
    id?: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    wellBillingPeriod: WellBillingPeriodCreateNestedOneWithoutDistributionsInput
    owner: UserCreateNestedOneWithoutWellBillDistributionsInput
    debt?: DebtCreateNestedOneWithoutWellBillDistributionsInput
  }

  export type WellBillDistributionUncheckedCreateWithoutFieldInput = {
    id?: string
    wellBillingPeriodId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type WellBillDistributionCreateOrConnectWithoutFieldInput = {
    where: WellBillDistributionWhereUniqueInput
    create: XOR<WellBillDistributionCreateWithoutFieldInput, WellBillDistributionUncheckedCreateWithoutFieldInput>
  }

  export type WellBillDistributionCreateManyFieldInputEnvelope = {
    data: WellBillDistributionCreateManyFieldInput | WellBillDistributionCreateManyFieldInput[]
  }

  export type SeasonUpsertWithoutFieldsInput = {
    update: XOR<SeasonUpdateWithoutFieldsInput, SeasonUncheckedUpdateWithoutFieldsInput>
    create: XOR<SeasonCreateWithoutFieldsInput, SeasonUncheckedCreateWithoutFieldsInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutFieldsInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutFieldsInput, SeasonUncheckedUpdateWithoutFieldsInput>
  }

  export type SeasonUpdateWithoutFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type FieldOwnershipUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldOwnershipWhereUniqueInput
    update: XOR<FieldOwnershipUpdateWithoutFieldInput, FieldOwnershipUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldOwnershipCreateWithoutFieldInput, FieldOwnershipUncheckedCreateWithoutFieldInput>
  }

  export type FieldOwnershipUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldOwnershipWhereUniqueInput
    data: XOR<FieldOwnershipUpdateWithoutFieldInput, FieldOwnershipUncheckedUpdateWithoutFieldInput>
  }

  export type FieldOwnershipUpdateManyWithWhereWithoutFieldInput = {
    where: FieldOwnershipScalarWhereInput
    data: XOR<FieldOwnershipUpdateManyMutationInput, FieldOwnershipUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldWorkerAssignmentUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldWorkerAssignmentWhereUniqueInput
    update: XOR<FieldWorkerAssignmentUpdateWithoutFieldInput, FieldWorkerAssignmentUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldWorkerAssignmentCreateWithoutFieldInput, FieldWorkerAssignmentUncheckedCreateWithoutFieldInput>
  }

  export type FieldWorkerAssignmentUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldWorkerAssignmentWhereUniqueInput
    data: XOR<FieldWorkerAssignmentUpdateWithoutFieldInput, FieldWorkerAssignmentUncheckedUpdateWithoutFieldInput>
  }

  export type FieldWorkerAssignmentUpdateManyWithWhereWithoutFieldInput = {
    where: FieldWorkerAssignmentScalarWhereInput
    data: XOR<FieldWorkerAssignmentUpdateManyMutationInput, FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldInput>
  }

  export type CropUpsertWithWhereUniqueWithoutFieldInput = {
    where: CropWhereUniqueInput
    update: XOR<CropUpdateWithoutFieldInput, CropUncheckedUpdateWithoutFieldInput>
    create: XOR<CropCreateWithoutFieldInput, CropUncheckedCreateWithoutFieldInput>
  }

  export type CropUpdateWithWhereUniqueWithoutFieldInput = {
    where: CropWhereUniqueInput
    data: XOR<CropUpdateWithoutFieldInput, CropUncheckedUpdateWithoutFieldInput>
  }

  export type CropUpdateManyWithWhereWithoutFieldInput = {
    where: CropScalarWhereInput
    data: XOR<CropUpdateManyMutationInput, CropUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldWellUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldWellWhereUniqueInput
    update: XOR<FieldWellUpdateWithoutFieldInput, FieldWellUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldWellCreateWithoutFieldInput, FieldWellUncheckedCreateWithoutFieldInput>
  }

  export type FieldWellUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldWellWhereUniqueInput
    data: XOR<FieldWellUpdateWithoutFieldInput, FieldWellUncheckedUpdateWithoutFieldInput>
  }

  export type FieldWellUpdateManyWithWhereWithoutFieldInput = {
    where: FieldWellScalarWhereInput
    data: XOR<FieldWellUpdateManyMutationInput, FieldWellUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldWellScalarWhereInput = {
    AND?: FieldWellScalarWhereInput | FieldWellScalarWhereInput[]
    OR?: FieldWellScalarWhereInput[]
    NOT?: FieldWellScalarWhereInput | FieldWellScalarWhereInput[]
    id?: StringFilter<"FieldWell"> | string
    fieldId?: StringFilter<"FieldWell"> | string
    wellId?: StringFilter<"FieldWell"> | string
    createdAt?: DateTimeFilter<"FieldWell"> | Date | string
  }

  export type ProcessingLogUpsertWithWhereUniqueWithoutFieldInput = {
    where: ProcessingLogWhereUniqueInput
    update: XOR<ProcessingLogUpdateWithoutFieldInput, ProcessingLogUncheckedUpdateWithoutFieldInput>
    create: XOR<ProcessingLogCreateWithoutFieldInput, ProcessingLogUncheckedCreateWithoutFieldInput>
  }

  export type ProcessingLogUpdateWithWhereUniqueWithoutFieldInput = {
    where: ProcessingLogWhereUniqueInput
    data: XOR<ProcessingLogUpdateWithoutFieldInput, ProcessingLogUncheckedUpdateWithoutFieldInput>
  }

  export type ProcessingLogUpdateManyWithWhereWithoutFieldInput = {
    where: ProcessingLogScalarWhereInput
    data: XOR<ProcessingLogUpdateManyMutationInput, ProcessingLogUncheckedUpdateManyWithoutFieldInput>
  }

  export type ProcessingLogScalarWhereInput = {
    AND?: ProcessingLogScalarWhereInput | ProcessingLogScalarWhereInput[]
    OR?: ProcessingLogScalarWhereInput[]
    NOT?: ProcessingLogScalarWhereInput | ProcessingLogScalarWhereInput[]
    id?: StringFilter<"ProcessingLog"> | string
    date?: DateTimeFilter<"ProcessingLog"> | Date | string
    processType?: EnumProcessTypeFilter<"ProcessingLog"> | $Enums.ProcessType
    equipment?: StringNullableFilter<"ProcessingLog"> | string | null
    duration?: FloatFilter<"ProcessingLog"> | number
    notes?: StringNullableFilter<"ProcessingLog"> | string | null
    createdAt?: DateTimeFilter<"ProcessingLog"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessingLog"> | Date | string
    fieldId?: StringFilter<"ProcessingLog"> | string
  }

  export type ProcessCostUpsertWithWhereUniqueWithoutFieldInput = {
    where: ProcessCostWhereUniqueInput
    update: XOR<ProcessCostUpdateWithoutFieldInput, ProcessCostUncheckedUpdateWithoutFieldInput>
    create: XOR<ProcessCostCreateWithoutFieldInput, ProcessCostUncheckedCreateWithoutFieldInput>
  }

  export type ProcessCostUpdateWithWhereUniqueWithoutFieldInput = {
    where: ProcessCostWhereUniqueInput
    data: XOR<ProcessCostUpdateWithoutFieldInput, ProcessCostUncheckedUpdateWithoutFieldInput>
  }

  export type ProcessCostUpdateManyWithWhereWithoutFieldInput = {
    where: ProcessCostScalarWhereInput
    data: XOR<ProcessCostUpdateManyMutationInput, ProcessCostUncheckedUpdateManyWithoutFieldInput>
  }

  export type ProcessCostScalarWhereInput = {
    AND?: ProcessCostScalarWhereInput | ProcessCostScalarWhereInput[]
    OR?: ProcessCostScalarWhereInput[]
    NOT?: ProcessCostScalarWhereInput | ProcessCostScalarWhereInput[]
    id?: StringFilter<"ProcessCost"> | string
    processId?: StringFilter<"ProcessCost"> | string
    laborCost?: FloatFilter<"ProcessCost"> | number
    equipmentCost?: FloatFilter<"ProcessCost"> | number
    inventoryCost?: FloatFilter<"ProcessCost"> | number
    fuelCost?: FloatFilter<"ProcessCost"> | number
    totalCost?: FloatFilter<"ProcessCost"> | number
    createdAt?: DateTimeFilter<"ProcessCost"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessCost"> | Date | string
    fieldId?: StringFilter<"ProcessCost"> | string
  }

  export type InventoryUsageUpsertWithWhereUniqueWithoutFieldInput = {
    where: InventoryUsageWhereUniqueInput
    update: XOR<InventoryUsageUpdateWithoutFieldInput, InventoryUsageUncheckedUpdateWithoutFieldInput>
    create: XOR<InventoryUsageCreateWithoutFieldInput, InventoryUsageUncheckedCreateWithoutFieldInput>
  }

  export type InventoryUsageUpdateWithWhereUniqueWithoutFieldInput = {
    where: InventoryUsageWhereUniqueInput
    data: XOR<InventoryUsageUpdateWithoutFieldInput, InventoryUsageUncheckedUpdateWithoutFieldInput>
  }

  export type InventoryUsageUpdateManyWithWhereWithoutFieldInput = {
    where: InventoryUsageScalarWhereInput
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyWithoutFieldInput>
  }

  export type ProcessUpsertWithWhereUniqueWithoutFieldInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutFieldInput, ProcessUncheckedUpdateWithoutFieldInput>
    create: XOR<ProcessCreateWithoutFieldInput, ProcessUncheckedCreateWithoutFieldInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutFieldInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutFieldInput, ProcessUncheckedUpdateWithoutFieldInput>
  }

  export type ProcessUpdateManyWithWhereWithoutFieldInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldExpenseUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldExpenseWhereUniqueInput
    update: XOR<FieldExpenseUpdateWithoutFieldInput, FieldExpenseUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldExpenseCreateWithoutFieldInput, FieldExpenseUncheckedCreateWithoutFieldInput>
  }

  export type FieldExpenseUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldExpenseWhereUniqueInput
    data: XOR<FieldExpenseUpdateWithoutFieldInput, FieldExpenseUncheckedUpdateWithoutFieldInput>
  }

  export type FieldExpenseUpdateManyWithWhereWithoutFieldInput = {
    where: FieldExpenseScalarWhereInput
    data: XOR<FieldExpenseUpdateManyMutationInput, FieldExpenseUncheckedUpdateManyWithoutFieldInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutFieldInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutFieldInput, NotificationUncheckedUpdateWithoutFieldInput>
    create: XOR<NotificationCreateWithoutFieldInput, NotificationUncheckedCreateWithoutFieldInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutFieldInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutFieldInput, NotificationUncheckedUpdateWithoutFieldInput>
  }

  export type NotificationUpdateManyWithWhereWithoutFieldInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutFieldInput>
  }

  export type IrrigationFieldUsageUpsertWithWhereUniqueWithoutFieldInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    update: XOR<IrrigationFieldUsageUpdateWithoutFieldInput, IrrigationFieldUsageUncheckedUpdateWithoutFieldInput>
    create: XOR<IrrigationFieldUsageCreateWithoutFieldInput, IrrigationFieldUsageUncheckedCreateWithoutFieldInput>
  }

  export type IrrigationFieldUsageUpdateWithWhereUniqueWithoutFieldInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    data: XOR<IrrigationFieldUsageUpdateWithoutFieldInput, IrrigationFieldUsageUncheckedUpdateWithoutFieldInput>
  }

  export type IrrigationFieldUsageUpdateManyWithWhereWithoutFieldInput = {
    where: IrrigationFieldUsageScalarWhereInput
    data: XOR<IrrigationFieldUsageUpdateManyMutationInput, IrrigationFieldUsageUncheckedUpdateManyWithoutFieldInput>
  }

  export type IrrigationFieldUsageScalarWhereInput = {
    AND?: IrrigationFieldUsageScalarWhereInput | IrrigationFieldUsageScalarWhereInput[]
    OR?: IrrigationFieldUsageScalarWhereInput[]
    NOT?: IrrigationFieldUsageScalarWhereInput | IrrigationFieldUsageScalarWhereInput[]
    id?: StringFilter<"IrrigationFieldUsage"> | string
    irrigationLogId?: StringFilter<"IrrigationFieldUsage"> | string
    fieldId?: StringFilter<"IrrigationFieldUsage"> | string
    percentage?: FloatFilter<"IrrigationFieldUsage"> | number
    actualIrrigatedArea?: FloatNullableFilter<"IrrigationFieldUsage"> | number | null
    createdAt?: DateTimeFilter<"IrrigationFieldUsage"> | Date | string
  }

  export type WellBillDistributionUpsertWithWhereUniqueWithoutFieldInput = {
    where: WellBillDistributionWhereUniqueInput
    update: XOR<WellBillDistributionUpdateWithoutFieldInput, WellBillDistributionUncheckedUpdateWithoutFieldInput>
    create: XOR<WellBillDistributionCreateWithoutFieldInput, WellBillDistributionUncheckedCreateWithoutFieldInput>
  }

  export type WellBillDistributionUpdateWithWhereUniqueWithoutFieldInput = {
    where: WellBillDistributionWhereUniqueInput
    data: XOR<WellBillDistributionUpdateWithoutFieldInput, WellBillDistributionUncheckedUpdateWithoutFieldInput>
  }

  export type WellBillDistributionUpdateManyWithWhereWithoutFieldInput = {
    where: WellBillDistributionScalarWhereInput
    data: XOR<WellBillDistributionUpdateManyMutationInput, WellBillDistributionUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldCreateWithoutOwnersInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutOwnersInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutOwnersInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutOwnersInput, FieldUncheckedCreateWithoutOwnersInput>
  }

  export type UserCreateWithoutOwnedFieldsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutOwnedFieldsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutOwnedFieldsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedFieldsInput, UserUncheckedCreateWithoutOwnedFieldsInput>
  }

  export type FieldOwnerExpenseCreateWithoutFieldOwnershipInput = {
    id?: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    processCost: ProcessCostCreateNestedOneWithoutOwnerExpensesInput
    user: UserCreateNestedOneWithoutFieldOwnerExpensesInput
    notifications?: NotificationCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput = {
    id?: string
    processCostId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseCreateOrConnectWithoutFieldOwnershipInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    create: XOR<FieldOwnerExpenseCreateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput>
  }

  export type FieldOwnerExpenseCreateManyFieldOwnershipInputEnvelope = {
    data: FieldOwnerExpenseCreateManyFieldOwnershipInput | FieldOwnerExpenseCreateManyFieldOwnershipInput[]
  }

  export type FieldUpsertWithoutOwnersInput = {
    update: XOR<FieldUpdateWithoutOwnersInput, FieldUncheckedUpdateWithoutOwnersInput>
    create: XOR<FieldCreateWithoutOwnersInput, FieldUncheckedCreateWithoutOwnersInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutOwnersInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutOwnersInput, FieldUncheckedUpdateWithoutOwnersInput>
  }

  export type FieldUpdateWithoutOwnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutOwnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type UserUpsertWithoutOwnedFieldsInput = {
    update: XOR<UserUpdateWithoutOwnedFieldsInput, UserUncheckedUpdateWithoutOwnedFieldsInput>
    create: XOR<UserCreateWithoutOwnedFieldsInput, UserUncheckedCreateWithoutOwnedFieldsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedFieldsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedFieldsInput, UserUncheckedUpdateWithoutOwnedFieldsInput>
  }

  export type UserUpdateWithoutOwnedFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type FieldOwnerExpenseUpsertWithWhereUniqueWithoutFieldOwnershipInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    update: XOR<FieldOwnerExpenseUpdateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedUpdateWithoutFieldOwnershipInput>
    create: XOR<FieldOwnerExpenseCreateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedCreateWithoutFieldOwnershipInput>
  }

  export type FieldOwnerExpenseUpdateWithWhereUniqueWithoutFieldOwnershipInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    data: XOR<FieldOwnerExpenseUpdateWithoutFieldOwnershipInput, FieldOwnerExpenseUncheckedUpdateWithoutFieldOwnershipInput>
  }

  export type FieldOwnerExpenseUpdateManyWithWhereWithoutFieldOwnershipInput = {
    where: FieldOwnerExpenseScalarWhereInput
    data: XOR<FieldOwnerExpenseUpdateManyMutationInput, FieldOwnerExpenseUncheckedUpdateManyWithoutFieldOwnershipInput>
  }

  export type FieldCreateWithoutWorkerAssignmentsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutWorkerAssignmentsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutWorkerAssignmentsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutWorkerAssignmentsInput, FieldUncheckedCreateWithoutWorkerAssignmentsInput>
  }

  export type UserCreateWithoutAssignedFieldsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAssignedFieldsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAssignedFieldsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedFieldsInput, UserUncheckedCreateWithoutAssignedFieldsInput>
  }

  export type FieldUpsertWithoutWorkerAssignmentsInput = {
    update: XOR<FieldUpdateWithoutWorkerAssignmentsInput, FieldUncheckedUpdateWithoutWorkerAssignmentsInput>
    create: XOR<FieldCreateWithoutWorkerAssignmentsInput, FieldUncheckedCreateWithoutWorkerAssignmentsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutWorkerAssignmentsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutWorkerAssignmentsInput, FieldUncheckedUpdateWithoutWorkerAssignmentsInput>
  }

  export type FieldUpdateWithoutWorkerAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutWorkerAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type UserUpsertWithoutAssignedFieldsInput = {
    update: XOR<UserUpdateWithoutAssignedFieldsInput, UserUncheckedUpdateWithoutAssignedFieldsInput>
    create: XOR<UserCreateWithoutAssignedFieldsInput, UserUncheckedCreateWithoutAssignedFieldsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedFieldsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedFieldsInput, UserUncheckedUpdateWithoutAssignedFieldsInput>
  }

  export type UserUpdateWithoutAssignedFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type FieldCreateWithoutFieldWellsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutFieldWellsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutFieldWellsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFieldWellsInput, FieldUncheckedCreateWithoutFieldWellsInput>
  }

  export type WellCreateWithoutFieldWellsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWellInput
  }

  export type WellUncheckedCreateWithoutFieldWellsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodUncheckedCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWellInput
  }

  export type WellCreateOrConnectWithoutFieldWellsInput = {
    where: WellWhereUniqueInput
    create: XOR<WellCreateWithoutFieldWellsInput, WellUncheckedCreateWithoutFieldWellsInput>
  }

  export type FieldUpsertWithoutFieldWellsInput = {
    update: XOR<FieldUpdateWithoutFieldWellsInput, FieldUncheckedUpdateWithoutFieldWellsInput>
    create: XOR<FieldCreateWithoutFieldWellsInput, FieldUncheckedCreateWithoutFieldWellsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFieldWellsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFieldWellsInput, FieldUncheckedUpdateWithoutFieldWellsInput>
  }

  export type FieldUpdateWithoutFieldWellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFieldWellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type WellUpsertWithoutFieldWellsInput = {
    update: XOR<WellUpdateWithoutFieldWellsInput, WellUncheckedUpdateWithoutFieldWellsInput>
    create: XOR<WellCreateWithoutFieldWellsInput, WellUncheckedCreateWithoutFieldWellsInput>
    where?: WellWhereInput
  }

  export type WellUpdateToOneWithWhereWithoutFieldWellsInput = {
    where?: WellWhereInput
    data: XOR<WellUpdateWithoutFieldWellsInput, WellUncheckedUpdateWithoutFieldWellsInput>
  }

  export type WellUpdateWithoutFieldWellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUpdateManyWithoutWellNestedInput
  }

  export type WellUncheckedUpdateWithoutFieldWellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUncheckedUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWellNestedInput
  }

  export type UserCreateWithoutWellAssignmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutWellAssignmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutWellAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWellAssignmentsInput, UserUncheckedCreateWithoutWellAssignmentsInput>
  }

  export type WellCreateWithoutWorkerAssignmentsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellCreateNestedManyWithoutWellInput
    notifications?: NotificationCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodCreateNestedManyWithoutWellInput
  }

  export type WellUncheckedCreateWithoutWorkerAssignmentsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutWellInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodUncheckedCreateNestedManyWithoutWellInput
  }

  export type WellCreateOrConnectWithoutWorkerAssignmentsInput = {
    where: WellWhereUniqueInput
    create: XOR<WellCreateWithoutWorkerAssignmentsInput, WellUncheckedCreateWithoutWorkerAssignmentsInput>
  }

  export type UserUpsertWithoutWellAssignmentsInput = {
    update: XOR<UserUpdateWithoutWellAssignmentsInput, UserUncheckedUpdateWithoutWellAssignmentsInput>
    create: XOR<UserCreateWithoutWellAssignmentsInput, UserUncheckedCreateWithoutWellAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWellAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWellAssignmentsInput, UserUncheckedUpdateWithoutWellAssignmentsInput>
  }

  export type UserUpdateWithoutWellAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutWellAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type WellUpsertWithoutWorkerAssignmentsInput = {
    update: XOR<WellUpdateWithoutWorkerAssignmentsInput, WellUncheckedUpdateWithoutWorkerAssignmentsInput>
    create: XOR<WellCreateWithoutWorkerAssignmentsInput, WellUncheckedCreateWithoutWorkerAssignmentsInput>
    where?: WellWhereInput
  }

  export type WellUpdateToOneWithWhereWithoutWorkerAssignmentsInput = {
    where?: WellWhereInput
    data: XOR<WellUpdateWithoutWorkerAssignmentsInput, WellUncheckedUpdateWithoutWorkerAssignmentsInput>
  }

  export type WellUpdateWithoutWorkerAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUpdateManyWithoutWellNestedInput
    notifications?: NotificationUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUpdateManyWithoutWellNestedInput
  }

  export type WellUncheckedUpdateWithoutWorkerAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUncheckedUpdateManyWithoutWellNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUncheckedUpdateManyWithoutWellNestedInput
  }

  export type FieldWellCreateWithoutWellInput = {
    id?: string
    createdAt?: Date | string
    field: FieldCreateNestedOneWithoutFieldWellsInput
  }

  export type FieldWellUncheckedCreateWithoutWellInput = {
    id?: string
    fieldId: string
    createdAt?: Date | string
  }

  export type FieldWellCreateOrConnectWithoutWellInput = {
    where: FieldWellWhereUniqueInput
    create: XOR<FieldWellCreateWithoutWellInput, FieldWellUncheckedCreateWithoutWellInput>
  }

  export type FieldWellCreateManyWellInputEnvelope = {
    data: FieldWellCreateManyWellInput | FieldWellCreateManyWellInput[]
  }

  export type NotificationCreateWithoutWellInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutWellInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutWellInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutWellInput, NotificationUncheckedCreateWithoutWellInput>
  }

  export type NotificationCreateManyWellInputEnvelope = {
    data: NotificationCreateManyWellInput | NotificationCreateManyWellInput[]
  }

  export type IrrigationLogCreateWithoutWellInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutWellInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutWellInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutWellInput, IrrigationLogUncheckedCreateWithoutWellInput>
  }

  export type IrrigationLogCreateManyWellInputEnvelope = {
    data: IrrigationLogCreateManyWellInput | IrrigationLogCreateManyWellInput[]
  }

  export type WellBillingPeriodCreateWithoutWellInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    irrigationUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutWellBillingPeriodInput
    distributions?: WellBillDistributionCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodUncheckedCreateWithoutWellInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    irrigationUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutWellBillingPeriodInput
    distributions?: WellBillDistributionUncheckedCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodCreateOrConnectWithoutWellInput = {
    where: WellBillingPeriodWhereUniqueInput
    create: XOR<WellBillingPeriodCreateWithoutWellInput, WellBillingPeriodUncheckedCreateWithoutWellInput>
  }

  export type WellBillingPeriodCreateManyWellInputEnvelope = {
    data: WellBillingPeriodCreateManyWellInput | WellBillingPeriodCreateManyWellInput[]
  }

  export type WorkerWellAssignmentCreateWithoutWellInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    worker: UserCreateNestedOneWithoutWellAssignmentsInput
  }

  export type WorkerWellAssignmentUncheckedCreateWithoutWellInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workerId: string
  }

  export type WorkerWellAssignmentCreateOrConnectWithoutWellInput = {
    where: WorkerWellAssignmentWhereUniqueInput
    create: XOR<WorkerWellAssignmentCreateWithoutWellInput, WorkerWellAssignmentUncheckedCreateWithoutWellInput>
  }

  export type WorkerWellAssignmentCreateManyWellInputEnvelope = {
    data: WorkerWellAssignmentCreateManyWellInput | WorkerWellAssignmentCreateManyWellInput[]
  }

  export type FieldWellUpsertWithWhereUniqueWithoutWellInput = {
    where: FieldWellWhereUniqueInput
    update: XOR<FieldWellUpdateWithoutWellInput, FieldWellUncheckedUpdateWithoutWellInput>
    create: XOR<FieldWellCreateWithoutWellInput, FieldWellUncheckedCreateWithoutWellInput>
  }

  export type FieldWellUpdateWithWhereUniqueWithoutWellInput = {
    where: FieldWellWhereUniqueInput
    data: XOR<FieldWellUpdateWithoutWellInput, FieldWellUncheckedUpdateWithoutWellInput>
  }

  export type FieldWellUpdateManyWithWhereWithoutWellInput = {
    where: FieldWellScalarWhereInput
    data: XOR<FieldWellUpdateManyMutationInput, FieldWellUncheckedUpdateManyWithoutWellInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutWellInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutWellInput, NotificationUncheckedUpdateWithoutWellInput>
    create: XOR<NotificationCreateWithoutWellInput, NotificationUncheckedCreateWithoutWellInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutWellInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutWellInput, NotificationUncheckedUpdateWithoutWellInput>
  }

  export type NotificationUpdateManyWithWhereWithoutWellInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutWellInput>
  }

  export type IrrigationLogUpsertWithWhereUniqueWithoutWellInput = {
    where: IrrigationLogWhereUniqueInput
    update: XOR<IrrigationLogUpdateWithoutWellInput, IrrigationLogUncheckedUpdateWithoutWellInput>
    create: XOR<IrrigationLogCreateWithoutWellInput, IrrigationLogUncheckedCreateWithoutWellInput>
  }

  export type IrrigationLogUpdateWithWhereUniqueWithoutWellInput = {
    where: IrrigationLogWhereUniqueInput
    data: XOR<IrrigationLogUpdateWithoutWellInput, IrrigationLogUncheckedUpdateWithoutWellInput>
  }

  export type IrrigationLogUpdateManyWithWhereWithoutWellInput = {
    where: IrrigationLogScalarWhereInput
    data: XOR<IrrigationLogUpdateManyMutationInput, IrrigationLogUncheckedUpdateManyWithoutWellInput>
  }

  export type WellBillingPeriodUpsertWithWhereUniqueWithoutWellInput = {
    where: WellBillingPeriodWhereUniqueInput
    update: XOR<WellBillingPeriodUpdateWithoutWellInput, WellBillingPeriodUncheckedUpdateWithoutWellInput>
    create: XOR<WellBillingPeriodCreateWithoutWellInput, WellBillingPeriodUncheckedCreateWithoutWellInput>
  }

  export type WellBillingPeriodUpdateWithWhereUniqueWithoutWellInput = {
    where: WellBillingPeriodWhereUniqueInput
    data: XOR<WellBillingPeriodUpdateWithoutWellInput, WellBillingPeriodUncheckedUpdateWithoutWellInput>
  }

  export type WellBillingPeriodUpdateManyWithWhereWithoutWellInput = {
    where: WellBillingPeriodScalarWhereInput
    data: XOR<WellBillingPeriodUpdateManyMutationInput, WellBillingPeriodUncheckedUpdateManyWithoutWellInput>
  }

  export type WellBillingPeriodScalarWhereInput = {
    AND?: WellBillingPeriodScalarWhereInput | WellBillingPeriodScalarWhereInput[]
    OR?: WellBillingPeriodScalarWhereInput[]
    NOT?: WellBillingPeriodScalarWhereInput | WellBillingPeriodScalarWhereInput[]
    id?: StringFilter<"WellBillingPeriod"> | string
    wellId?: StringFilter<"WellBillingPeriod"> | string
    startDate?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    endDate?: DateTimeFilter<"WellBillingPeriod"> | Date | string
    totalAmount?: FloatFilter<"WellBillingPeriod"> | number
    totalUsage?: FloatNullableFilter<"WellBillingPeriod"> | number | null
    status?: StringFilter<"WellBillingPeriod"> | string
    createdAt?: DateTimeFilter<"WellBillingPeriod"> | Date | string
  }

  export type WorkerWellAssignmentUpsertWithWhereUniqueWithoutWellInput = {
    where: WorkerWellAssignmentWhereUniqueInput
    update: XOR<WorkerWellAssignmentUpdateWithoutWellInput, WorkerWellAssignmentUncheckedUpdateWithoutWellInput>
    create: XOR<WorkerWellAssignmentCreateWithoutWellInput, WorkerWellAssignmentUncheckedCreateWithoutWellInput>
  }

  export type WorkerWellAssignmentUpdateWithWhereUniqueWithoutWellInput = {
    where: WorkerWellAssignmentWhereUniqueInput
    data: XOR<WorkerWellAssignmentUpdateWithoutWellInput, WorkerWellAssignmentUncheckedUpdateWithoutWellInput>
  }

  export type WorkerWellAssignmentUpdateManyWithWhereWithoutWellInput = {
    where: WorkerWellAssignmentScalarWhereInput
    data: XOR<WorkerWellAssignmentUpdateManyMutationInput, WorkerWellAssignmentUncheckedUpdateManyWithoutWellInput>
  }

  export type SeasonCreateWithoutCropsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutCropsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutCropsInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutCropsInput, SeasonUncheckedCreateWithoutCropsInput>
  }

  export type FieldCreateWithoutCropsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutCropsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutCropsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutCropsInput, FieldUncheckedCreateWithoutCropsInput>
  }

  export type NotificationCreateWithoutCropInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCropInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutCropInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCropInput, NotificationUncheckedCreateWithoutCropInput>
  }

  export type NotificationCreateManyCropInputEnvelope = {
    data: NotificationCreateManyCropInput | NotificationCreateManyCropInput[]
  }

  export type SeasonUpsertWithoutCropsInput = {
    update: XOR<SeasonUpdateWithoutCropsInput, SeasonUncheckedUpdateWithoutCropsInput>
    create: XOR<SeasonCreateWithoutCropsInput, SeasonUncheckedCreateWithoutCropsInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutCropsInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutCropsInput, SeasonUncheckedUpdateWithoutCropsInput>
  }

  export type SeasonUpdateWithoutCropsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutCropsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type FieldUpsertWithoutCropsInput = {
    update: XOR<FieldUpdateWithoutCropsInput, FieldUncheckedUpdateWithoutCropsInput>
    create: XOR<FieldCreateWithoutCropsInput, FieldUncheckedCreateWithoutCropsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutCropsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutCropsInput, FieldUncheckedUpdateWithoutCropsInput>
  }

  export type FieldUpdateWithoutCropsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutCropsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutCropInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCropInput, NotificationUncheckedUpdateWithoutCropInput>
    create: XOR<NotificationCreateWithoutCropInput, NotificationUncheckedCreateWithoutCropInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCropInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCropInput, NotificationUncheckedUpdateWithoutCropInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCropInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCropInput>
  }

  export type FieldCreateWithoutProcessingLogsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutProcessingLogsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutProcessingLogsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutProcessingLogsInput, FieldUncheckedCreateWithoutProcessingLogsInput>
  }

  export type NotificationCreateWithoutProcessingLogInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutProcessingLogInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutProcessingLogInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutProcessingLogInput, NotificationUncheckedCreateWithoutProcessingLogInput>
  }

  export type NotificationCreateManyProcessingLogInputEnvelope = {
    data: NotificationCreateManyProcessingLogInput | NotificationCreateManyProcessingLogInput[]
  }

  export type FieldUpsertWithoutProcessingLogsInput = {
    update: XOR<FieldUpdateWithoutProcessingLogsInput, FieldUncheckedUpdateWithoutProcessingLogsInput>
    create: XOR<FieldCreateWithoutProcessingLogsInput, FieldUncheckedCreateWithoutProcessingLogsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutProcessingLogsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutProcessingLogsInput, FieldUncheckedUpdateWithoutProcessingLogsInput>
  }

  export type FieldUpdateWithoutProcessingLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutProcessingLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutProcessingLogInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutProcessingLogInput, NotificationUncheckedUpdateWithoutProcessingLogInput>
    create: XOR<NotificationCreateWithoutProcessingLogInput, NotificationUncheckedCreateWithoutProcessingLogInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutProcessingLogInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutProcessingLogInput, NotificationUncheckedUpdateWithoutProcessingLogInput>
  }

  export type NotificationUpdateManyWithWhereWithoutProcessingLogInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutProcessingLogInput>
  }

  export type InventoryOwnershipCreateWithoutInventoryInput = {
    id?: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInventoryOwnershipInput
  }

  export type InventoryOwnershipUncheckedCreateWithoutInventoryInput = {
    id?: string
    userId: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryOwnershipCreateOrConnectWithoutInventoryInput = {
    where: InventoryOwnershipWhereUniqueInput
    create: XOR<InventoryOwnershipCreateWithoutInventoryInput, InventoryOwnershipUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryOwnershipCreateManyInventoryInputEnvelope = {
    data: InventoryOwnershipCreateManyInventoryInput | InventoryOwnershipCreateManyInventoryInput[]
  }

  export type InventoryUsageCreateWithoutInventoryInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    createdAt?: Date | string
    usedBy: UserCreateNestedOneWithoutInventoryUsagesInput
    field?: FieldCreateNestedOneWithoutInventoryUsagesInput
    process?: ProcessCreateNestedOneWithoutInventoryUsagesInput
    notifications?: NotificationCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageUncheckedCreateWithoutInventoryInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageCreateOrConnectWithoutInventoryInput = {
    where: InventoryUsageWhereUniqueInput
    create: XOR<InventoryUsageCreateWithoutInventoryInput, InventoryUsageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUsageCreateManyInventoryInputEnvelope = {
    data: InventoryUsageCreateManyInventoryInput | InventoryUsageCreateManyInventoryInput[]
  }

  export type InventoryTransactionCreateWithoutInventoryInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    season?: SeasonCreateNestedOneWithoutInventoryTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutInventoryTransactionsInput
    user: UserCreateNestedOneWithoutInventoryTransactionsInput
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutInventoryInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    purchaseId?: string | null
    userId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionCreateOrConnectWithoutInventoryInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutInventoryInput, InventoryTransactionUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryTransactionCreateManyInventoryInputEnvelope = {
    data: InventoryTransactionCreateManyInventoryInput | InventoryTransactionCreateManyInventoryInput[]
  }

  export type NotificationCreateWithoutInventoryInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutInventoryInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutInventoryInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutInventoryInput, NotificationUncheckedCreateWithoutInventoryInput>
  }

  export type NotificationCreateManyInventoryInputEnvelope = {
    data: NotificationCreateManyInventoryInput | NotificationCreateManyInventoryInput[]
  }

  export type IrrigationInventoryUsageCreateWithoutInventoryInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutInventoryUsagesInput
    ownerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutIrrigationInventoryUsageInput
  }

  export type IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput = {
    id?: string
    irrigationLogId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    ownerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutIrrigationInventoryUsageInput
  }

  export type IrrigationInventoryUsageCreateOrConnectWithoutInventoryInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    create: XOR<IrrigationInventoryUsageCreateWithoutInventoryInput, IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput>
  }

  export type IrrigationInventoryUsageCreateManyInventoryInputEnvelope = {
    data: IrrigationInventoryUsageCreateManyInventoryInput | IrrigationInventoryUsageCreateManyInventoryInput[]
  }

  export type InventoryOwnershipUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryOwnershipWhereUniqueInput
    update: XOR<InventoryOwnershipUpdateWithoutInventoryInput, InventoryOwnershipUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryOwnershipCreateWithoutInventoryInput, InventoryOwnershipUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryOwnershipUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryOwnershipWhereUniqueInput
    data: XOR<InventoryOwnershipUpdateWithoutInventoryInput, InventoryOwnershipUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryOwnershipUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryOwnershipScalarWhereInput
    data: XOR<InventoryOwnershipUpdateManyMutationInput, InventoryOwnershipUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryUsageUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUsageWhereUniqueInput
    update: XOR<InventoryUsageUpdateWithoutInventoryInput, InventoryUsageUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryUsageCreateWithoutInventoryInput, InventoryUsageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUsageUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUsageWhereUniqueInput
    data: XOR<InventoryUsageUpdateWithoutInventoryInput, InventoryUsageUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryUsageUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryUsageScalarWhereInput
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutInventoryInput, InventoryTransactionUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryTransactionCreateWithoutInventoryInput, InventoryTransactionUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutInventoryInput, InventoryTransactionUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutInventoryInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutInventoryInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutInventoryInput, NotificationUncheckedUpdateWithoutInventoryInput>
    create: XOR<NotificationCreateWithoutInventoryInput, NotificationUncheckedCreateWithoutInventoryInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutInventoryInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutInventoryInput, NotificationUncheckedUpdateWithoutInventoryInput>
  }

  export type NotificationUpdateManyWithWhereWithoutInventoryInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutInventoryInput>
  }

  export type IrrigationInventoryUsageUpsertWithWhereUniqueWithoutInventoryInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    update: XOR<IrrigationInventoryUsageUpdateWithoutInventoryInput, IrrigationInventoryUsageUncheckedUpdateWithoutInventoryInput>
    create: XOR<IrrigationInventoryUsageCreateWithoutInventoryInput, IrrigationInventoryUsageUncheckedCreateWithoutInventoryInput>
  }

  export type IrrigationInventoryUsageUpdateWithWhereUniqueWithoutInventoryInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    data: XOR<IrrigationInventoryUsageUpdateWithoutInventoryInput, IrrigationInventoryUsageUncheckedUpdateWithoutInventoryInput>
  }

  export type IrrigationInventoryUsageUpdateManyWithWhereWithoutInventoryInput = {
    where: IrrigationInventoryUsageScalarWhereInput
    data: XOR<IrrigationInventoryUsageUpdateManyMutationInput, IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryInput>
  }

  export type IrrigationInventoryUsageScalarWhereInput = {
    AND?: IrrigationInventoryUsageScalarWhereInput | IrrigationInventoryUsageScalarWhereInput[]
    OR?: IrrigationInventoryUsageScalarWhereInput[]
    NOT?: IrrigationInventoryUsageScalarWhereInput | IrrigationInventoryUsageScalarWhereInput[]
    id?: StringFilter<"IrrigationInventoryUsage"> | string
    irrigationLogId?: StringFilter<"IrrigationInventoryUsage"> | string
    inventoryId?: StringFilter<"IrrigationInventoryUsage"> | string
    quantity?: FloatFilter<"IrrigationInventoryUsage"> | number
    unitPrice?: FloatFilter<"IrrigationInventoryUsage"> | number
    totalCost?: FloatFilter<"IrrigationInventoryUsage"> | number
    createdAt?: DateTimeFilter<"IrrigationInventoryUsage"> | Date | string
  }

  export type InventoryCreateWithoutOwnershipsInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: InventoryUsageCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutInventoryInput
    notifications?: NotificationCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutOwnershipsInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: InventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutOwnershipsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutOwnershipsInput, InventoryUncheckedCreateWithoutOwnershipsInput>
  }

  export type UserCreateWithoutInventoryOwnershipInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutInventoryOwnershipInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutInventoryOwnershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryOwnershipInput, UserUncheckedCreateWithoutInventoryOwnershipInput>
  }

  export type InventoryUpsertWithoutOwnershipsInput = {
    update: XOR<InventoryUpdateWithoutOwnershipsInput, InventoryUncheckedUpdateWithoutOwnershipsInput>
    create: XOR<InventoryCreateWithoutOwnershipsInput, InventoryUncheckedCreateWithoutOwnershipsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutOwnershipsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutOwnershipsInput, InventoryUncheckedUpdateWithoutOwnershipsInput>
  }

  export type InventoryUpdateWithoutOwnershipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: InventoryUsageUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutOwnershipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: InventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type UserUpsertWithoutInventoryOwnershipInput = {
    update: XOR<UserUpdateWithoutInventoryOwnershipInput, UserUncheckedUpdateWithoutInventoryOwnershipInput>
    create: XOR<UserCreateWithoutInventoryOwnershipInput, UserUncheckedCreateWithoutInventoryOwnershipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryOwnershipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryOwnershipInput, UserUncheckedUpdateWithoutInventoryOwnershipInput>
  }

  export type UserUpdateWithoutInventoryOwnershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryOwnershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type SeasonCreateWithoutPurchasesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutPurchasesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutPurchasesInput, SeasonUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseContributorCreateWithoutPurchaseInput = {
    id?: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchaseContributionsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutContributorInput
    notifications?: NotificationCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorUncheckedCreateWithoutPurchaseInput = {
    id?: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutContributorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseContributorWhereUniqueInput
    create: XOR<PurchaseContributorCreateWithoutPurchaseInput, PurchaseContributorUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseContributorCreateManyPurchaseInputEnvelope = {
    data: PurchaseContributorCreateManyPurchaseInput | PurchaseContributorCreateManyPurchaseInput[]
  }

  export type DebtCreateWithoutPurchaseInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutPurchaseInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutPurchaseInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutPurchaseInput, DebtUncheckedCreateWithoutPurchaseInput>
  }

  export type DebtCreateManyPurchaseInputEnvelope = {
    data: DebtCreateManyPurchaseInput | DebtCreateManyPurchaseInput[]
  }

  export type InvoiceCreateWithoutPurchaseInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaser: UserCreateNestedOneWithoutInvoicesPurchasedInput
    debts?: DebtCreateNestedManyWithoutInvoiceInput
    notifications?: NotificationCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPurchaseInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaserId: string
    debts?: DebtUncheckedCreateNestedManyWithoutInvoiceInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPurchaseInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPurchaseInput, InvoiceUncheckedCreateWithoutPurchaseInput>
  }

  export type InvoiceCreateManyPurchaseInputEnvelope = {
    data: InvoiceCreateManyPurchaseInput | InvoiceCreateManyPurchaseInput[]
  }

  export type InventoryTransactionCreateWithoutPurchaseInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    season?: SeasonCreateNestedOneWithoutInventoryTransactionsInput
    inventory: InventoryCreateNestedOneWithoutInventoryTransactionsInput
    user: UserCreateNestedOneWithoutInventoryTransactionsInput
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutPurchaseInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    userId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type InventoryTransactionCreateOrConnectWithoutPurchaseInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutPurchaseInput, InventoryTransactionUncheckedCreateWithoutPurchaseInput>
  }

  export type InventoryTransactionCreateManyPurchaseInputEnvelope = {
    data: InventoryTransactionCreateManyPurchaseInput | InventoryTransactionCreateManyPurchaseInput[]
  }

  export type PurchaseApprovalCreateWithoutPurchaseInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver: UserCreateNestedOneWithoutPurchaseApprovalsInput
    notifications?: NotificationCreateNestedManyWithoutApprovalInput
  }

  export type PurchaseApprovalUncheckedCreateWithoutPurchaseInput = {
    id?: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type PurchaseApprovalCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseApprovalWhereUniqueInput
    create: XOR<PurchaseApprovalCreateWithoutPurchaseInput, PurchaseApprovalUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseApprovalCreateManyPurchaseInputEnvelope = {
    data: PurchaseApprovalCreateManyPurchaseInput | PurchaseApprovalCreateManyPurchaseInput[]
  }

  export type NotificationCreateWithoutPurchaseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPurchaseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutPurchaseInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPurchaseInput, NotificationUncheckedCreateWithoutPurchaseInput>
  }

  export type NotificationCreateManyPurchaseInputEnvelope = {
    data: NotificationCreateManyPurchaseInput | NotificationCreateManyPurchaseInput[]
  }

  export type SeasonUpsertWithoutPurchasesInput = {
    update: XOR<SeasonUpdateWithoutPurchasesInput, SeasonUncheckedUpdateWithoutPurchasesInput>
    create: XOR<SeasonCreateWithoutPurchasesInput, SeasonUncheckedCreateWithoutPurchasesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutPurchasesInput, SeasonUncheckedUpdateWithoutPurchasesInput>
  }

  export type SeasonUpdateWithoutPurchasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutPurchasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type PurchaseContributorUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseContributorWhereUniqueInput
    update: XOR<PurchaseContributorUpdateWithoutPurchaseInput, PurchaseContributorUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseContributorCreateWithoutPurchaseInput, PurchaseContributorUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseContributorUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseContributorWhereUniqueInput
    data: XOR<PurchaseContributorUpdateWithoutPurchaseInput, PurchaseContributorUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseContributorUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseContributorScalarWhereInput
    data: XOR<PurchaseContributorUpdateManyMutationInput, PurchaseContributorUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type DebtUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: DebtWhereUniqueInput
    update: XOR<DebtUpdateWithoutPurchaseInput, DebtUncheckedUpdateWithoutPurchaseInput>
    create: XOR<DebtCreateWithoutPurchaseInput, DebtUncheckedCreateWithoutPurchaseInput>
  }

  export type DebtUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: DebtWhereUniqueInput
    data: XOR<DebtUpdateWithoutPurchaseInput, DebtUncheckedUpdateWithoutPurchaseInput>
  }

  export type DebtUpdateManyWithWhereWithoutPurchaseInput = {
    where: DebtScalarWhereInput
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPurchaseInput, InvoiceUncheckedUpdateWithoutPurchaseInput>
    create: XOR<InvoiceCreateWithoutPurchaseInput, InvoiceUncheckedCreateWithoutPurchaseInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPurchaseInput, InvoiceUncheckedUpdateWithoutPurchaseInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPurchaseInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutPurchaseInput, InventoryTransactionUncheckedUpdateWithoutPurchaseInput>
    create: XOR<InventoryTransactionCreateWithoutPurchaseInput, InventoryTransactionUncheckedCreateWithoutPurchaseInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutPurchaseInput, InventoryTransactionUncheckedUpdateWithoutPurchaseInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutPurchaseInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseApprovalUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseApprovalWhereUniqueInput
    update: XOR<PurchaseApprovalUpdateWithoutPurchaseInput, PurchaseApprovalUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseApprovalCreateWithoutPurchaseInput, PurchaseApprovalUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseApprovalUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseApprovalWhereUniqueInput
    data: XOR<PurchaseApprovalUpdateWithoutPurchaseInput, PurchaseApprovalUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseApprovalUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseApprovalScalarWhereInput
    data: XOR<PurchaseApprovalUpdateManyMutationInput, PurchaseApprovalUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPurchaseInput, NotificationUncheckedUpdateWithoutPurchaseInput>
    create: XOR<NotificationCreateWithoutPurchaseInput, NotificationUncheckedCreateWithoutPurchaseInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPurchaseInput, NotificationUncheckedUpdateWithoutPurchaseInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPurchaseInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchaseCreateWithoutApprovalsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutApprovalsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutApprovalsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutApprovalsInput, PurchaseUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutPurchaseApprovalsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutPurchaseApprovalsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutPurchaseApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseApprovalsInput, UserUncheckedCreateWithoutPurchaseApprovalsInput>
  }

  export type NotificationCreateWithoutApprovalInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutApprovalInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutApprovalInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutApprovalInput, NotificationUncheckedCreateWithoutApprovalInput>
  }

  export type NotificationCreateManyApprovalInputEnvelope = {
    data: NotificationCreateManyApprovalInput | NotificationCreateManyApprovalInput[]
  }

  export type PurchaseUpsertWithoutApprovalsInput = {
    update: XOR<PurchaseUpdateWithoutApprovalsInput, PurchaseUncheckedUpdateWithoutApprovalsInput>
    create: XOR<PurchaseCreateWithoutApprovalsInput, PurchaseUncheckedCreateWithoutApprovalsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutApprovalsInput, PurchaseUncheckedUpdateWithoutApprovalsInput>
  }

  export type PurchaseUpdateWithoutApprovalsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutApprovalsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type UserUpsertWithoutPurchaseApprovalsInput = {
    update: XOR<UserUpdateWithoutPurchaseApprovalsInput, UserUncheckedUpdateWithoutPurchaseApprovalsInput>
    create: XOR<UserCreateWithoutPurchaseApprovalsInput, UserUncheckedCreateWithoutPurchaseApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseApprovalsInput, UserUncheckedUpdateWithoutPurchaseApprovalsInput>
  }

  export type UserUpdateWithoutPurchaseApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutApprovalInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutApprovalInput, NotificationUncheckedUpdateWithoutApprovalInput>
    create: XOR<NotificationCreateWithoutApprovalInput, NotificationUncheckedCreateWithoutApprovalInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutApprovalInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutApprovalInput, NotificationUncheckedUpdateWithoutApprovalInput>
  }

  export type NotificationUpdateManyWithWhereWithoutApprovalInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutApprovalInput>
  }

  export type PurchaseCreateWithoutContributorsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutContributorsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutContributorsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutContributorsInput, PurchaseUncheckedCreateWithoutContributorsInput>
  }

  export type UserCreateWithoutPurchaseContributionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutPurchaseContributionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutPurchaseContributionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseContributionsInput, UserUncheckedCreateWithoutPurchaseContributionsInput>
  }

  export type PaymentHistoryCreateWithoutContributorInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debt?: DebtCreateNestedOneWithoutPaymentHistoryInput
    payer: UserCreateNestedOneWithoutPaymentsMadeInput
    receiver: UserCreateNestedOneWithoutPaymentsReceivedInput
    notifications?: NotificationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryUncheckedCreateWithoutContributorInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    payerId: string
    receiverId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryCreateOrConnectWithoutContributorInput = {
    where: PaymentHistoryWhereUniqueInput
    create: XOR<PaymentHistoryCreateWithoutContributorInput, PaymentHistoryUncheckedCreateWithoutContributorInput>
  }

  export type PaymentHistoryCreateManyContributorInputEnvelope = {
    data: PaymentHistoryCreateManyContributorInput | PaymentHistoryCreateManyContributorInput[]
  }

  export type NotificationCreateWithoutContributorInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutContributorInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutContributorInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutContributorInput, NotificationUncheckedCreateWithoutContributorInput>
  }

  export type NotificationCreateManyContributorInputEnvelope = {
    data: NotificationCreateManyContributorInput | NotificationCreateManyContributorInput[]
  }

  export type PurchaseUpsertWithoutContributorsInput = {
    update: XOR<PurchaseUpdateWithoutContributorsInput, PurchaseUncheckedUpdateWithoutContributorsInput>
    create: XOR<PurchaseCreateWithoutContributorsInput, PurchaseUncheckedCreateWithoutContributorsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutContributorsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutContributorsInput, PurchaseUncheckedUpdateWithoutContributorsInput>
  }

  export type PurchaseUpdateWithoutContributorsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutContributorsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type UserUpsertWithoutPurchaseContributionsInput = {
    update: XOR<UserUpdateWithoutPurchaseContributionsInput, UserUncheckedUpdateWithoutPurchaseContributionsInput>
    create: XOR<UserCreateWithoutPurchaseContributionsInput, UserUncheckedCreateWithoutPurchaseContributionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseContributionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseContributionsInput, UserUncheckedUpdateWithoutPurchaseContributionsInput>
  }

  export type UserUpdateWithoutPurchaseContributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseContributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PaymentHistoryUpsertWithWhereUniqueWithoutContributorInput = {
    where: PaymentHistoryWhereUniqueInput
    update: XOR<PaymentHistoryUpdateWithoutContributorInput, PaymentHistoryUncheckedUpdateWithoutContributorInput>
    create: XOR<PaymentHistoryCreateWithoutContributorInput, PaymentHistoryUncheckedCreateWithoutContributorInput>
  }

  export type PaymentHistoryUpdateWithWhereUniqueWithoutContributorInput = {
    where: PaymentHistoryWhereUniqueInput
    data: XOR<PaymentHistoryUpdateWithoutContributorInput, PaymentHistoryUncheckedUpdateWithoutContributorInput>
  }

  export type PaymentHistoryUpdateManyWithWhereWithoutContributorInput = {
    where: PaymentHistoryScalarWhereInput
    data: XOR<PaymentHistoryUpdateManyMutationInput, PaymentHistoryUncheckedUpdateManyWithoutContributorInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutContributorInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutContributorInput, NotificationUncheckedUpdateWithoutContributorInput>
    create: XOR<NotificationCreateWithoutContributorInput, NotificationUncheckedCreateWithoutContributorInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutContributorInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutContributorInput, NotificationUncheckedUpdateWithoutContributorInput>
  }

  export type NotificationUpdateManyWithWhereWithoutContributorInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutContributorInput>
  }

  export type DebtCreateWithoutPaymentHistoryInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutPaymentHistoryInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutPaymentHistoryInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutPaymentHistoryInput, DebtUncheckedCreateWithoutPaymentHistoryInput>
  }

  export type PurchaseContributorCreateWithoutPaymentHistoryInput = {
    id?: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutContributorsInput
    user: UserCreateNestedOneWithoutPurchaseContributionsInput
    notifications?: NotificationCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorUncheckedCreateWithoutPaymentHistoryInput = {
    id?: string
    purchaseId: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorCreateOrConnectWithoutPaymentHistoryInput = {
    where: PurchaseContributorWhereUniqueInput
    create: XOR<PurchaseContributorCreateWithoutPaymentHistoryInput, PurchaseContributorUncheckedCreateWithoutPaymentHistoryInput>
  }

  export type UserCreateWithoutPaymentsMadeInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutPaymentsMadeInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutPaymentsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsMadeInput, UserUncheckedCreateWithoutPaymentsMadeInput>
  }

  export type UserCreateWithoutPaymentsReceivedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutPaymentsReceivedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutPaymentsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
  }

  export type NotificationCreateWithoutPaymentInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPaymentInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutPaymentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
  }

  export type NotificationCreateManyPaymentInputEnvelope = {
    data: NotificationCreateManyPaymentInput | NotificationCreateManyPaymentInput[]
  }

  export type DebtUpsertWithoutPaymentHistoryInput = {
    update: XOR<DebtUpdateWithoutPaymentHistoryInput, DebtUncheckedUpdateWithoutPaymentHistoryInput>
    create: XOR<DebtCreateWithoutPaymentHistoryInput, DebtUncheckedCreateWithoutPaymentHistoryInput>
    where?: DebtWhereInput
  }

  export type DebtUpdateToOneWithWhereWithoutPaymentHistoryInput = {
    where?: DebtWhereInput
    data: XOR<DebtUpdateWithoutPaymentHistoryInput, DebtUncheckedUpdateWithoutPaymentHistoryInput>
  }

  export type DebtUpdateWithoutPaymentHistoryInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutPaymentHistoryInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type PurchaseContributorUpsertWithoutPaymentHistoryInput = {
    update: XOR<PurchaseContributorUpdateWithoutPaymentHistoryInput, PurchaseContributorUncheckedUpdateWithoutPaymentHistoryInput>
    create: XOR<PurchaseContributorCreateWithoutPaymentHistoryInput, PurchaseContributorUncheckedCreateWithoutPaymentHistoryInput>
    where?: PurchaseContributorWhereInput
  }

  export type PurchaseContributorUpdateToOneWithWhereWithoutPaymentHistoryInput = {
    where?: PurchaseContributorWhereInput
    data: XOR<PurchaseContributorUpdateWithoutPaymentHistoryInput, PurchaseContributorUncheckedUpdateWithoutPaymentHistoryInput>
  }

  export type PurchaseContributorUpdateWithoutPaymentHistoryInput = {
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutContributorsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseContributionsNestedInput
    notifications?: NotificationUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateWithoutPaymentHistoryInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutContributorNestedInput
  }

  export type UserUpsertWithoutPaymentsMadeInput = {
    update: XOR<UserUpdateWithoutPaymentsMadeInput, UserUncheckedUpdateWithoutPaymentsMadeInput>
    create: XOR<UserCreateWithoutPaymentsMadeInput, UserUncheckedCreateWithoutPaymentsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsMadeInput, UserUncheckedUpdateWithoutPaymentsMadeInput>
  }

  export type UserUpdateWithoutPaymentsMadeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsMadeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithoutPaymentsReceivedInput = {
    update: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type UserUpdateWithoutPaymentsReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutPaymentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPaymentInput, NotificationUncheckedUpdateWithoutPaymentInput>
    create: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPaymentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPaymentInput, NotificationUncheckedUpdateWithoutPaymentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPaymentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPaymentInput>
  }

  export type SeasonCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutInventoryTransactionsInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutInventoryTransactionsInput, SeasonUncheckedCreateWithoutInventoryTransactionsInput>
  }

  export type InventoryCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageCreateNestedManyWithoutInventoryInput
    notifications?: NotificationCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipUncheckedCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryTransactionsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryTransactionsInput, InventoryUncheckedCreateWithoutInventoryTransactionsInput>
  }

  export type PurchaseCreateWithoutInventoryTransactionsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutInventoryTransactionsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutInventoryTransactionsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutInventoryTransactionsInput, PurchaseUncheckedCreateWithoutInventoryTransactionsInput>
  }

  export type UserCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutInventoryTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryTransactionsInput, UserUncheckedCreateWithoutInventoryTransactionsInput>
  }

  export type NotificationCreateWithoutTransactionInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTransactionInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutTransactionInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput>
  }

  export type NotificationCreateManyTransactionInputEnvelope = {
    data: NotificationCreateManyTransactionInput | NotificationCreateManyTransactionInput[]
  }

  export type SeasonUpsertWithoutInventoryTransactionsInput = {
    update: XOR<SeasonUpdateWithoutInventoryTransactionsInput, SeasonUncheckedUpdateWithoutInventoryTransactionsInput>
    create: XOR<SeasonCreateWithoutInventoryTransactionsInput, SeasonUncheckedCreateWithoutInventoryTransactionsInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutInventoryTransactionsInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutInventoryTransactionsInput, SeasonUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type SeasonUpdateWithoutInventoryTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutInventoryTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type InventoryUpsertWithoutInventoryTransactionsInput = {
    update: XOR<InventoryUpdateWithoutInventoryTransactionsInput, InventoryUncheckedUpdateWithoutInventoryTransactionsInput>
    create: XOR<InventoryCreateWithoutInventoryTransactionsInput, InventoryUncheckedCreateWithoutInventoryTransactionsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventoryTransactionsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventoryTransactionsInput, InventoryUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type InventoryUpdateWithoutInventoryTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUncheckedUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type PurchaseUpsertWithoutInventoryTransactionsInput = {
    update: XOR<PurchaseUpdateWithoutInventoryTransactionsInput, PurchaseUncheckedUpdateWithoutInventoryTransactionsInput>
    create: XOR<PurchaseCreateWithoutInventoryTransactionsInput, PurchaseUncheckedCreateWithoutInventoryTransactionsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutInventoryTransactionsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutInventoryTransactionsInput, PurchaseUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type PurchaseUpdateWithoutInventoryTransactionsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutInventoryTransactionsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type UserUpsertWithoutInventoryTransactionsInput = {
    update: XOR<UserUpdateWithoutInventoryTransactionsInput, UserUncheckedUpdateWithoutInventoryTransactionsInput>
    create: XOR<UserCreateWithoutInventoryTransactionsInput, UserUncheckedCreateWithoutInventoryTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryTransactionsInput, UserUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type UserUpdateWithoutInventoryTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutTransactionInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTransactionInput, NotificationUncheckedUpdateWithoutTransactionInput>
    create: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTransactionInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTransactionInput, NotificationUncheckedUpdateWithoutTransactionInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTransactionInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserCreateWithoutDebtsAsCreditorInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutDebtsAsCreditorInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutDebtsAsCreditorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtsAsCreditorInput, UserUncheckedCreateWithoutDebtsAsCreditorInput>
  }

  export type UserCreateWithoutDebtsAsDebtorInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutDebtsAsDebtorInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutDebtsAsDebtorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtsAsDebtorInput, UserUncheckedCreateWithoutDebtsAsDebtorInput>
  }

  export type InvoiceCreateWithoutDebtsInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaser: UserCreateNestedOneWithoutInvoicesPurchasedInput
    purchase?: PurchaseCreateNestedOneWithoutInvoicesInput
    notifications?: NotificationCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutDebtsInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaserId: string
    purchaseId?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutDebtsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutDebtsInput, InvoiceUncheckedCreateWithoutDebtsInput>
  }

  export type PurchaseCreateWithoutDebtsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutDebtsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutDebtsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutDebtsInput, PurchaseUncheckedCreateWithoutDebtsInput>
  }

  export type PaymentHistoryCreateWithoutDebtInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    contributor?: PurchaseContributorCreateNestedOneWithoutPaymentHistoryInput
    payer: UserCreateNestedOneWithoutPaymentsMadeInput
    receiver: UserCreateNestedOneWithoutPaymentsReceivedInput
    notifications?: NotificationCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryUncheckedCreateWithoutDebtInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    contributorId?: string | null
    payerId: string
    receiverId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentHistoryCreateOrConnectWithoutDebtInput = {
    where: PaymentHistoryWhereUniqueInput
    create: XOR<PaymentHistoryCreateWithoutDebtInput, PaymentHistoryUncheckedCreateWithoutDebtInput>
  }

  export type PaymentHistoryCreateManyDebtInputEnvelope = {
    data: PaymentHistoryCreateManyDebtInput | PaymentHistoryCreateManyDebtInput[]
  }

  export type WellBillDistributionCreateWithoutDebtInput = {
    id?: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    wellBillingPeriod: WellBillingPeriodCreateNestedOneWithoutDistributionsInput
    field: FieldCreateNestedOneWithoutWellBillDistributionsInput
    owner: UserCreateNestedOneWithoutWellBillDistributionsInput
  }

  export type WellBillDistributionUncheckedCreateWithoutDebtInput = {
    id?: string
    wellBillingPeriodId: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
  }

  export type WellBillDistributionCreateOrConnectWithoutDebtInput = {
    where: WellBillDistributionWhereUniqueInput
    create: XOR<WellBillDistributionCreateWithoutDebtInput, WellBillDistributionUncheckedCreateWithoutDebtInput>
  }

  export type WellBillDistributionCreateManyDebtInputEnvelope = {
    data: WellBillDistributionCreateManyDebtInput | WellBillDistributionCreateManyDebtInput[]
  }

  export type NotificationCreateWithoutDebtInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutDebtInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutDebtInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDebtInput, NotificationUncheckedCreateWithoutDebtInput>
  }

  export type NotificationCreateManyDebtInputEnvelope = {
    data: NotificationCreateManyDebtInput | NotificationCreateManyDebtInput[]
  }

  export type UserUpsertWithoutDebtsAsCreditorInput = {
    update: XOR<UserUpdateWithoutDebtsAsCreditorInput, UserUncheckedUpdateWithoutDebtsAsCreditorInput>
    create: XOR<UserCreateWithoutDebtsAsCreditorInput, UserUncheckedCreateWithoutDebtsAsCreditorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtsAsCreditorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtsAsCreditorInput, UserUncheckedUpdateWithoutDebtsAsCreditorInput>
  }

  export type UserUpdateWithoutDebtsAsCreditorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtsAsCreditorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithoutDebtsAsDebtorInput = {
    update: XOR<UserUpdateWithoutDebtsAsDebtorInput, UserUncheckedUpdateWithoutDebtsAsDebtorInput>
    create: XOR<UserCreateWithoutDebtsAsDebtorInput, UserUncheckedCreateWithoutDebtsAsDebtorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtsAsDebtorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtsAsDebtorInput, UserUncheckedUpdateWithoutDebtsAsDebtorInput>
  }

  export type UserUpdateWithoutDebtsAsDebtorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtsAsDebtorInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type InvoiceUpsertWithoutDebtsInput = {
    update: XOR<InvoiceUpdateWithoutDebtsInput, InvoiceUncheckedUpdateWithoutDebtsInput>
    create: XOR<InvoiceCreateWithoutDebtsInput, InvoiceUncheckedCreateWithoutDebtsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutDebtsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutDebtsInput, InvoiceUncheckedUpdateWithoutDebtsInput>
  }

  export type InvoiceUpdateWithoutDebtsInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaser?: UserUpdateOneRequiredWithoutInvoicesPurchasedNestedInput
    purchase?: PurchaseUpdateOneWithoutInvoicesNestedInput
    notifications?: NotificationUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutDebtsInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaserId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PurchaseUpsertWithoutDebtsInput = {
    update: XOR<PurchaseUpdateWithoutDebtsInput, PurchaseUncheckedUpdateWithoutDebtsInput>
    create: XOR<PurchaseCreateWithoutDebtsInput, PurchaseUncheckedCreateWithoutDebtsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutDebtsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutDebtsInput, PurchaseUncheckedUpdateWithoutDebtsInput>
  }

  export type PurchaseUpdateWithoutDebtsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutDebtsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PaymentHistoryUpsertWithWhereUniqueWithoutDebtInput = {
    where: PaymentHistoryWhereUniqueInput
    update: XOR<PaymentHistoryUpdateWithoutDebtInput, PaymentHistoryUncheckedUpdateWithoutDebtInput>
    create: XOR<PaymentHistoryCreateWithoutDebtInput, PaymentHistoryUncheckedCreateWithoutDebtInput>
  }

  export type PaymentHistoryUpdateWithWhereUniqueWithoutDebtInput = {
    where: PaymentHistoryWhereUniqueInput
    data: XOR<PaymentHistoryUpdateWithoutDebtInput, PaymentHistoryUncheckedUpdateWithoutDebtInput>
  }

  export type PaymentHistoryUpdateManyWithWhereWithoutDebtInput = {
    where: PaymentHistoryScalarWhereInput
    data: XOR<PaymentHistoryUpdateManyMutationInput, PaymentHistoryUncheckedUpdateManyWithoutDebtInput>
  }

  export type WellBillDistributionUpsertWithWhereUniqueWithoutDebtInput = {
    where: WellBillDistributionWhereUniqueInput
    update: XOR<WellBillDistributionUpdateWithoutDebtInput, WellBillDistributionUncheckedUpdateWithoutDebtInput>
    create: XOR<WellBillDistributionCreateWithoutDebtInput, WellBillDistributionUncheckedCreateWithoutDebtInput>
  }

  export type WellBillDistributionUpdateWithWhereUniqueWithoutDebtInput = {
    where: WellBillDistributionWhereUniqueInput
    data: XOR<WellBillDistributionUpdateWithoutDebtInput, WellBillDistributionUncheckedUpdateWithoutDebtInput>
  }

  export type WellBillDistributionUpdateManyWithWhereWithoutDebtInput = {
    where: WellBillDistributionScalarWhereInput
    data: XOR<WellBillDistributionUpdateManyMutationInput, WellBillDistributionUncheckedUpdateManyWithoutDebtInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutDebtInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutDebtInput, NotificationUncheckedUpdateWithoutDebtInput>
    create: XOR<NotificationCreateWithoutDebtInput, NotificationUncheckedCreateWithoutDebtInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutDebtInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutDebtInput, NotificationUncheckedUpdateWithoutDebtInput>
  }

  export type NotificationUpdateManyWithWhereWithoutDebtInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutDebtInput>
  }

  export type UserCreateWithoutInvoicesPurchasedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutInvoicesPurchasedInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutInvoicesPurchasedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesPurchasedInput, UserUncheckedCreateWithoutInvoicesPurchasedInput>
  }

  export type DebtCreateWithoutInvoiceInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutInvoiceInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    purchaseId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutInvoiceInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutInvoiceInput, DebtUncheckedCreateWithoutInvoiceInput>
  }

  export type DebtCreateManyInvoiceInputEnvelope = {
    data: DebtCreateManyInvoiceInput | DebtCreateManyInvoiceInput[]
  }

  export type PurchaseCreateWithoutInvoicesInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutInvoicesInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutInvoicesInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutInvoicesInput, PurchaseUncheckedCreateWithoutInvoicesInput>
  }

  export type NotificationCreateWithoutInvoiceInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutInvoiceInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutInvoiceInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutInvoiceInput, NotificationUncheckedCreateWithoutInvoiceInput>
  }

  export type NotificationCreateManyInvoiceInputEnvelope = {
    data: NotificationCreateManyInvoiceInput | NotificationCreateManyInvoiceInput[]
  }

  export type UserUpsertWithoutInvoicesPurchasedInput = {
    update: XOR<UserUpdateWithoutInvoicesPurchasedInput, UserUncheckedUpdateWithoutInvoicesPurchasedInput>
    create: XOR<UserCreateWithoutInvoicesPurchasedInput, UserUncheckedCreateWithoutInvoicesPurchasedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesPurchasedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesPurchasedInput, UserUncheckedUpdateWithoutInvoicesPurchasedInput>
  }

  export type UserUpdateWithoutInvoicesPurchasedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesPurchasedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type DebtUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: DebtWhereUniqueInput
    update: XOR<DebtUpdateWithoutInvoiceInput, DebtUncheckedUpdateWithoutInvoiceInput>
    create: XOR<DebtCreateWithoutInvoiceInput, DebtUncheckedCreateWithoutInvoiceInput>
  }

  export type DebtUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: DebtWhereUniqueInput
    data: XOR<DebtUpdateWithoutInvoiceInput, DebtUncheckedUpdateWithoutInvoiceInput>
  }

  export type DebtUpdateManyWithWhereWithoutInvoiceInput = {
    where: DebtScalarWhereInput
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PurchaseUpsertWithoutInvoicesInput = {
    update: XOR<PurchaseUpdateWithoutInvoicesInput, PurchaseUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PurchaseCreateWithoutInvoicesInput, PurchaseUncheckedCreateWithoutInvoicesInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutInvoicesInput, PurchaseUncheckedUpdateWithoutInvoicesInput>
  }

  export type PurchaseUpdateWithoutInvoicesInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutInvoicesInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutInvoiceInput, NotificationUncheckedUpdateWithoutInvoiceInput>
    create: XOR<NotificationCreateWithoutInvoiceInput, NotificationUncheckedCreateWithoutInvoiceInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutInvoiceInput, NotificationUncheckedUpdateWithoutInvoiceInput>
  }

  export type NotificationUpdateManyWithWhereWithoutInvoiceInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InventoryCreateWithoutUsagesInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutInventoryInput
    notifications?: NotificationCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutUsagesInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipUncheckedCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutUsagesInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutUsagesInput, InventoryUncheckedCreateWithoutUsagesInput>
  }

  export type UserCreateWithoutInventoryUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutInventoryUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutInventoryUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryUsagesInput, UserUncheckedCreateWithoutInventoryUsagesInput>
  }

  export type FieldCreateWithoutInventoryUsagesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutInventoryUsagesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutInventoryUsagesInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutInventoryUsagesInput, FieldUncheckedCreateWithoutInventoryUsagesInput>
  }

  export type ProcessCreateWithoutInventoryUsagesInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    worker: UserCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutInventoryUsagesInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutInventoryUsagesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutInventoryUsagesInput, ProcessUncheckedCreateWithoutInventoryUsagesInput>
  }

  export type NotificationCreateWithoutInventoryUsageInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutInventoryUsageInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutInventoryUsageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutInventoryUsageInput, NotificationUncheckedCreateWithoutInventoryUsageInput>
  }

  export type NotificationCreateManyInventoryUsageInputEnvelope = {
    data: NotificationCreateManyInventoryUsageInput | NotificationCreateManyInventoryUsageInput[]
  }

  export type InventoryUpsertWithoutUsagesInput = {
    update: XOR<InventoryUpdateWithoutUsagesInput, InventoryUncheckedUpdateWithoutUsagesInput>
    create: XOR<InventoryCreateWithoutUsagesInput, InventoryUncheckedCreateWithoutUsagesInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutUsagesInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutUsagesInput, InventoryUncheckedUpdateWithoutUsagesInput>
  }

  export type InventoryUpdateWithoutUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type UserUpsertWithoutInventoryUsagesInput = {
    update: XOR<UserUpdateWithoutInventoryUsagesInput, UserUncheckedUpdateWithoutInventoryUsagesInput>
    create: XOR<UserCreateWithoutInventoryUsagesInput, UserUncheckedCreateWithoutInventoryUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryUsagesInput, UserUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type UserUpdateWithoutInventoryUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type FieldUpsertWithoutInventoryUsagesInput = {
    update: XOR<FieldUpdateWithoutInventoryUsagesInput, FieldUncheckedUpdateWithoutInventoryUsagesInput>
    create: XOR<FieldCreateWithoutInventoryUsagesInput, FieldUncheckedCreateWithoutInventoryUsagesInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutInventoryUsagesInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutInventoryUsagesInput, FieldUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type FieldUpdateWithoutInventoryUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutInventoryUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type ProcessUpsertWithoutInventoryUsagesInput = {
    update: XOR<ProcessUpdateWithoutInventoryUsagesInput, ProcessUncheckedUpdateWithoutInventoryUsagesInput>
    create: XOR<ProcessCreateWithoutInventoryUsagesInput, ProcessUncheckedCreateWithoutInventoryUsagesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutInventoryUsagesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutInventoryUsagesInput, ProcessUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type ProcessUpdateWithoutInventoryUsagesInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutInventoryUsagesInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutInventoryUsageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutInventoryUsageInput, NotificationUncheckedUpdateWithoutInventoryUsageInput>
    create: XOR<NotificationCreateWithoutInventoryUsageInput, NotificationUncheckedCreateWithoutInventoryUsageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutInventoryUsageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutInventoryUsageInput, NotificationUncheckedUpdateWithoutInventoryUsageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutInventoryUsageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutInventoryUsageInput>
  }

  export type FieldCreateWithoutProcessesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutProcessesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutProcessesInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutProcessesInput, FieldUncheckedCreateWithoutProcessesInput>
  }

  export type UserCreateWithoutProcessesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutProcessesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutProcessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
  }

  export type SeasonCreateWithoutProcessesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutProcessesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutProcessesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutProcessesInput, SeasonUncheckedCreateWithoutProcessesInput>
  }

  export type InventoryUsageCreateWithoutProcessInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutUsagesInput
    usedBy: UserCreateNestedOneWithoutInventoryUsagesInput
    field?: FieldCreateNestedOneWithoutInventoryUsagesInput
    notifications?: NotificationCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageUncheckedCreateWithoutProcessInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    createdAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryUsageInput
  }

  export type InventoryUsageCreateOrConnectWithoutProcessInput = {
    where: InventoryUsageWhereUniqueInput
    create: XOR<InventoryUsageCreateWithoutProcessInput, InventoryUsageUncheckedCreateWithoutProcessInput>
  }

  export type InventoryUsageCreateManyProcessInputEnvelope = {
    data: InventoryUsageCreateManyProcessInput | InventoryUsageCreateManyProcessInput[]
  }

  export type EquipmentUsageCreateWithoutProcessInput = {
    id?: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment: EquipmentCreateNestedOneWithoutUsagesInput
    user: UserCreateNestedOneWithoutEquipmentUsagesInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageUncheckedCreateWithoutProcessInput = {
    id?: string
    equipmentId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageCreateOrConnectWithoutProcessInput = {
    where: EquipmentUsageWhereUniqueInput
    create: XOR<EquipmentUsageCreateWithoutProcessInput, EquipmentUsageUncheckedCreateWithoutProcessInput>
  }

  export type EquipmentUsageCreateManyProcessInputEnvelope = {
    data: EquipmentUsageCreateManyProcessInput | EquipmentUsageCreateManyProcessInput[]
  }

  export type ProcessCostCreateWithoutProcessInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutProcessCostsInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutProcessCostInput
    notifications?: NotificationCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostUncheckedCreateWithoutProcessInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutProcessCostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostCreateOrConnectWithoutProcessInput = {
    where: ProcessCostWhereUniqueInput
    create: XOR<ProcessCostCreateWithoutProcessInput, ProcessCostUncheckedCreateWithoutProcessInput>
  }

  export type ProcessCostCreateManyProcessInputEnvelope = {
    data: ProcessCostCreateManyProcessInput | ProcessCostCreateManyProcessInput[]
  }

  export type NotificationCreateWithoutProcessInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutProcessInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutProcessInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutProcessInput, NotificationUncheckedCreateWithoutProcessInput>
  }

  export type NotificationCreateManyProcessInputEnvelope = {
    data: NotificationCreateManyProcessInput | NotificationCreateManyProcessInput[]
  }

  export type FieldUpsertWithoutProcessesInput = {
    update: XOR<FieldUpdateWithoutProcessesInput, FieldUncheckedUpdateWithoutProcessesInput>
    create: XOR<FieldCreateWithoutProcessesInput, FieldUncheckedCreateWithoutProcessesInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutProcessesInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutProcessesInput, FieldUncheckedUpdateWithoutProcessesInput>
  }

  export type FieldUpdateWithoutProcessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutProcessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type UserUpsertWithoutProcessesInput = {
    update: XOR<UserUpdateWithoutProcessesInput, UserUncheckedUpdateWithoutProcessesInput>
    create: XOR<UserCreateWithoutProcessesInput, UserUncheckedCreateWithoutProcessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessesInput, UserUncheckedUpdateWithoutProcessesInput>
  }

  export type UserUpdateWithoutProcessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type SeasonUpsertWithoutProcessesInput = {
    update: XOR<SeasonUpdateWithoutProcessesInput, SeasonUncheckedUpdateWithoutProcessesInput>
    create: XOR<SeasonCreateWithoutProcessesInput, SeasonUncheckedCreateWithoutProcessesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutProcessesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutProcessesInput, SeasonUncheckedUpdateWithoutProcessesInput>
  }

  export type SeasonUpdateWithoutProcessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutProcessesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type InventoryUsageUpsertWithWhereUniqueWithoutProcessInput = {
    where: InventoryUsageWhereUniqueInput
    update: XOR<InventoryUsageUpdateWithoutProcessInput, InventoryUsageUncheckedUpdateWithoutProcessInput>
    create: XOR<InventoryUsageCreateWithoutProcessInput, InventoryUsageUncheckedCreateWithoutProcessInput>
  }

  export type InventoryUsageUpdateWithWhereUniqueWithoutProcessInput = {
    where: InventoryUsageWhereUniqueInput
    data: XOR<InventoryUsageUpdateWithoutProcessInput, InventoryUsageUncheckedUpdateWithoutProcessInput>
  }

  export type InventoryUsageUpdateManyWithWhereWithoutProcessInput = {
    where: InventoryUsageScalarWhereInput
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyWithoutProcessInput>
  }

  export type EquipmentUsageUpsertWithWhereUniqueWithoutProcessInput = {
    where: EquipmentUsageWhereUniqueInput
    update: XOR<EquipmentUsageUpdateWithoutProcessInput, EquipmentUsageUncheckedUpdateWithoutProcessInput>
    create: XOR<EquipmentUsageCreateWithoutProcessInput, EquipmentUsageUncheckedCreateWithoutProcessInput>
  }

  export type EquipmentUsageUpdateWithWhereUniqueWithoutProcessInput = {
    where: EquipmentUsageWhereUniqueInput
    data: XOR<EquipmentUsageUpdateWithoutProcessInput, EquipmentUsageUncheckedUpdateWithoutProcessInput>
  }

  export type EquipmentUsageUpdateManyWithWhereWithoutProcessInput = {
    where: EquipmentUsageScalarWhereInput
    data: XOR<EquipmentUsageUpdateManyMutationInput, EquipmentUsageUncheckedUpdateManyWithoutProcessInput>
  }

  export type ProcessCostUpsertWithWhereUniqueWithoutProcessInput = {
    where: ProcessCostWhereUniqueInput
    update: XOR<ProcessCostUpdateWithoutProcessInput, ProcessCostUncheckedUpdateWithoutProcessInput>
    create: XOR<ProcessCostCreateWithoutProcessInput, ProcessCostUncheckedCreateWithoutProcessInput>
  }

  export type ProcessCostUpdateWithWhereUniqueWithoutProcessInput = {
    where: ProcessCostWhereUniqueInput
    data: XOR<ProcessCostUpdateWithoutProcessInput, ProcessCostUncheckedUpdateWithoutProcessInput>
  }

  export type ProcessCostUpdateManyWithWhereWithoutProcessInput = {
    where: ProcessCostScalarWhereInput
    data: XOR<ProcessCostUpdateManyMutationInput, ProcessCostUncheckedUpdateManyWithoutProcessInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutProcessInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutProcessInput, NotificationUncheckedUpdateWithoutProcessInput>
    create: XOR<NotificationCreateWithoutProcessInput, NotificationUncheckedCreateWithoutProcessInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutProcessInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutProcessInput, NotificationUncheckedUpdateWithoutProcessInput>
  }

  export type NotificationUpdateManyWithWhereWithoutProcessInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutProcessInput>
  }

  export type UserCreateWithoutReceivedNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutReceivedNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutReceivedNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type ProcessCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    worker: UserCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutNotificationsInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutNotificationsInput, ProcessUncheckedCreateWithoutNotificationsInput>
  }

  export type DebtCreateWithoutNotificationsInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutNotificationsInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutNotificationsInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutNotificationsInput, DebtUncheckedCreateWithoutNotificationsInput>
  }

  export type PurchaseCreateWithoutNotificationsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    season?: SeasonCreateNestedOneWithoutPurchasesInput
    contributors?: PurchaseContributorCreateNestedManyWithoutPurchaseInput
    debts?: DebtCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutNotificationsInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
    seasonId?: string | null
    contributors?: PurchaseContributorUncheckedCreateNestedManyWithoutPurchaseInput
    debts?: DebtUncheckedCreateNestedManyWithoutPurchaseInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: PurchaseApprovalUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutNotificationsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutNotificationsInput, PurchaseUncheckedCreateWithoutNotificationsInput>
  }

  export type InventoryCreateWithoutNotificationsInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipUncheckedCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutNotificationsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutNotificationsInput, InventoryUncheckedCreateWithoutNotificationsInput>
  }

  export type IrrigationLogCreateWithoutNotificationsInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
  }

  export type IrrigationLogUncheckedCreateWithoutNotificationsInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
  }

  export type IrrigationLogCreateOrConnectWithoutNotificationsInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutNotificationsInput, IrrigationLogUncheckedCreateWithoutNotificationsInput>
  }

  export type FieldCreateWithoutNotificationsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutNotificationsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutNotificationsInput, FieldUncheckedCreateWithoutNotificationsInput>
  }

  export type SeasonCreateWithoutNotificationsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutNotificationsInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutNotificationsInput, SeasonUncheckedCreateWithoutNotificationsInput>
  }

  export type CropCreateWithoutNotificationsInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutCropsInput
    field: FieldCreateNestedOneWithoutCropsInput
  }

  export type CropUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldId: string
  }

  export type CropCreateOrConnectWithoutNotificationsInput = {
    where: CropWhereUniqueInput
    create: XOR<CropCreateWithoutNotificationsInput, CropUncheckedCreateWithoutNotificationsInput>
  }

  export type WellCreateWithoutNotificationsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWellInput
  }

  export type WellUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodUncheckedCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWellInput
  }

  export type WellCreateOrConnectWithoutNotificationsInput = {
    where: WellWhereUniqueInput
    create: XOR<WellCreateWithoutNotificationsInput, WellUncheckedCreateWithoutNotificationsInput>
  }

  export type ProcessingLogCreateWithoutNotificationsInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutProcessingLogsInput
  }

  export type ProcessingLogUncheckedCreateWithoutNotificationsInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type ProcessingLogCreateOrConnectWithoutNotificationsInput = {
    where: ProcessingLogWhereUniqueInput
    create: XOR<ProcessingLogCreateWithoutNotificationsInput, ProcessingLogUncheckedCreateWithoutNotificationsInput>
  }

  export type InvoiceCreateWithoutNotificationsInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaser: UserCreateNestedOneWithoutInvoicesPurchasedInput
    debts?: DebtCreateNestedManyWithoutInvoiceInput
    purchase?: PurchaseCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutNotificationsInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaserId: string
    purchaseId?: string | null
    debts?: DebtUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutNotificationsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutNotificationsInput, InvoiceUncheckedCreateWithoutNotificationsInput>
  }

  export type InventoryUsageCreateWithoutNotificationsInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutUsagesInput
    usedBy: UserCreateNestedOneWithoutInventoryUsagesInput
    field?: FieldCreateNestedOneWithoutInventoryUsagesInput
    process?: ProcessCreateNestedOneWithoutInventoryUsagesInput
  }

  export type InventoryUsageUncheckedCreateWithoutNotificationsInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageCreateOrConnectWithoutNotificationsInput = {
    where: InventoryUsageWhereUniqueInput
    create: XOR<InventoryUsageCreateWithoutNotificationsInput, InventoryUsageUncheckedCreateWithoutNotificationsInput>
  }

  export type InventoryTransactionCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    season?: SeasonCreateNestedOneWithoutInventoryTransactionsInput
    inventory: InventoryCreateNestedOneWithoutInventoryTransactionsInput
    purchase?: PurchaseCreateNestedOneWithoutInventoryTransactionsInput
    user: UserCreateNestedOneWithoutInventoryTransactionsInput
  }

  export type InventoryTransactionUncheckedCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    purchaseId?: string | null
    userId: string
  }

  export type InventoryTransactionCreateOrConnectWithoutNotificationsInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutNotificationsInput, InventoryTransactionUncheckedCreateWithoutNotificationsInput>
  }

  export type PaymentHistoryCreateWithoutNotificationsInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debt?: DebtCreateNestedOneWithoutPaymentHistoryInput
    contributor?: PurchaseContributorCreateNestedOneWithoutPaymentHistoryInput
    payer: UserCreateNestedOneWithoutPaymentsMadeInput
    receiver: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentHistoryUncheckedCreateWithoutNotificationsInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    payerId: string
    receiverId: string
  }

  export type PaymentHistoryCreateOrConnectWithoutNotificationsInput = {
    where: PaymentHistoryWhereUniqueInput
    create: XOR<PaymentHistoryCreateWithoutNotificationsInput, PaymentHistoryUncheckedCreateWithoutNotificationsInput>
  }

  export type PurchaseContributorCreateWithoutNotificationsInput = {
    id?: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutContributorsInput
    user: UserCreateNestedOneWithoutPurchaseContributionsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorUncheckedCreateWithoutNotificationsInput = {
    id?: string
    purchaseId: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutContributorInput
  }

  export type PurchaseContributorCreateOrConnectWithoutNotificationsInput = {
    where: PurchaseContributorWhereUniqueInput
    create: XOR<PurchaseContributorCreateWithoutNotificationsInput, PurchaseContributorUncheckedCreateWithoutNotificationsInput>
  }

  export type PurchaseApprovalCreateWithoutNotificationsInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutPurchaseApprovalsInput
  }

  export type PurchaseApprovalUncheckedCreateWithoutNotificationsInput = {
    id?: string
    purchaseId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseApprovalCreateOrConnectWithoutNotificationsInput = {
    where: PurchaseApprovalWhereUniqueInput
    create: XOR<PurchaseApprovalCreateWithoutNotificationsInput, PurchaseApprovalUncheckedCreateWithoutNotificationsInput>
  }

  export type EquipmentCreateWithoutNotificationsInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipCreateNestedManyWithoutEquipmentInput
    capabilities?: EquipmentCapabilityCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutEquipmentInput
    capabilities?: EquipmentCapabilityUncheckedCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutNotificationsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutNotificationsInput, EquipmentUncheckedCreateWithoutNotificationsInput>
  }

  export type EquipmentUsageCreateWithoutNotificationsInput = {
    id?: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutEquipmentUsagesInput
    equipment: EquipmentCreateNestedOneWithoutUsagesInput
    user: UserCreateNestedOneWithoutEquipmentUsagesInput
  }

  export type EquipmentUsageUncheckedCreateWithoutNotificationsInput = {
    id?: string
    processId: string
    equipmentId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUsageCreateOrConnectWithoutNotificationsInput = {
    where: EquipmentUsageWhereUniqueInput
    create: XOR<EquipmentUsageCreateWithoutNotificationsInput, EquipmentUsageUncheckedCreateWithoutNotificationsInput>
  }

  export type ProcessCostCreateWithoutNotificationsInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutProcessCostsInput
    field: FieldCreateNestedOneWithoutProcessCostsInput
    ownerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostUncheckedCreateWithoutNotificationsInput = {
    id?: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    ownerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostCreateOrConnectWithoutNotificationsInput = {
    where: ProcessCostWhereUniqueInput
    create: XOR<ProcessCostCreateWithoutNotificationsInput, ProcessCostUncheckedCreateWithoutNotificationsInput>
  }

  export type FieldExpenseCreateWithoutNotificationsInput = {
    id?: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    field: FieldCreateNestedOneWithoutFieldExpensesInput
    season: SeasonCreateNestedOneWithoutFieldExpensesInput
  }

  export type FieldExpenseUncheckedCreateWithoutNotificationsInput = {
    id?: string
    fieldId: string
    seasonId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldExpenseCreateOrConnectWithoutNotificationsInput = {
    where: FieldExpenseWhereUniqueInput
    create: XOR<FieldExpenseCreateWithoutNotificationsInput, FieldExpenseUncheckedCreateWithoutNotificationsInput>
  }

  export type FieldOwnerExpenseCreateWithoutNotificationsInput = {
    id?: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldOwnership: FieldOwnershipCreateNestedOneWithoutOwnerExpensesInput
    processCost: ProcessCostCreateNestedOneWithoutOwnerExpensesInput
    user: UserCreateNestedOneWithoutFieldOwnerExpensesInput
  }

  export type FieldOwnerExpenseUncheckedCreateWithoutNotificationsInput = {
    id?: string
    fieldOwnershipId: string
    processCostId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldOwnerExpenseCreateOrConnectWithoutNotificationsInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    create: XOR<FieldOwnerExpenseCreateWithoutNotificationsInput, FieldOwnerExpenseUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutReceivedNotificationsInput = {
    update: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserUpdateWithoutReceivedNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type ProcessUpsertWithoutNotificationsInput = {
    update: XOR<ProcessUpdateWithoutNotificationsInput, ProcessUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProcessCreateWithoutNotificationsInput, ProcessUncheckedCreateWithoutNotificationsInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutNotificationsInput, ProcessUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProcessUpdateWithoutNotificationsInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutNotificationsInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type DebtUpsertWithoutNotificationsInput = {
    update: XOR<DebtUpdateWithoutNotificationsInput, DebtUncheckedUpdateWithoutNotificationsInput>
    create: XOR<DebtCreateWithoutNotificationsInput, DebtUncheckedCreateWithoutNotificationsInput>
    where?: DebtWhereInput
  }

  export type DebtUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: DebtWhereInput
    data: XOR<DebtUpdateWithoutNotificationsInput, DebtUncheckedUpdateWithoutNotificationsInput>
  }

  export type DebtUpdateWithoutNotificationsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutNotificationsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type PurchaseUpsertWithoutNotificationsInput = {
    update: XOR<PurchaseUpdateWithoutNotificationsInput, PurchaseUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PurchaseCreateWithoutNotificationsInput, PurchaseUncheckedCreateWithoutNotificationsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutNotificationsInput, PurchaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type PurchaseUpdateWithoutNotificationsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    season?: SeasonUpdateOneWithoutPurchasesNestedInput
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutNotificationsInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type InventoryUpsertWithoutNotificationsInput = {
    update: XOR<InventoryUpdateWithoutNotificationsInput, InventoryUncheckedUpdateWithoutNotificationsInput>
    create: XOR<InventoryCreateWithoutNotificationsInput, InventoryUncheckedCreateWithoutNotificationsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutNotificationsInput, InventoryUncheckedUpdateWithoutNotificationsInput>
  }

  export type InventoryUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUncheckedUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutInventoryNestedInput
    irrigationInventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type IrrigationLogUpsertWithoutNotificationsInput = {
    update: XOR<IrrigationLogUpdateWithoutNotificationsInput, IrrigationLogUncheckedUpdateWithoutNotificationsInput>
    create: XOR<IrrigationLogCreateWithoutNotificationsInput, IrrigationLogUncheckedCreateWithoutNotificationsInput>
    where?: IrrigationLogWhereInput
  }

  export type IrrigationLogUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: IrrigationLogWhereInput
    data: XOR<IrrigationLogUpdateWithoutNotificationsInput, IrrigationLogUncheckedUpdateWithoutNotificationsInput>
  }

  export type IrrigationLogUpdateWithoutNotificationsInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutNotificationsInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
  }

  export type FieldUpsertWithoutNotificationsInput = {
    update: XOR<FieldUpdateWithoutNotificationsInput, FieldUncheckedUpdateWithoutNotificationsInput>
    create: XOR<FieldCreateWithoutNotificationsInput, FieldUncheckedCreateWithoutNotificationsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutNotificationsInput, FieldUncheckedUpdateWithoutNotificationsInput>
  }

  export type FieldUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type SeasonUpsertWithoutNotificationsInput = {
    update: XOR<SeasonUpdateWithoutNotificationsInput, SeasonUncheckedUpdateWithoutNotificationsInput>
    create: XOR<SeasonCreateWithoutNotificationsInput, SeasonUncheckedCreateWithoutNotificationsInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutNotificationsInput, SeasonUncheckedUpdateWithoutNotificationsInput>
  }

  export type SeasonUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type CropUpsertWithoutNotificationsInput = {
    update: XOR<CropUpdateWithoutNotificationsInput, CropUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CropCreateWithoutNotificationsInput, CropUncheckedCreateWithoutNotificationsInput>
    where?: CropWhereInput
  }

  export type CropUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CropWhereInput
    data: XOR<CropUpdateWithoutNotificationsInput, CropUncheckedUpdateWithoutNotificationsInput>
  }

  export type CropUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutCropsNestedInput
    field?: FieldUpdateOneRequiredWithoutCropsNestedInput
  }

  export type CropUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type WellUpsertWithoutNotificationsInput = {
    update: XOR<WellUpdateWithoutNotificationsInput, WellUncheckedUpdateWithoutNotificationsInput>
    create: XOR<WellCreateWithoutNotificationsInput, WellUncheckedCreateWithoutNotificationsInput>
    where?: WellWhereInput
  }

  export type WellUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: WellWhereInput
    data: XOR<WellUpdateWithoutNotificationsInput, WellUncheckedUpdateWithoutNotificationsInput>
  }

  export type WellUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUpdateManyWithoutWellNestedInput
  }

  export type WellUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUncheckedUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUncheckedUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWellNestedInput
  }

  export type ProcessingLogUpsertWithoutNotificationsInput = {
    update: XOR<ProcessingLogUpdateWithoutNotificationsInput, ProcessingLogUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProcessingLogCreateWithoutNotificationsInput, ProcessingLogUncheckedCreateWithoutNotificationsInput>
    where?: ProcessingLogWhereInput
  }

  export type ProcessingLogUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProcessingLogWhereInput
    data: XOR<ProcessingLogUpdateWithoutNotificationsInput, ProcessingLogUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProcessingLogUpdateWithoutNotificationsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutProcessingLogsNestedInput
  }

  export type ProcessingLogUncheckedUpdateWithoutNotificationsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpsertWithoutNotificationsInput = {
    update: XOR<InvoiceUpdateWithoutNotificationsInput, InvoiceUncheckedUpdateWithoutNotificationsInput>
    create: XOR<InvoiceCreateWithoutNotificationsInput, InvoiceUncheckedCreateWithoutNotificationsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutNotificationsInput, InvoiceUncheckedUpdateWithoutNotificationsInput>
  }

  export type InvoiceUpdateWithoutNotificationsInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaser?: UserUpdateOneRequiredWithoutInvoicesPurchasedNestedInput
    debts?: DebtUpdateManyWithoutInvoiceNestedInput
    purchase?: PurchaseUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutNotificationsInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaserId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    debts?: DebtUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InventoryUsageUpsertWithoutNotificationsInput = {
    update: XOR<InventoryUsageUpdateWithoutNotificationsInput, InventoryUsageUncheckedUpdateWithoutNotificationsInput>
    create: XOR<InventoryUsageCreateWithoutNotificationsInput, InventoryUsageUncheckedCreateWithoutNotificationsInput>
    where?: InventoryUsageWhereInput
  }

  export type InventoryUsageUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: InventoryUsageWhereInput
    data: XOR<InventoryUsageUpdateWithoutNotificationsInput, InventoryUsageUncheckedUpdateWithoutNotificationsInput>
  }

  export type InventoryUsageUpdateWithoutNotificationsInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutUsagesNestedInput
    usedBy?: UserUpdateOneRequiredWithoutInventoryUsagesNestedInput
    field?: FieldUpdateOneWithoutInventoryUsagesNestedInput
    process?: ProcessUpdateOneWithoutInventoryUsagesNestedInput
  }

  export type InventoryUsageUncheckedUpdateWithoutNotificationsInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpsertWithoutNotificationsInput = {
    update: XOR<InventoryTransactionUpdateWithoutNotificationsInput, InventoryTransactionUncheckedUpdateWithoutNotificationsInput>
    create: XOR<InventoryTransactionCreateWithoutNotificationsInput, InventoryTransactionUncheckedCreateWithoutNotificationsInput>
    where?: InventoryTransactionWhereInput
  }

  export type InventoryTransactionUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: InventoryTransactionWhereInput
    data: XOR<InventoryTransactionUpdateWithoutNotificationsInput, InventoryTransactionUncheckedUpdateWithoutNotificationsInput>
  }

  export type InventoryTransactionUpdateWithoutNotificationsInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutInventoryTransactionsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutInventoryTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryTransactionsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutNotificationsInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentHistoryUpsertWithoutNotificationsInput = {
    update: XOR<PaymentHistoryUpdateWithoutNotificationsInput, PaymentHistoryUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PaymentHistoryCreateWithoutNotificationsInput, PaymentHistoryUncheckedCreateWithoutNotificationsInput>
    where?: PaymentHistoryWhereInput
  }

  export type PaymentHistoryUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PaymentHistoryWhereInput
    data: XOR<PaymentHistoryUpdateWithoutNotificationsInput, PaymentHistoryUncheckedUpdateWithoutNotificationsInput>
  }

  export type PaymentHistoryUpdateWithoutNotificationsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneWithoutPaymentHistoryNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutPaymentHistoryNestedInput
    payer?: UserUpdateOneRequiredWithoutPaymentsMadeNestedInput
    receiver?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
  }

  export type PaymentHistoryUncheckedUpdateWithoutNotificationsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseContributorUpsertWithoutNotificationsInput = {
    update: XOR<PurchaseContributorUpdateWithoutNotificationsInput, PurchaseContributorUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PurchaseContributorCreateWithoutNotificationsInput, PurchaseContributorUncheckedCreateWithoutNotificationsInput>
    where?: PurchaseContributorWhereInput
  }

  export type PurchaseContributorUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PurchaseContributorWhereInput
    data: XOR<PurchaseContributorUpdateWithoutNotificationsInput, PurchaseContributorUncheckedUpdateWithoutNotificationsInput>
  }

  export type PurchaseContributorUpdateWithoutNotificationsInput = {
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutContributorsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseContributionsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateWithoutNotificationsInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseApprovalUpsertWithoutNotificationsInput = {
    update: XOR<PurchaseApprovalUpdateWithoutNotificationsInput, PurchaseApprovalUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PurchaseApprovalCreateWithoutNotificationsInput, PurchaseApprovalUncheckedCreateWithoutNotificationsInput>
    where?: PurchaseApprovalWhereInput
  }

  export type PurchaseApprovalUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PurchaseApprovalWhereInput
    data: XOR<PurchaseApprovalUpdateWithoutNotificationsInput, PurchaseApprovalUncheckedUpdateWithoutNotificationsInput>
  }

  export type PurchaseApprovalUpdateWithoutNotificationsInput = {
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutPurchaseApprovalsNestedInput
  }

  export type PurchaseApprovalUncheckedUpdateWithoutNotificationsInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpsertWithoutNotificationsInput = {
    update: XOR<EquipmentUpdateWithoutNotificationsInput, EquipmentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<EquipmentCreateWithoutNotificationsInput, EquipmentUncheckedCreateWithoutNotificationsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutNotificationsInput, EquipmentUncheckedUpdateWithoutNotificationsInput>
  }

  export type EquipmentUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUpdateManyWithoutEquipmentNestedInput
    capabilities?: EquipmentCapabilityUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentNestedInput
    capabilities?: EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUsageUpsertWithoutNotificationsInput = {
    update: XOR<EquipmentUsageUpdateWithoutNotificationsInput, EquipmentUsageUncheckedUpdateWithoutNotificationsInput>
    create: XOR<EquipmentUsageCreateWithoutNotificationsInput, EquipmentUsageUncheckedCreateWithoutNotificationsInput>
    where?: EquipmentUsageWhereInput
  }

  export type EquipmentUsageUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: EquipmentUsageWhereInput
    data: XOR<EquipmentUsageUpdateWithoutNotificationsInput, EquipmentUsageUncheckedUpdateWithoutNotificationsInput>
  }

  export type EquipmentUsageUpdateWithoutNotificationsInput = {
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutUsagesNestedInput
    user?: UserUpdateOneRequiredWithoutEquipmentUsagesNestedInput
  }

  export type EquipmentUsageUncheckedUpdateWithoutNotificationsInput = {
    processId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCostUpsertWithoutNotificationsInput = {
    update: XOR<ProcessCostUpdateWithoutNotificationsInput, ProcessCostUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProcessCostCreateWithoutNotificationsInput, ProcessCostUncheckedCreateWithoutNotificationsInput>
    where?: ProcessCostWhereInput
  }

  export type ProcessCostUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProcessCostWhereInput
    data: XOR<ProcessCostUpdateWithoutNotificationsInput, ProcessCostUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProcessCostUpdateWithoutNotificationsInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutProcessCostsNestedInput
    field?: FieldUpdateOneRequiredWithoutProcessCostsNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateWithoutNotificationsInput = {
    processId?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostNestedInput
  }

  export type FieldExpenseUpsertWithoutNotificationsInput = {
    update: XOR<FieldExpenseUpdateWithoutNotificationsInput, FieldExpenseUncheckedUpdateWithoutNotificationsInput>
    create: XOR<FieldExpenseCreateWithoutNotificationsInput, FieldExpenseUncheckedCreateWithoutNotificationsInput>
    where?: FieldExpenseWhereInput
  }

  export type FieldExpenseUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: FieldExpenseWhereInput
    data: XOR<FieldExpenseUpdateWithoutNotificationsInput, FieldExpenseUncheckedUpdateWithoutNotificationsInput>
  }

  export type FieldExpenseUpdateWithoutNotificationsInput = {
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldExpensesNestedInput
    season?: SeasonUpdateOneRequiredWithoutFieldExpensesNestedInput
  }

  export type FieldExpenseUncheckedUpdateWithoutNotificationsInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOwnerExpenseUpsertWithoutNotificationsInput = {
    update: XOR<FieldOwnerExpenseUpdateWithoutNotificationsInput, FieldOwnerExpenseUncheckedUpdateWithoutNotificationsInput>
    create: XOR<FieldOwnerExpenseCreateWithoutNotificationsInput, FieldOwnerExpenseUncheckedCreateWithoutNotificationsInput>
    where?: FieldOwnerExpenseWhereInput
  }

  export type FieldOwnerExpenseUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: FieldOwnerExpenseWhereInput
    data: XOR<FieldOwnerExpenseUpdateWithoutNotificationsInput, FieldOwnerExpenseUncheckedUpdateWithoutNotificationsInput>
  }

  export type FieldOwnerExpenseUpdateWithoutNotificationsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldOwnership?: FieldOwnershipUpdateOneRequiredWithoutOwnerExpensesNestedInput
    processCost?: ProcessCostUpdateOneRequiredWithoutOwnerExpensesNestedInput
    user?: UserUpdateOneRequiredWithoutFieldOwnerExpensesNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateWithoutNotificationsInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    processCostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationPreferencesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserUpdateWithoutNotificationPreferencesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferencesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type EquipmentOwnershipCreateWithoutEquipmentInput = {
    id?: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEquipmentOwnershipsInput
  }

  export type EquipmentOwnershipUncheckedCreateWithoutEquipmentInput = {
    id?: string
    userId: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentOwnershipCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentOwnershipWhereUniqueInput
    create: XOR<EquipmentOwnershipCreateWithoutEquipmentInput, EquipmentOwnershipUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentOwnershipCreateManyEquipmentInputEnvelope = {
    data: EquipmentOwnershipCreateManyEquipmentInput | EquipmentOwnershipCreateManyEquipmentInput[]
  }

  export type EquipmentCapabilityCreateWithoutEquipmentInput = {
    id?: string
    inventoryCategory: $Enums.InventoryCategory
    canUse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCapabilityUncheckedCreateWithoutEquipmentInput = {
    id?: string
    inventoryCategory: $Enums.InventoryCategory
    canUse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCapabilityCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentCapabilityWhereUniqueInput
    create: XOR<EquipmentCapabilityCreateWithoutEquipmentInput, EquipmentCapabilityUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentCapabilityCreateManyEquipmentInputEnvelope = {
    data: EquipmentCapabilityCreateManyEquipmentInput | EquipmentCapabilityCreateManyEquipmentInput[]
  }

  export type EquipmentUsageCreateWithoutEquipmentInput = {
    id?: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutEquipmentUsagesInput
    user: UserCreateNestedOneWithoutEquipmentUsagesInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageUncheckedCreateWithoutEquipmentInput = {
    id?: string
    processId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentUsageInput
  }

  export type EquipmentUsageCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentUsageWhereUniqueInput
    create: XOR<EquipmentUsageCreateWithoutEquipmentInput, EquipmentUsageUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentUsageCreateManyEquipmentInputEnvelope = {
    data: EquipmentUsageCreateManyEquipmentInput | EquipmentUsageCreateManyEquipmentInput[]
  }

  export type NotificationCreateWithoutEquipmentInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutEquipmentInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutEquipmentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutEquipmentInput, NotificationUncheckedCreateWithoutEquipmentInput>
  }

  export type NotificationCreateManyEquipmentInputEnvelope = {
    data: NotificationCreateManyEquipmentInput | NotificationCreateManyEquipmentInput[]
  }

  export type EquipmentOwnershipUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentOwnershipWhereUniqueInput
    update: XOR<EquipmentOwnershipUpdateWithoutEquipmentInput, EquipmentOwnershipUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentOwnershipCreateWithoutEquipmentInput, EquipmentOwnershipUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentOwnershipUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentOwnershipWhereUniqueInput
    data: XOR<EquipmentOwnershipUpdateWithoutEquipmentInput, EquipmentOwnershipUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentOwnershipUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentOwnershipScalarWhereInput
    data: XOR<EquipmentOwnershipUpdateManyMutationInput, EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentCapabilityUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentCapabilityWhereUniqueInput
    update: XOR<EquipmentCapabilityUpdateWithoutEquipmentInput, EquipmentCapabilityUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentCapabilityCreateWithoutEquipmentInput, EquipmentCapabilityUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentCapabilityUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentCapabilityWhereUniqueInput
    data: XOR<EquipmentCapabilityUpdateWithoutEquipmentInput, EquipmentCapabilityUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentCapabilityUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentCapabilityScalarWhereInput
    data: XOR<EquipmentCapabilityUpdateManyMutationInput, EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentCapabilityScalarWhereInput = {
    AND?: EquipmentCapabilityScalarWhereInput | EquipmentCapabilityScalarWhereInput[]
    OR?: EquipmentCapabilityScalarWhereInput[]
    NOT?: EquipmentCapabilityScalarWhereInput | EquipmentCapabilityScalarWhereInput[]
    id?: StringFilter<"EquipmentCapability"> | string
    equipmentId?: StringFilter<"EquipmentCapability"> | string
    inventoryCategory?: EnumInventoryCategoryFilter<"EquipmentCapability"> | $Enums.InventoryCategory
    canUse?: BoolFilter<"EquipmentCapability"> | boolean
    createdAt?: DateTimeFilter<"EquipmentCapability"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentCapability"> | Date | string
  }

  export type EquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentUsageWhereUniqueInput
    update: XOR<EquipmentUsageUpdateWithoutEquipmentInput, EquipmentUsageUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentUsageCreateWithoutEquipmentInput, EquipmentUsageUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentUsageWhereUniqueInput
    data: XOR<EquipmentUsageUpdateWithoutEquipmentInput, EquipmentUsageUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentUsageUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentUsageScalarWhereInput
    data: XOR<EquipmentUsageUpdateManyMutationInput, EquipmentUsageUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutEquipmentInput, NotificationUncheckedUpdateWithoutEquipmentInput>
    create: XOR<NotificationCreateWithoutEquipmentInput, NotificationUncheckedCreateWithoutEquipmentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutEquipmentInput, NotificationUncheckedUpdateWithoutEquipmentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutEquipmentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentCreateWithoutOwnershipsInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: EquipmentCapabilityCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutOwnershipsInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: EquipmentCapabilityUncheckedCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutOwnershipsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutOwnershipsInput, EquipmentUncheckedCreateWithoutOwnershipsInput>
  }

  export type UserCreateWithoutEquipmentOwnershipsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutEquipmentOwnershipsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutEquipmentOwnershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEquipmentOwnershipsInput, UserUncheckedCreateWithoutEquipmentOwnershipsInput>
  }

  export type EquipmentUpsertWithoutOwnershipsInput = {
    update: XOR<EquipmentUpdateWithoutOwnershipsInput, EquipmentUncheckedUpdateWithoutOwnershipsInput>
    create: XOR<EquipmentCreateWithoutOwnershipsInput, EquipmentUncheckedCreateWithoutOwnershipsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutOwnershipsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutOwnershipsInput, EquipmentUncheckedUpdateWithoutOwnershipsInput>
  }

  export type EquipmentUpdateWithoutOwnershipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: EquipmentCapabilityUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutOwnershipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type UserUpsertWithoutEquipmentOwnershipsInput = {
    update: XOR<UserUpdateWithoutEquipmentOwnershipsInput, UserUncheckedUpdateWithoutEquipmentOwnershipsInput>
    create: XOR<UserCreateWithoutEquipmentOwnershipsInput, UserUncheckedCreateWithoutEquipmentOwnershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEquipmentOwnershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEquipmentOwnershipsInput, UserUncheckedUpdateWithoutEquipmentOwnershipsInput>
  }

  export type UserUpdateWithoutEquipmentOwnershipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutEquipmentOwnershipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type EquipmentCreateWithoutCapabilitiesInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutCapabilitiesInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutEquipmentInput
    usages?: EquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutCapabilitiesInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutCapabilitiesInput, EquipmentUncheckedCreateWithoutCapabilitiesInput>
  }

  export type EquipmentUpsertWithoutCapabilitiesInput = {
    update: XOR<EquipmentUpdateWithoutCapabilitiesInput, EquipmentUncheckedUpdateWithoutCapabilitiesInput>
    create: XOR<EquipmentCreateWithoutCapabilitiesInput, EquipmentUncheckedCreateWithoutCapabilitiesInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutCapabilitiesInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutCapabilitiesInput, EquipmentUncheckedUpdateWithoutCapabilitiesInput>
  }

  export type EquipmentUpdateWithoutCapabilitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutCapabilitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentNestedInput
    usages?: EquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type ProcessCreateWithoutEquipmentUsagesInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    worker: UserCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutEquipmentUsagesInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutEquipmentUsagesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutEquipmentUsagesInput, ProcessUncheckedCreateWithoutEquipmentUsagesInput>
  }

  export type EquipmentCreateWithoutUsagesInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipCreateNestedManyWithoutEquipmentInput
    capabilities?: EquipmentCapabilityCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutUsagesInput = {
    id?: string
    name: string
    type: $Enums.EquipmentType
    fuelConsumptionPerDecare: number
    description?: string | null
    status?: $Enums.EquipmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutEquipmentInput
    capabilities?: EquipmentCapabilityUncheckedCreateNestedManyWithoutEquipmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutUsagesInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutUsagesInput, EquipmentUncheckedCreateWithoutUsagesInput>
  }

  export type UserCreateWithoutEquipmentUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutEquipmentUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutEquipmentUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEquipmentUsagesInput, UserUncheckedCreateWithoutEquipmentUsagesInput>
  }

  export type NotificationCreateWithoutEquipmentUsageInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutEquipmentUsageInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutEquipmentUsageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutEquipmentUsageInput, NotificationUncheckedCreateWithoutEquipmentUsageInput>
  }

  export type NotificationCreateManyEquipmentUsageInputEnvelope = {
    data: NotificationCreateManyEquipmentUsageInput | NotificationCreateManyEquipmentUsageInput[]
  }

  export type ProcessUpsertWithoutEquipmentUsagesInput = {
    update: XOR<ProcessUpdateWithoutEquipmentUsagesInput, ProcessUncheckedUpdateWithoutEquipmentUsagesInput>
    create: XOR<ProcessCreateWithoutEquipmentUsagesInput, ProcessUncheckedCreateWithoutEquipmentUsagesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutEquipmentUsagesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutEquipmentUsagesInput, ProcessUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type ProcessUpdateWithoutEquipmentUsagesInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutEquipmentUsagesInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type EquipmentUpsertWithoutUsagesInput = {
    update: XOR<EquipmentUpdateWithoutUsagesInput, EquipmentUncheckedUpdateWithoutUsagesInput>
    create: XOR<EquipmentCreateWithoutUsagesInput, EquipmentUncheckedCreateWithoutUsagesInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutUsagesInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutUsagesInput, EquipmentUncheckedUpdateWithoutUsagesInput>
  }

  export type EquipmentUpdateWithoutUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUpdateManyWithoutEquipmentNestedInput
    capabilities?: EquipmentCapabilityUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEquipmentTypeFieldUpdateOperationsInput | $Enums.EquipmentType
    fuelConsumptionPerDecare?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentNestedInput
    capabilities?: EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type UserUpsertWithoutEquipmentUsagesInput = {
    update: XOR<UserUpdateWithoutEquipmentUsagesInput, UserUncheckedUpdateWithoutEquipmentUsagesInput>
    create: XOR<UserCreateWithoutEquipmentUsagesInput, UserUncheckedCreateWithoutEquipmentUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEquipmentUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEquipmentUsagesInput, UserUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type UserUpdateWithoutEquipmentUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutEquipmentUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutEquipmentUsageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutEquipmentUsageInput, NotificationUncheckedUpdateWithoutEquipmentUsageInput>
    create: XOR<NotificationCreateWithoutEquipmentUsageInput, NotificationUncheckedCreateWithoutEquipmentUsageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutEquipmentUsageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutEquipmentUsageInput, NotificationUncheckedUpdateWithoutEquipmentUsageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutEquipmentUsageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutEquipmentUsageInput>
  }

  export type ProcessCreateWithoutProcessCostsInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    field?: FieldCreateNestedOneWithoutProcessesInput
    worker: UserCreateNestedOneWithoutProcessesInput
    season?: SeasonCreateNestedOneWithoutProcessesInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutProcessInput
    notifications?: NotificationCreateNestedManyWithoutProcessInput
  }

  export type ProcessUncheckedCreateWithoutProcessCostsInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutProcessInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutProcessInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutProcessCostsInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutProcessCostsInput, ProcessUncheckedCreateWithoutProcessCostsInput>
  }

  export type FieldCreateWithoutProcessCostsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutProcessCostsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutProcessCostsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutProcessCostsInput, FieldUncheckedCreateWithoutProcessCostsInput>
  }

  export type FieldOwnerExpenseCreateWithoutProcessCostInput = {
    id?: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldOwnership: FieldOwnershipCreateNestedOneWithoutOwnerExpensesInput
    user: UserCreateNestedOneWithoutFieldOwnerExpensesInput
    notifications?: NotificationCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput = {
    id?: string
    fieldOwnershipId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutOwnerExpenseInput
  }

  export type FieldOwnerExpenseCreateOrConnectWithoutProcessCostInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    create: XOR<FieldOwnerExpenseCreateWithoutProcessCostInput, FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput>
  }

  export type FieldOwnerExpenseCreateManyProcessCostInputEnvelope = {
    data: FieldOwnerExpenseCreateManyProcessCostInput | FieldOwnerExpenseCreateManyProcessCostInput[]
  }

  export type NotificationCreateWithoutProcessCostInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutProcessCostInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutProcessCostInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutProcessCostInput, NotificationUncheckedCreateWithoutProcessCostInput>
  }

  export type NotificationCreateManyProcessCostInputEnvelope = {
    data: NotificationCreateManyProcessCostInput | NotificationCreateManyProcessCostInput[]
  }

  export type ProcessUpsertWithoutProcessCostsInput = {
    update: XOR<ProcessUpdateWithoutProcessCostsInput, ProcessUncheckedUpdateWithoutProcessCostsInput>
    create: XOR<ProcessCreateWithoutProcessCostsInput, ProcessUncheckedCreateWithoutProcessCostsInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutProcessCostsInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutProcessCostsInput, ProcessUncheckedUpdateWithoutProcessCostsInput>
  }

  export type ProcessUpdateWithoutProcessCostsInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutProcessCostsInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type FieldUpsertWithoutProcessCostsInput = {
    update: XOR<FieldUpdateWithoutProcessCostsInput, FieldUncheckedUpdateWithoutProcessCostsInput>
    create: XOR<FieldCreateWithoutProcessCostsInput, FieldUncheckedCreateWithoutProcessCostsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutProcessCostsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutProcessCostsInput, FieldUncheckedUpdateWithoutProcessCostsInput>
  }

  export type FieldUpdateWithoutProcessCostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutProcessCostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FieldOwnerExpenseUpsertWithWhereUniqueWithoutProcessCostInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    update: XOR<FieldOwnerExpenseUpdateWithoutProcessCostInput, FieldOwnerExpenseUncheckedUpdateWithoutProcessCostInput>
    create: XOR<FieldOwnerExpenseCreateWithoutProcessCostInput, FieldOwnerExpenseUncheckedCreateWithoutProcessCostInput>
  }

  export type FieldOwnerExpenseUpdateWithWhereUniqueWithoutProcessCostInput = {
    where: FieldOwnerExpenseWhereUniqueInput
    data: XOR<FieldOwnerExpenseUpdateWithoutProcessCostInput, FieldOwnerExpenseUncheckedUpdateWithoutProcessCostInput>
  }

  export type FieldOwnerExpenseUpdateManyWithWhereWithoutProcessCostInput = {
    where: FieldOwnerExpenseScalarWhereInput
    data: XOR<FieldOwnerExpenseUpdateManyMutationInput, FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutProcessCostInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutProcessCostInput, NotificationUncheckedUpdateWithoutProcessCostInput>
    create: XOR<NotificationCreateWithoutProcessCostInput, NotificationUncheckedCreateWithoutProcessCostInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutProcessCostInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutProcessCostInput, NotificationUncheckedUpdateWithoutProcessCostInput>
  }

  export type NotificationUpdateManyWithWhereWithoutProcessCostInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutProcessCostInput>
  }

  export type FieldCreateWithoutFieldExpensesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutFieldExpensesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutFieldExpensesInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFieldExpensesInput, FieldUncheckedCreateWithoutFieldExpensesInput>
  }

  export type SeasonCreateWithoutFieldExpensesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutFieldExpensesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutFieldExpensesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutFieldExpensesInput, SeasonUncheckedCreateWithoutFieldExpensesInput>
  }

  export type NotificationCreateWithoutFieldExpenseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutFieldExpenseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutFieldExpenseInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutFieldExpenseInput, NotificationUncheckedCreateWithoutFieldExpenseInput>
  }

  export type NotificationCreateManyFieldExpenseInputEnvelope = {
    data: NotificationCreateManyFieldExpenseInput | NotificationCreateManyFieldExpenseInput[]
  }

  export type FieldUpsertWithoutFieldExpensesInput = {
    update: XOR<FieldUpdateWithoutFieldExpensesInput, FieldUncheckedUpdateWithoutFieldExpensesInput>
    create: XOR<FieldCreateWithoutFieldExpensesInput, FieldUncheckedCreateWithoutFieldExpensesInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFieldExpensesInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFieldExpensesInput, FieldUncheckedUpdateWithoutFieldExpensesInput>
  }

  export type FieldUpdateWithoutFieldExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFieldExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type SeasonUpsertWithoutFieldExpensesInput = {
    update: XOR<SeasonUpdateWithoutFieldExpensesInput, SeasonUncheckedUpdateWithoutFieldExpensesInput>
    create: XOR<SeasonCreateWithoutFieldExpensesInput, SeasonUncheckedCreateWithoutFieldExpensesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutFieldExpensesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutFieldExpensesInput, SeasonUncheckedUpdateWithoutFieldExpensesInput>
  }

  export type SeasonUpdateWithoutFieldExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutFieldExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutFieldExpenseInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutFieldExpenseInput, NotificationUncheckedUpdateWithoutFieldExpenseInput>
    create: XOR<NotificationCreateWithoutFieldExpenseInput, NotificationUncheckedCreateWithoutFieldExpenseInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutFieldExpenseInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutFieldExpenseInput, NotificationUncheckedUpdateWithoutFieldExpenseInput>
  }

  export type NotificationUpdateManyWithWhereWithoutFieldExpenseInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutFieldExpenseInput>
  }

  export type FieldOwnershipCreateWithoutOwnerExpensesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    field: FieldCreateNestedOneWithoutOwnersInput
    user: UserCreateNestedOneWithoutOwnedFieldsInput
  }

  export type FieldOwnershipUncheckedCreateWithoutOwnerExpensesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    fieldId: string
    userId: string
  }

  export type FieldOwnershipCreateOrConnectWithoutOwnerExpensesInput = {
    where: FieldOwnershipWhereUniqueInput
    create: XOR<FieldOwnershipCreateWithoutOwnerExpensesInput, FieldOwnershipUncheckedCreateWithoutOwnerExpensesInput>
  }

  export type ProcessCostCreateWithoutOwnerExpensesInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutProcessCostsInput
    field: FieldCreateNestedOneWithoutProcessCostsInput
    notifications?: NotificationCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostUncheckedCreateWithoutOwnerExpensesInput = {
    id?: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutProcessCostInput
  }

  export type ProcessCostCreateOrConnectWithoutOwnerExpensesInput = {
    where: ProcessCostWhereUniqueInput
    create: XOR<ProcessCostCreateWithoutOwnerExpensesInput, ProcessCostUncheckedCreateWithoutOwnerExpensesInput>
  }

  export type UserCreateWithoutFieldOwnerExpensesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutFieldOwnerExpensesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutFieldOwnerExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFieldOwnerExpensesInput, UserUncheckedCreateWithoutFieldOwnerExpensesInput>
  }

  export type NotificationCreateWithoutOwnerExpenseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    irrigation?: IrrigationLogCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutOwnerExpenseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutOwnerExpenseInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutOwnerExpenseInput, NotificationUncheckedCreateWithoutOwnerExpenseInput>
  }

  export type NotificationCreateManyOwnerExpenseInputEnvelope = {
    data: NotificationCreateManyOwnerExpenseInput | NotificationCreateManyOwnerExpenseInput[]
  }

  export type FieldOwnershipUpsertWithoutOwnerExpensesInput = {
    update: XOR<FieldOwnershipUpdateWithoutOwnerExpensesInput, FieldOwnershipUncheckedUpdateWithoutOwnerExpensesInput>
    create: XOR<FieldOwnershipCreateWithoutOwnerExpensesInput, FieldOwnershipUncheckedCreateWithoutOwnerExpensesInput>
    where?: FieldOwnershipWhereInput
  }

  export type FieldOwnershipUpdateToOneWithWhereWithoutOwnerExpensesInput = {
    where?: FieldOwnershipWhereInput
    data: XOR<FieldOwnershipUpdateWithoutOwnerExpensesInput, FieldOwnershipUncheckedUpdateWithoutOwnerExpensesInput>
  }

  export type FieldOwnershipUpdateWithoutOwnerExpensesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    field?: FieldUpdateOneRequiredWithoutOwnersNestedInput
    user?: UserUpdateOneRequiredWithoutOwnedFieldsNestedInput
  }

  export type FieldOwnershipUncheckedUpdateWithoutOwnerExpensesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    fieldId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessCostUpsertWithoutOwnerExpensesInput = {
    update: XOR<ProcessCostUpdateWithoutOwnerExpensesInput, ProcessCostUncheckedUpdateWithoutOwnerExpensesInput>
    create: XOR<ProcessCostCreateWithoutOwnerExpensesInput, ProcessCostUncheckedCreateWithoutOwnerExpensesInput>
    where?: ProcessCostWhereInput
  }

  export type ProcessCostUpdateToOneWithWhereWithoutOwnerExpensesInput = {
    where?: ProcessCostWhereInput
    data: XOR<ProcessCostUpdateWithoutOwnerExpensesInput, ProcessCostUncheckedUpdateWithoutOwnerExpensesInput>
  }

  export type ProcessCostUpdateWithoutOwnerExpensesInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutProcessCostsNestedInput
    field?: FieldUpdateOneRequiredWithoutProcessCostsNestedInput
    notifications?: NotificationUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateWithoutOwnerExpensesInput = {
    processId?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutProcessCostNestedInput
  }

  export type UserUpsertWithoutFieldOwnerExpensesInput = {
    update: XOR<UserUpdateWithoutFieldOwnerExpensesInput, UserUncheckedUpdateWithoutFieldOwnerExpensesInput>
    create: XOR<UserCreateWithoutFieldOwnerExpensesInput, UserUncheckedCreateWithoutFieldOwnerExpensesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFieldOwnerExpensesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFieldOwnerExpensesInput, UserUncheckedUpdateWithoutFieldOwnerExpensesInput>
  }

  export type UserUpdateWithoutFieldOwnerExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutFieldOwnerExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutOwnerExpenseInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutOwnerExpenseInput, NotificationUncheckedUpdateWithoutOwnerExpenseInput>
    create: XOR<NotificationCreateWithoutOwnerExpenseInput, NotificationUncheckedCreateWithoutOwnerExpenseInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutOwnerExpenseInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutOwnerExpenseInput, NotificationUncheckedUpdateWithoutOwnerExpenseInput>
  }

  export type NotificationUpdateManyWithWhereWithoutOwnerExpenseInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutOwnerExpenseInput>
  }

  export type WellCreateWithoutIrrigationLogsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellCreateNestedManyWithoutWellInput
    notifications?: NotificationCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWellInput
  }

  export type WellUncheckedCreateWithoutIrrigationLogsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutWellInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutWellInput
    wellBillingPeriods?: WellBillingPeriodUncheckedCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWellInput
  }

  export type WellCreateOrConnectWithoutIrrigationLogsInput = {
    where: WellWhereUniqueInput
    create: XOR<WellCreateWithoutIrrigationLogsInput, WellUncheckedCreateWithoutIrrigationLogsInput>
  }

  export type UserCreateWithoutIrrigationLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutIrrigationLogsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutIrrigationLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIrrigationLogsInput, UserUncheckedCreateWithoutIrrigationLogsInput>
  }

  export type SeasonCreateWithoutIrrigationLogsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutSeasonsInput
    fields?: FieldCreateNestedManyWithoutSeasonInput
    crops?: CropCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutSeasonInput
    processes?: ProcessCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutSeasonInput
    notifications?: NotificationCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutIrrigationLogsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    fields?: FieldUncheckedCreateNestedManyWithoutSeasonInput
    crops?: CropUncheckedCreateNestedManyWithoutSeasonInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutSeasonInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutSeasonInput
    processes?: ProcessUncheckedCreateNestedManyWithoutSeasonInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutSeasonInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutIrrigationLogsInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutIrrigationLogsInput, SeasonUncheckedCreateWithoutIrrigationLogsInput>
  }

  export type IrrigationFieldUsageCreateWithoutIrrigationLogInput = {
    id?: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    field: FieldCreateNestedOneWithoutIrrigationFieldUsagesInput
    ownerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutIrrigationFieldUsageInput
  }

  export type IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput = {
    id?: string
    fieldId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    ownerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutIrrigationFieldUsageInput
  }

  export type IrrigationFieldUsageCreateOrConnectWithoutIrrigationLogInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    create: XOR<IrrigationFieldUsageCreateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput>
  }

  export type IrrigationFieldUsageCreateManyIrrigationLogInputEnvelope = {
    data: IrrigationFieldUsageCreateManyIrrigationLogInput | IrrigationFieldUsageCreateManyIrrigationLogInput[]
  }

  export type IrrigationInventoryUsageCreateWithoutIrrigationLogInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutIrrigationInventoryUsagesInput
    ownerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutIrrigationInventoryUsageInput
  }

  export type IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput = {
    id?: string
    inventoryId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    ownerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutIrrigationInventoryUsageInput
  }

  export type IrrigationInventoryUsageCreateOrConnectWithoutIrrigationLogInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    create: XOR<IrrigationInventoryUsageCreateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput>
  }

  export type IrrigationInventoryUsageCreateManyIrrigationLogInputEnvelope = {
    data: IrrigationInventoryUsageCreateManyIrrigationLogInput | IrrigationInventoryUsageCreateManyIrrigationLogInput[]
  }

  export type WellBillingIrrigationUsageCreateWithoutIrrigationLogInput = {
    id?: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
    wellBillingPeriod: WellBillingPeriodCreateNestedOneWithoutIrrigationUsagesInput
  }

  export type WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput = {
    id?: string
    wellBillingPeriodId: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
  }

  export type WellBillingIrrigationUsageCreateOrConnectWithoutIrrigationLogInput = {
    where: WellBillingIrrigationUsageWhereUniqueInput
    create: XOR<WellBillingIrrigationUsageCreateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput>
  }

  export type WellBillingIrrigationUsageCreateManyIrrigationLogInputEnvelope = {
    data: WellBillingIrrigationUsageCreateManyIrrigationLogInput | WellBillingIrrigationUsageCreateManyIrrigationLogInput[]
  }

  export type IrrigationOwnerSummaryCreateWithoutIrrigationLogInput = {
    id?: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutIrrigationOwnerSummariesInput
  }

  export type IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput = {
    id?: string
    ownerId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerSummaryCreateOrConnectWithoutIrrigationLogInput = {
    where: IrrigationOwnerSummaryWhereUniqueInput
    create: XOR<IrrigationOwnerSummaryCreateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput>
  }

  export type IrrigationOwnerSummaryCreateManyIrrigationLogInputEnvelope = {
    data: IrrigationOwnerSummaryCreateManyIrrigationLogInput | IrrigationOwnerSummaryCreateManyIrrigationLogInput[]
  }

  export type NotificationCreateWithoutIrrigationInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
    process?: ProcessCreateNestedOneWithoutNotificationsInput
    debt?: DebtCreateNestedOneWithoutNotificationsInput
    purchase?: PurchaseCreateNestedOneWithoutNotificationsInput
    inventory?: InventoryCreateNestedOneWithoutNotificationsInput
    field?: FieldCreateNestedOneWithoutNotificationsInput
    season?: SeasonCreateNestedOneWithoutNotificationsInput
    crop?: CropCreateNestedOneWithoutNotificationsInput
    well?: WellCreateNestedOneWithoutNotificationsInput
    processingLog?: ProcessingLogCreateNestedOneWithoutNotificationsInput
    invoice?: InvoiceCreateNestedOneWithoutNotificationsInput
    inventoryUsage?: InventoryUsageCreateNestedOneWithoutNotificationsInput
    transaction?: InventoryTransactionCreateNestedOneWithoutNotificationsInput
    payment?: PaymentHistoryCreateNestedOneWithoutNotificationsInput
    contributor?: PurchaseContributorCreateNestedOneWithoutNotificationsInput
    approval?: PurchaseApprovalCreateNestedOneWithoutNotificationsInput
    equipment?: EquipmentCreateNestedOneWithoutNotificationsInput
    equipmentUsage?: EquipmentUsageCreateNestedOneWithoutNotificationsInput
    processCost?: ProcessCostCreateNestedOneWithoutNotificationsInput
    fieldExpense?: FieldExpenseCreateNestedOneWithoutNotificationsInput
    ownerExpense?: FieldOwnerExpenseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutIrrigationInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateOrConnectWithoutIrrigationInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutIrrigationInput, NotificationUncheckedCreateWithoutIrrigationInput>
  }

  export type NotificationCreateManyIrrigationInputEnvelope = {
    data: NotificationCreateManyIrrigationInput | NotificationCreateManyIrrigationInput[]
  }

  export type WellUpsertWithoutIrrigationLogsInput = {
    update: XOR<WellUpdateWithoutIrrigationLogsInput, WellUncheckedUpdateWithoutIrrigationLogsInput>
    create: XOR<WellCreateWithoutIrrigationLogsInput, WellUncheckedCreateWithoutIrrigationLogsInput>
    where?: WellWhereInput
  }

  export type WellUpdateToOneWithWhereWithoutIrrigationLogsInput = {
    where?: WellWhereInput
    data: XOR<WellUpdateWithoutIrrigationLogsInput, WellUncheckedUpdateWithoutIrrigationLogsInput>
  }

  export type WellUpdateWithoutIrrigationLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUpdateManyWithoutWellNestedInput
    notifications?: NotificationUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUpdateManyWithoutWellNestedInput
  }

  export type WellUncheckedUpdateWithoutIrrigationLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUncheckedUpdateManyWithoutWellNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutWellNestedInput
    wellBillingPeriods?: WellBillingPeriodUncheckedUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWellNestedInput
  }

  export type UserUpsertWithoutIrrigationLogsInput = {
    update: XOR<UserUpdateWithoutIrrigationLogsInput, UserUncheckedUpdateWithoutIrrigationLogsInput>
    create: XOR<UserCreateWithoutIrrigationLogsInput, UserUncheckedCreateWithoutIrrigationLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIrrigationLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIrrigationLogsInput, UserUncheckedUpdateWithoutIrrigationLogsInput>
  }

  export type UserUpdateWithoutIrrigationLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutIrrigationLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type SeasonUpsertWithoutIrrigationLogsInput = {
    update: XOR<SeasonUpdateWithoutIrrigationLogsInput, SeasonUncheckedUpdateWithoutIrrigationLogsInput>
    create: XOR<SeasonCreateWithoutIrrigationLogsInput, SeasonUncheckedCreateWithoutIrrigationLogsInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutIrrigationLogsInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutIrrigationLogsInput, SeasonUncheckedUpdateWithoutIrrigationLogsInput>
  }

  export type SeasonUpdateWithoutIrrigationLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSeasonsNestedInput
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutIrrigationLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type IrrigationFieldUsageUpsertWithWhereUniqueWithoutIrrigationLogInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    update: XOR<IrrigationFieldUsageUpdateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedUpdateWithoutIrrigationLogInput>
    create: XOR<IrrigationFieldUsageCreateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedCreateWithoutIrrigationLogInput>
  }

  export type IrrigationFieldUsageUpdateWithWhereUniqueWithoutIrrigationLogInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    data: XOR<IrrigationFieldUsageUpdateWithoutIrrigationLogInput, IrrigationFieldUsageUncheckedUpdateWithoutIrrigationLogInput>
  }

  export type IrrigationFieldUsageUpdateManyWithWhereWithoutIrrigationLogInput = {
    where: IrrigationFieldUsageScalarWhereInput
    data: XOR<IrrigationFieldUsageUpdateManyMutationInput, IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogInput>
  }

  export type IrrigationInventoryUsageUpsertWithWhereUniqueWithoutIrrigationLogInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    update: XOR<IrrigationInventoryUsageUpdateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedUpdateWithoutIrrigationLogInput>
    create: XOR<IrrigationInventoryUsageCreateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedCreateWithoutIrrigationLogInput>
  }

  export type IrrigationInventoryUsageUpdateWithWhereUniqueWithoutIrrigationLogInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    data: XOR<IrrigationInventoryUsageUpdateWithoutIrrigationLogInput, IrrigationInventoryUsageUncheckedUpdateWithoutIrrigationLogInput>
  }

  export type IrrigationInventoryUsageUpdateManyWithWhereWithoutIrrigationLogInput = {
    where: IrrigationInventoryUsageScalarWhereInput
    data: XOR<IrrigationInventoryUsageUpdateManyMutationInput, IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogInput>
  }

  export type WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutIrrigationLogInput = {
    where: WellBillingIrrigationUsageWhereUniqueInput
    update: XOR<WellBillingIrrigationUsageUpdateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedUpdateWithoutIrrigationLogInput>
    create: XOR<WellBillingIrrigationUsageCreateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedCreateWithoutIrrigationLogInput>
  }

  export type WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutIrrigationLogInput = {
    where: WellBillingIrrigationUsageWhereUniqueInput
    data: XOR<WellBillingIrrigationUsageUpdateWithoutIrrigationLogInput, WellBillingIrrigationUsageUncheckedUpdateWithoutIrrigationLogInput>
  }

  export type WellBillingIrrigationUsageUpdateManyWithWhereWithoutIrrigationLogInput = {
    where: WellBillingIrrigationUsageScalarWhereInput
    data: XOR<WellBillingIrrigationUsageUpdateManyMutationInput, WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogInput>
  }

  export type WellBillingIrrigationUsageScalarWhereInput = {
    AND?: WellBillingIrrigationUsageScalarWhereInput | WellBillingIrrigationUsageScalarWhereInput[]
    OR?: WellBillingIrrigationUsageScalarWhereInput[]
    NOT?: WellBillingIrrigationUsageScalarWhereInput | WellBillingIrrigationUsageScalarWhereInput[]
    id?: StringFilter<"WellBillingIrrigationUsage"> | string
    wellBillingPeriodId?: StringFilter<"WellBillingIrrigationUsage"> | string
    irrigationLogId?: StringFilter<"WellBillingIrrigationUsage"> | string
    duration?: FloatFilter<"WellBillingIrrigationUsage"> | number
    percentage?: FloatFilter<"WellBillingIrrigationUsage"> | number
    amount?: FloatFilter<"WellBillingIrrigationUsage"> | number
    createdAt?: DateTimeFilter<"WellBillingIrrigationUsage"> | Date | string
  }

  export type IrrigationOwnerSummaryUpsertWithWhereUniqueWithoutIrrigationLogInput = {
    where: IrrigationOwnerSummaryWhereUniqueInput
    update: XOR<IrrigationOwnerSummaryUpdateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedUpdateWithoutIrrigationLogInput>
    create: XOR<IrrigationOwnerSummaryCreateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedCreateWithoutIrrigationLogInput>
  }

  export type IrrigationOwnerSummaryUpdateWithWhereUniqueWithoutIrrigationLogInput = {
    where: IrrigationOwnerSummaryWhereUniqueInput
    data: XOR<IrrigationOwnerSummaryUpdateWithoutIrrigationLogInput, IrrigationOwnerSummaryUncheckedUpdateWithoutIrrigationLogInput>
  }

  export type IrrigationOwnerSummaryUpdateManyWithWhereWithoutIrrigationLogInput = {
    where: IrrigationOwnerSummaryScalarWhereInput
    data: XOR<IrrigationOwnerSummaryUpdateManyMutationInput, IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutIrrigationInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutIrrigationInput, NotificationUncheckedUpdateWithoutIrrigationInput>
    create: XOR<NotificationCreateWithoutIrrigationInput, NotificationUncheckedCreateWithoutIrrigationInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutIrrigationInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutIrrigationInput, NotificationUncheckedUpdateWithoutIrrigationInput>
  }

  export type NotificationUpdateManyWithWhereWithoutIrrigationInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutIrrigationInput>
  }

  export type IrrigationLogCreateWithoutFieldUsagesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutFieldUsagesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutFieldUsagesInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutFieldUsagesInput, IrrigationLogUncheckedCreateWithoutFieldUsagesInput>
  }

  export type FieldCreateWithoutIrrigationFieldUsagesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutIrrigationFieldUsagesInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutIrrigationFieldUsagesInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutIrrigationFieldUsagesInput, FieldUncheckedCreateWithoutIrrigationFieldUsagesInput>
  }

  export type IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput = {
    id?: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutIrrigationOwnerUsagesInput
  }

  export type IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput = {
    id?: string
    ownerId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerUsageCreateOrConnectWithoutIrrigationFieldUsageInput = {
    where: IrrigationOwnerUsageWhereUniqueInput
    create: XOR<IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput>
  }

  export type IrrigationOwnerUsageCreateManyIrrigationFieldUsageInputEnvelope = {
    data: IrrigationOwnerUsageCreateManyIrrigationFieldUsageInput | IrrigationOwnerUsageCreateManyIrrigationFieldUsageInput[]
  }

  export type IrrigationLogUpsertWithoutFieldUsagesInput = {
    update: XOR<IrrigationLogUpdateWithoutFieldUsagesInput, IrrigationLogUncheckedUpdateWithoutFieldUsagesInput>
    create: XOR<IrrigationLogCreateWithoutFieldUsagesInput, IrrigationLogUncheckedCreateWithoutFieldUsagesInput>
    where?: IrrigationLogWhereInput
  }

  export type IrrigationLogUpdateToOneWithWhereWithoutFieldUsagesInput = {
    where?: IrrigationLogWhereInput
    data: XOR<IrrigationLogUpdateWithoutFieldUsagesInput, IrrigationLogUncheckedUpdateWithoutFieldUsagesInput>
  }

  export type IrrigationLogUpdateWithoutFieldUsagesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutFieldUsagesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type FieldUpsertWithoutIrrigationFieldUsagesInput = {
    update: XOR<FieldUpdateWithoutIrrigationFieldUsagesInput, FieldUncheckedUpdateWithoutIrrigationFieldUsagesInput>
    create: XOR<FieldCreateWithoutIrrigationFieldUsagesInput, FieldUncheckedCreateWithoutIrrigationFieldUsagesInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutIrrigationFieldUsagesInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutIrrigationFieldUsagesInput, FieldUncheckedUpdateWithoutIrrigationFieldUsagesInput>
  }

  export type FieldUpdateWithoutIrrigationFieldUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutIrrigationFieldUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type IrrigationOwnerUsageUpsertWithWhereUniqueWithoutIrrigationFieldUsageInput = {
    where: IrrigationOwnerUsageWhereUniqueInput
    update: XOR<IrrigationOwnerUsageUpdateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedUpdateWithoutIrrigationFieldUsageInput>
    create: XOR<IrrigationOwnerUsageCreateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedCreateWithoutIrrigationFieldUsageInput>
  }

  export type IrrigationOwnerUsageUpdateWithWhereUniqueWithoutIrrigationFieldUsageInput = {
    where: IrrigationOwnerUsageWhereUniqueInput
    data: XOR<IrrigationOwnerUsageUpdateWithoutIrrigationFieldUsageInput, IrrigationOwnerUsageUncheckedUpdateWithoutIrrigationFieldUsageInput>
  }

  export type IrrigationOwnerUsageUpdateManyWithWhereWithoutIrrigationFieldUsageInput = {
    where: IrrigationOwnerUsageScalarWhereInput
    data: XOR<IrrigationOwnerUsageUpdateManyMutationInput, IrrigationOwnerUsageUncheckedUpdateManyWithoutIrrigationFieldUsageInput>
  }

  export type IrrigationFieldUsageCreateWithoutOwnerUsagesInput = {
    id?: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutFieldUsagesInput
    field: FieldCreateNestedOneWithoutIrrigationFieldUsagesInput
  }

  export type IrrigationFieldUsageUncheckedCreateWithoutOwnerUsagesInput = {
    id?: string
    irrigationLogId: string
    fieldId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
  }

  export type IrrigationFieldUsageCreateOrConnectWithoutOwnerUsagesInput = {
    where: IrrigationFieldUsageWhereUniqueInput
    create: XOR<IrrigationFieldUsageCreateWithoutOwnerUsagesInput, IrrigationFieldUsageUncheckedCreateWithoutOwnerUsagesInput>
  }

  export type UserCreateWithoutIrrigationOwnerUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutIrrigationOwnerUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutIrrigationOwnerUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIrrigationOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationOwnerUsagesInput>
  }

  export type IrrigationFieldUsageUpsertWithoutOwnerUsagesInput = {
    update: XOR<IrrigationFieldUsageUpdateWithoutOwnerUsagesInput, IrrigationFieldUsageUncheckedUpdateWithoutOwnerUsagesInput>
    create: XOR<IrrigationFieldUsageCreateWithoutOwnerUsagesInput, IrrigationFieldUsageUncheckedCreateWithoutOwnerUsagesInput>
    where?: IrrigationFieldUsageWhereInput
  }

  export type IrrigationFieldUsageUpdateToOneWithWhereWithoutOwnerUsagesInput = {
    where?: IrrigationFieldUsageWhereInput
    data: XOR<IrrigationFieldUsageUpdateWithoutOwnerUsagesInput, IrrigationFieldUsageUncheckedUpdateWithoutOwnerUsagesInput>
  }

  export type IrrigationFieldUsageUpdateWithoutOwnerUsagesInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutFieldUsagesNestedInput
    field?: FieldUpdateOneRequiredWithoutIrrigationFieldUsagesNestedInput
  }

  export type IrrigationFieldUsageUncheckedUpdateWithoutOwnerUsagesInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutIrrigationOwnerUsagesInput = {
    update: XOR<UserUpdateWithoutIrrigationOwnerUsagesInput, UserUncheckedUpdateWithoutIrrigationOwnerUsagesInput>
    create: XOR<UserCreateWithoutIrrigationOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationOwnerUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIrrigationOwnerUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIrrigationOwnerUsagesInput, UserUncheckedUpdateWithoutIrrigationOwnerUsagesInput>
  }

  export type UserUpdateWithoutIrrigationOwnerUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutIrrigationOwnerUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type IrrigationLogCreateWithoutOwnerSummariesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutOwnerSummariesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutOwnerSummariesInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutOwnerSummariesInput, IrrigationLogUncheckedCreateWithoutOwnerSummariesInput>
  }

  export type UserCreateWithoutIrrigationOwnerSummariesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutIrrigationOwnerSummariesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutIrrigationOwnerSummariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIrrigationOwnerSummariesInput, UserUncheckedCreateWithoutIrrigationOwnerSummariesInput>
  }

  export type IrrigationLogUpsertWithoutOwnerSummariesInput = {
    update: XOR<IrrigationLogUpdateWithoutOwnerSummariesInput, IrrigationLogUncheckedUpdateWithoutOwnerSummariesInput>
    create: XOR<IrrigationLogCreateWithoutOwnerSummariesInput, IrrigationLogUncheckedCreateWithoutOwnerSummariesInput>
    where?: IrrigationLogWhereInput
  }

  export type IrrigationLogUpdateToOneWithWhereWithoutOwnerSummariesInput = {
    where?: IrrigationLogWhereInput
    data: XOR<IrrigationLogUpdateWithoutOwnerSummariesInput, IrrigationLogUncheckedUpdateWithoutOwnerSummariesInput>
  }

  export type IrrigationLogUpdateWithoutOwnerSummariesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutOwnerSummariesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type UserUpsertWithoutIrrigationOwnerSummariesInput = {
    update: XOR<UserUpdateWithoutIrrigationOwnerSummariesInput, UserUncheckedUpdateWithoutIrrigationOwnerSummariesInput>
    create: XOR<UserCreateWithoutIrrigationOwnerSummariesInput, UserUncheckedCreateWithoutIrrigationOwnerSummariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIrrigationOwnerSummariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIrrigationOwnerSummariesInput, UserUncheckedUpdateWithoutIrrigationOwnerSummariesInput>
  }

  export type UserUpdateWithoutIrrigationOwnerSummariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutIrrigationOwnerSummariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type IrrigationLogCreateWithoutInventoryUsagesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutInventoryUsagesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    billingUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutInventoryUsagesInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutInventoryUsagesInput, IrrigationLogUncheckedCreateWithoutInventoryUsagesInput>
  }

  export type InventoryCreateWithoutIrrigationInventoryUsagesInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutInventoryInput
    notifications?: NotificationCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutIrrigationInventoryUsagesInput = {
    id?: string
    name: string
    category: $Enums.InventoryCategory
    totalQuantity: number
    unit?: $Enums.Unit
    totalStock?: number | null
    purchaseDate?: Date | string | null
    expiryDate?: Date | string | null
    status?: $Enums.InventoryStatus
    costPrice?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerships?: InventoryOwnershipUncheckedCreateNestedManyWithoutInventoryInput
    usages?: InventoryUsageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutIrrigationInventoryUsagesInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutIrrigationInventoryUsagesInput, InventoryUncheckedCreateWithoutIrrigationInventoryUsagesInput>
  }

  export type IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput = {
    id?: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
    owner: UserCreateNestedOneWithoutIrrigationInventoryOwnerUsagesInput
  }

  export type IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput = {
    id?: string
    ownerId: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryOwnerUsageCreateOrConnectWithoutIrrigationInventoryUsageInput = {
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    create: XOR<IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput>
  }

  export type IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInputEnvelope = {
    data: IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInput | IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInput[]
  }

  export type IrrigationLogUpsertWithoutInventoryUsagesInput = {
    update: XOR<IrrigationLogUpdateWithoutInventoryUsagesInput, IrrigationLogUncheckedUpdateWithoutInventoryUsagesInput>
    create: XOR<IrrigationLogCreateWithoutInventoryUsagesInput, IrrigationLogUncheckedCreateWithoutInventoryUsagesInput>
    where?: IrrigationLogWhereInput
  }

  export type IrrigationLogUpdateToOneWithWhereWithoutInventoryUsagesInput = {
    where?: IrrigationLogWhereInput
    data: XOR<IrrigationLogUpdateWithoutInventoryUsagesInput, IrrigationLogUncheckedUpdateWithoutInventoryUsagesInput>
  }

  export type IrrigationLogUpdateWithoutInventoryUsagesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutInventoryUsagesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type InventoryUpsertWithoutIrrigationInventoryUsagesInput = {
    update: XOR<InventoryUpdateWithoutIrrigationInventoryUsagesInput, InventoryUncheckedUpdateWithoutIrrigationInventoryUsagesInput>
    create: XOR<InventoryCreateWithoutIrrigationInventoryUsagesInput, InventoryUncheckedCreateWithoutIrrigationInventoryUsagesInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutIrrigationInventoryUsagesInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutIrrigationInventoryUsagesInput, InventoryUncheckedUpdateWithoutIrrigationInventoryUsagesInput>
  }

  export type InventoryUpdateWithoutIrrigationInventoryUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutIrrigationInventoryUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    totalQuantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    totalStock?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerships?: InventoryOwnershipUncheckedUpdateManyWithoutInventoryNestedInput
    usages?: InventoryUsageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutInventoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type IrrigationInventoryOwnerUsageUpsertWithWhereUniqueWithoutIrrigationInventoryUsageInput = {
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    update: XOR<IrrigationInventoryOwnerUsageUpdateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedUpdateWithoutIrrigationInventoryUsageInput>
    create: XOR<IrrigationInventoryOwnerUsageCreateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedCreateWithoutIrrigationInventoryUsageInput>
  }

  export type IrrigationInventoryOwnerUsageUpdateWithWhereUniqueWithoutIrrigationInventoryUsageInput = {
    where: IrrigationInventoryOwnerUsageWhereUniqueInput
    data: XOR<IrrigationInventoryOwnerUsageUpdateWithoutIrrigationInventoryUsageInput, IrrigationInventoryOwnerUsageUncheckedUpdateWithoutIrrigationInventoryUsageInput>
  }

  export type IrrigationInventoryOwnerUsageUpdateManyWithWhereWithoutIrrigationInventoryUsageInput = {
    where: IrrigationInventoryOwnerUsageScalarWhereInput
    data: XOR<IrrigationInventoryOwnerUsageUpdateManyMutationInput, IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutIrrigationInventoryUsageInput>
  }

  export type IrrigationInventoryUsageCreateWithoutOwnerUsagesInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutInventoryUsagesInput
    inventory: InventoryCreateNestedOneWithoutIrrigationInventoryUsagesInput
  }

  export type IrrigationInventoryUsageUncheckedCreateWithoutOwnerUsagesInput = {
    id?: string
    irrigationLogId: string
    inventoryId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryUsageCreateOrConnectWithoutOwnerUsagesInput = {
    where: IrrigationInventoryUsageWhereUniqueInput
    create: XOR<IrrigationInventoryUsageCreateWithoutOwnerUsagesInput, IrrigationInventoryUsageUncheckedCreateWithoutOwnerUsagesInput>
  }

  export type UserCreateWithoutIrrigationInventoryOwnerUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutIrrigationInventoryOwnerUsagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
    wellBillDistributions?: WellBillDistributionUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutIrrigationInventoryOwnerUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIrrigationInventoryOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationInventoryOwnerUsagesInput>
  }

  export type IrrigationInventoryUsageUpsertWithoutOwnerUsagesInput = {
    update: XOR<IrrigationInventoryUsageUpdateWithoutOwnerUsagesInput, IrrigationInventoryUsageUncheckedUpdateWithoutOwnerUsagesInput>
    create: XOR<IrrigationInventoryUsageCreateWithoutOwnerUsagesInput, IrrigationInventoryUsageUncheckedCreateWithoutOwnerUsagesInput>
    where?: IrrigationInventoryUsageWhereInput
  }

  export type IrrigationInventoryUsageUpdateToOneWithWhereWithoutOwnerUsagesInput = {
    where?: IrrigationInventoryUsageWhereInput
    data: XOR<IrrigationInventoryUsageUpdateWithoutOwnerUsagesInput, IrrigationInventoryUsageUncheckedUpdateWithoutOwnerUsagesInput>
  }

  export type IrrigationInventoryUsageUpdateWithoutOwnerUsagesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutInventoryUsagesNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutIrrigationInventoryUsagesNestedInput
  }

  export type IrrigationInventoryUsageUncheckedUpdateWithoutOwnerUsagesInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutIrrigationInventoryOwnerUsagesInput = {
    update: XOR<UserUpdateWithoutIrrigationInventoryOwnerUsagesInput, UserUncheckedUpdateWithoutIrrigationInventoryOwnerUsagesInput>
    create: XOR<UserCreateWithoutIrrigationInventoryOwnerUsagesInput, UserUncheckedCreateWithoutIrrigationInventoryOwnerUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIrrigationInventoryOwnerUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIrrigationInventoryOwnerUsagesInput, UserUncheckedUpdateWithoutIrrigationInventoryOwnerUsagesInput>
  }

  export type UserUpdateWithoutIrrigationInventoryOwnerUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutIrrigationInventoryOwnerUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type WellCreateWithoutWellBillingPeriodsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellCreateNestedManyWithoutWellInput
    notifications?: NotificationCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWellInput
  }

  export type WellUncheckedCreateWithoutWellBillingPeriodsInput = {
    id?: string
    name: string
    depth: number
    capacity: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutWellInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutWellInput
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutWellInput
    workerAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWellInput
  }

  export type WellCreateOrConnectWithoutWellBillingPeriodsInput = {
    where: WellWhereUniqueInput
    create: XOR<WellCreateWithoutWellBillingPeriodsInput, WellUncheckedCreateWithoutWellBillingPeriodsInput>
  }

  export type WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput = {
    id?: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
    irrigationLog: IrrigationLogCreateNestedOneWithoutBillingUsagesInput
  }

  export type WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput = {
    id?: string
    irrigationLogId: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
  }

  export type WellBillingIrrigationUsageCreateOrConnectWithoutWellBillingPeriodInput = {
    where: WellBillingIrrigationUsageWhereUniqueInput
    create: XOR<WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput>
  }

  export type WellBillingIrrigationUsageCreateManyWellBillingPeriodInputEnvelope = {
    data: WellBillingIrrigationUsageCreateManyWellBillingPeriodInput | WellBillingIrrigationUsageCreateManyWellBillingPeriodInput[]
  }

  export type WellBillDistributionCreateWithoutWellBillingPeriodInput = {
    id?: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    field: FieldCreateNestedOneWithoutWellBillDistributionsInput
    owner: UserCreateNestedOneWithoutWellBillDistributionsInput
    debt?: DebtCreateNestedOneWithoutWellBillDistributionsInput
  }

  export type WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput = {
    id?: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type WellBillDistributionCreateOrConnectWithoutWellBillingPeriodInput = {
    where: WellBillDistributionWhereUniqueInput
    create: XOR<WellBillDistributionCreateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput>
  }

  export type WellBillDistributionCreateManyWellBillingPeriodInputEnvelope = {
    data: WellBillDistributionCreateManyWellBillingPeriodInput | WellBillDistributionCreateManyWellBillingPeriodInput[]
  }

  export type WellUpsertWithoutWellBillingPeriodsInput = {
    update: XOR<WellUpdateWithoutWellBillingPeriodsInput, WellUncheckedUpdateWithoutWellBillingPeriodsInput>
    create: XOR<WellCreateWithoutWellBillingPeriodsInput, WellUncheckedCreateWithoutWellBillingPeriodsInput>
    where?: WellWhereInput
  }

  export type WellUpdateToOneWithWhereWithoutWellBillingPeriodsInput = {
    where?: WellWhereInput
    data: XOR<WellUpdateWithoutWellBillingPeriodsInput, WellUncheckedUpdateWithoutWellBillingPeriodsInput>
  }

  export type WellUpdateWithoutWellBillingPeriodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUpdateManyWithoutWellNestedInput
    notifications?: NotificationUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUpdateManyWithoutWellNestedInput
  }

  export type WellUncheckedUpdateWithoutWellBillingPeriodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    depth?: FloatFieldUpdateOperationsInput | number
    capacity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldWells?: FieldWellUncheckedUpdateManyWithoutWellNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutWellNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutWellNestedInput
    workerAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWellNestedInput
  }

  export type WellBillingIrrigationUsageUpsertWithWhereUniqueWithoutWellBillingPeriodInput = {
    where: WellBillingIrrigationUsageWhereUniqueInput
    update: XOR<WellBillingIrrigationUsageUpdateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedUpdateWithoutWellBillingPeriodInput>
    create: XOR<WellBillingIrrigationUsageCreateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedCreateWithoutWellBillingPeriodInput>
  }

  export type WellBillingIrrigationUsageUpdateWithWhereUniqueWithoutWellBillingPeriodInput = {
    where: WellBillingIrrigationUsageWhereUniqueInput
    data: XOR<WellBillingIrrigationUsageUpdateWithoutWellBillingPeriodInput, WellBillingIrrigationUsageUncheckedUpdateWithoutWellBillingPeriodInput>
  }

  export type WellBillingIrrigationUsageUpdateManyWithWhereWithoutWellBillingPeriodInput = {
    where: WellBillingIrrigationUsageScalarWhereInput
    data: XOR<WellBillingIrrigationUsageUpdateManyMutationInput, WellBillingIrrigationUsageUncheckedUpdateManyWithoutWellBillingPeriodInput>
  }

  export type WellBillDistributionUpsertWithWhereUniqueWithoutWellBillingPeriodInput = {
    where: WellBillDistributionWhereUniqueInput
    update: XOR<WellBillDistributionUpdateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedUpdateWithoutWellBillingPeriodInput>
    create: XOR<WellBillDistributionCreateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedCreateWithoutWellBillingPeriodInput>
  }

  export type WellBillDistributionUpdateWithWhereUniqueWithoutWellBillingPeriodInput = {
    where: WellBillDistributionWhereUniqueInput
    data: XOR<WellBillDistributionUpdateWithoutWellBillingPeriodInput, WellBillDistributionUncheckedUpdateWithoutWellBillingPeriodInput>
  }

  export type WellBillDistributionUpdateManyWithWhereWithoutWellBillingPeriodInput = {
    where: WellBillDistributionScalarWhereInput
    data: XOR<WellBillDistributionUpdateManyMutationInput, WellBillDistributionUncheckedUpdateManyWithoutWellBillingPeriodInput>
  }

  export type WellBillingPeriodCreateWithoutIrrigationUsagesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    well: WellCreateNestedOneWithoutWellBillingPeriodsInput
    distributions?: WellBillDistributionCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodUncheckedCreateWithoutIrrigationUsagesInput = {
    id?: string
    wellId: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    distributions?: WellBillDistributionUncheckedCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodCreateOrConnectWithoutIrrigationUsagesInput = {
    where: WellBillingPeriodWhereUniqueInput
    create: XOR<WellBillingPeriodCreateWithoutIrrigationUsagesInput, WellBillingPeriodUncheckedCreateWithoutIrrigationUsagesInput>
  }

  export type IrrigationLogCreateWithoutBillingUsagesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    well: WellCreateNestedOneWithoutIrrigationLogsInput
    user: UserCreateNestedOneWithoutIrrigationLogsInput
    season?: SeasonCreateNestedOneWithoutIrrigationLogsInput
    fieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogUncheckedCreateWithoutBillingUsagesInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    fieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedCreateNestedManyWithoutIrrigationLogInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutIrrigationLogInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutIrrigationInput
  }

  export type IrrigationLogCreateOrConnectWithoutBillingUsagesInput = {
    where: IrrigationLogWhereUniqueInput
    create: XOR<IrrigationLogCreateWithoutBillingUsagesInput, IrrigationLogUncheckedCreateWithoutBillingUsagesInput>
  }

  export type WellBillingPeriodUpsertWithoutIrrigationUsagesInput = {
    update: XOR<WellBillingPeriodUpdateWithoutIrrigationUsagesInput, WellBillingPeriodUncheckedUpdateWithoutIrrigationUsagesInput>
    create: XOR<WellBillingPeriodCreateWithoutIrrigationUsagesInput, WellBillingPeriodUncheckedCreateWithoutIrrigationUsagesInput>
    where?: WellBillingPeriodWhereInput
  }

  export type WellBillingPeriodUpdateToOneWithWhereWithoutIrrigationUsagesInput = {
    where?: WellBillingPeriodWhereInput
    data: XOR<WellBillingPeriodUpdateWithoutIrrigationUsagesInput, WellBillingPeriodUncheckedUpdateWithoutIrrigationUsagesInput>
  }

  export type WellBillingPeriodUpdateWithoutIrrigationUsagesInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutWellBillingPeriodsNestedInput
    distributions?: WellBillDistributionUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type WellBillingPeriodUncheckedUpdateWithoutIrrigationUsagesInput = {
    wellId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributions?: WellBillDistributionUncheckedUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type IrrigationLogUpsertWithoutBillingUsagesInput = {
    update: XOR<IrrigationLogUpdateWithoutBillingUsagesInput, IrrigationLogUncheckedUpdateWithoutBillingUsagesInput>
    create: XOR<IrrigationLogCreateWithoutBillingUsagesInput, IrrigationLogUncheckedCreateWithoutBillingUsagesInput>
    where?: IrrigationLogWhereInput
  }

  export type IrrigationLogUpdateToOneWithWhereWithoutBillingUsagesInput = {
    where?: IrrigationLogWhereInput
    data: XOR<IrrigationLogUpdateWithoutBillingUsagesInput, IrrigationLogUncheckedUpdateWithoutBillingUsagesInput>
  }

  export type IrrigationLogUpdateWithoutBillingUsagesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutBillingUsagesInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type WellBillingPeriodCreateWithoutDistributionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    well: WellCreateNestedOneWithoutWellBillingPeriodsInput
    irrigationUsages?: WellBillingIrrigationUsageCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodUncheckedCreateWithoutDistributionsInput = {
    id?: string
    wellId: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
    irrigationUsages?: WellBillingIrrigationUsageUncheckedCreateNestedManyWithoutWellBillingPeriodInput
  }

  export type WellBillingPeriodCreateOrConnectWithoutDistributionsInput = {
    where: WellBillingPeriodWhereUniqueInput
    create: XOR<WellBillingPeriodCreateWithoutDistributionsInput, WellBillingPeriodUncheckedCreateWithoutDistributionsInput>
  }

  export type FieldCreateWithoutWellBillDistributionsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutFieldsInput
    owners?: FieldOwnershipCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentCreateNestedManyWithoutFieldInput
    crops?: CropCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutFieldInput
    processes?: ProcessCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseCreateNestedManyWithoutFieldInput
    notifications?: NotificationCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageCreateNestedManyWithoutFieldInput
  }

  export type FieldUncheckedCreateWithoutWellBillDistributionsInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
    owners?: FieldOwnershipUncheckedCreateNestedManyWithoutFieldInput
    workerAssignments?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutFieldInput
    crops?: CropUncheckedCreateNestedManyWithoutFieldInput
    fieldWells?: FieldWellUncheckedCreateNestedManyWithoutFieldInput
    processingLogs?: ProcessingLogUncheckedCreateNestedManyWithoutFieldInput
    processCosts?: ProcessCostUncheckedCreateNestedManyWithoutFieldInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutFieldInput
    processes?: ProcessUncheckedCreateNestedManyWithoutFieldInput
    fieldExpenses?: FieldExpenseUncheckedCreateNestedManyWithoutFieldInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutFieldInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FieldCreateOrConnectWithoutWellBillDistributionsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutWellBillDistributionsInput, FieldUncheckedCreateWithoutWellBillDistributionsInput>
  }

  export type UserCreateWithoutWellBillDistributionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageCreateNestedManyWithoutUsedByInput
    processes?: ProcessCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutUserInput
    seasons?: SeasonCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutWellBillDistributionsInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    irrigationLogs?: IrrigationLogUncheckedCreateNestedManyWithoutUserInput
    ownedFields?: FieldOwnershipUncheckedCreateNestedManyWithoutUserInput
    assignedFields?: FieldWorkerAssignmentUncheckedCreateNestedManyWithoutUserInput
    inventoryOwnership?: InventoryOwnershipUncheckedCreateNestedManyWithoutUserInput
    debtsAsCreditor?: DebtUncheckedCreateNestedManyWithoutCreditorInput
    debtsAsDebtor?: DebtUncheckedCreateNestedManyWithoutDebtorInput
    purchaseContributions?: PurchaseContributorUncheckedCreateNestedManyWithoutUserInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    inventoryUsages?: InventoryUsageUncheckedCreateNestedManyWithoutUsedByInput
    processes?: ProcessUncheckedCreateNestedManyWithoutWorkerInput
    invoicesPurchased?: InvoiceUncheckedCreateNestedManyWithoutPurchaserInput
    paymentsMade?: PaymentHistoryUncheckedCreateNestedManyWithoutPayerInput
    paymentsReceived?: PaymentHistoryUncheckedCreateNestedManyWithoutReceiverInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutCreatorInput
    purchaseApprovals?: PurchaseApprovalUncheckedCreateNestedManyWithoutApproverInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedCreateNestedManyWithoutUserInput
    equipmentUsages?: EquipmentUsageUncheckedCreateNestedManyWithoutUserInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedCreateNestedManyWithoutUserInput
    wellAssignments?: WorkerWellAssignmentUncheckedCreateNestedManyWithoutWorkerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedCreateNestedManyWithoutOwnerInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutWellBillDistributionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWellBillDistributionsInput, UserUncheckedCreateWithoutWellBillDistributionsInput>
  }

  export type DebtCreateWithoutWellBillDistributionsInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditor: UserCreateNestedOneWithoutDebtsAsCreditorInput
    debtor: UserCreateNestedOneWithoutDebtsAsDebtorInput
    invoice?: InvoiceCreateNestedOneWithoutDebtsInput
    purchase?: PurchaseCreateNestedOneWithoutDebtsInput
    paymentHistory?: PaymentHistoryCreateNestedManyWithoutDebtInput
    notifications?: NotificationCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutWellBillDistributionsInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
    paymentHistory?: PaymentHistoryUncheckedCreateNestedManyWithoutDebtInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutWellBillDistributionsInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutWellBillDistributionsInput, DebtUncheckedCreateWithoutWellBillDistributionsInput>
  }

  export type WellBillingPeriodUpsertWithoutDistributionsInput = {
    update: XOR<WellBillingPeriodUpdateWithoutDistributionsInput, WellBillingPeriodUncheckedUpdateWithoutDistributionsInput>
    create: XOR<WellBillingPeriodCreateWithoutDistributionsInput, WellBillingPeriodUncheckedCreateWithoutDistributionsInput>
    where?: WellBillingPeriodWhereInput
  }

  export type WellBillingPeriodUpdateToOneWithWhereWithoutDistributionsInput = {
    where?: WellBillingPeriodWhereInput
    data: XOR<WellBillingPeriodUpdateWithoutDistributionsInput, WellBillingPeriodUncheckedUpdateWithoutDistributionsInput>
  }

  export type WellBillingPeriodUpdateWithoutDistributionsInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutWellBillingPeriodsNestedInput
    irrigationUsages?: WellBillingIrrigationUsageUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type WellBillingPeriodUncheckedUpdateWithoutDistributionsInput = {
    wellId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type FieldUpsertWithoutWellBillDistributionsInput = {
    update: XOR<FieldUpdateWithoutWellBillDistributionsInput, FieldUncheckedUpdateWithoutWellBillDistributionsInput>
    create: XOR<FieldCreateWithoutWellBillDistributionsInput, FieldUncheckedCreateWithoutWellBillDistributionsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutWellBillDistributionsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutWellBillDistributionsInput, FieldUncheckedUpdateWithoutWellBillDistributionsInput>
  }

  export type FieldUpdateWithoutWellBillDistributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutFieldsNestedInput
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutWellBillDistributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type UserUpsertWithoutWellBillDistributionsInput = {
    update: XOR<UserUpdateWithoutWellBillDistributionsInput, UserUncheckedUpdateWithoutWellBillDistributionsInput>
    create: XOR<UserCreateWithoutWellBillDistributionsInput, UserUncheckedCreateWithoutWellBillDistributionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWellBillDistributionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWellBillDistributionsInput, UserUncheckedUpdateWithoutWellBillDistributionsInput>
  }

  export type UserUpdateWithoutWellBillDistributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutUserNestedInput
    seasons?: SeasonUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutWellBillDistributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutUserNestedInput
    ownedFields?: FieldOwnershipUncheckedUpdateManyWithoutUserNestedInput
    assignedFields?: FieldWorkerAssignmentUncheckedUpdateManyWithoutUserNestedInput
    inventoryOwnership?: InventoryOwnershipUncheckedUpdateManyWithoutUserNestedInput
    debtsAsCreditor?: DebtUncheckedUpdateManyWithoutCreditorNestedInput
    debtsAsDebtor?: DebtUncheckedUpdateManyWithoutDebtorNestedInput
    purchaseContributions?: PurchaseContributorUncheckedUpdateManyWithoutUserNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutUsedByNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutWorkerNestedInput
    invoicesPurchased?: InvoiceUncheckedUpdateManyWithoutPurchaserNestedInput
    paymentsMade?: PaymentHistoryUncheckedUpdateManyWithoutPayerNestedInput
    paymentsReceived?: PaymentHistoryUncheckedUpdateManyWithoutReceiverNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseApprovals?: PurchaseApprovalUncheckedUpdateManyWithoutApproverNestedInput
    equipmentOwnerships?: EquipmentOwnershipUncheckedUpdateManyWithoutUserNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutUserNestedInput
    fieldOwnerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutUserNestedInput
    wellAssignments?: WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    irrigationOwnerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationInventoryOwnerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerNestedInput
    irrigationOwnerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type DebtUpsertWithoutWellBillDistributionsInput = {
    update: XOR<DebtUpdateWithoutWellBillDistributionsInput, DebtUncheckedUpdateWithoutWellBillDistributionsInput>
    create: XOR<DebtCreateWithoutWellBillDistributionsInput, DebtUncheckedCreateWithoutWellBillDistributionsInput>
    where?: DebtWhereInput
  }

  export type DebtUpdateToOneWithWhereWithoutWellBillDistributionsInput = {
    where?: DebtWhereInput
    data: XOR<DebtUpdateWithoutWellBillDistributionsInput, DebtUncheckedUpdateWithoutWellBillDistributionsInput>
  }

  export type DebtUpdateWithoutWellBillDistributionsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutWellBillDistributionsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type IrrigationLogCreateManyUserInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
  }

  export type FieldOwnershipCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    fieldId: string
  }

  export type FieldWorkerAssignmentCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type InventoryOwnershipCreateManyUserInput = {
    id?: string
    inventoryId: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtCreateManyCreditorInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    debtorId: string
    invoiceId?: string | null
    purchaseId?: string | null
  }

  export type DebtCreateManyDebtorInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    invoiceId?: string | null
    purchaseId?: string | null
  }

  export type PurchaseContributorCreateManyUserInput = {
    id?: string
    purchaseId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyReceiverInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type InventoryUsageCreateManyUsedByInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
  }

  export type ProcessCreateManyWorkerInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPurchaserInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseId?: string | null
  }

  export type PaymentHistoryCreateManyPayerInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    receiverId: string
  }

  export type PaymentHistoryCreateManyReceiverInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    contributorId?: string | null
    payerId: string
  }

  export type InventoryTransactionCreateManyUserInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    purchaseId?: string | null
  }

  export type SeasonCreateManyCreatorInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseApprovalCreateManyApproverInput = {
    id?: string
    purchaseId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentOwnershipCreateManyUserInput = {
    id?: string
    equipmentId: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUsageCreateManyUserInput = {
    id?: string
    processId: string
    equipmentId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldOwnerExpenseCreateManyUserInput = {
    id?: string
    fieldOwnershipId: string
    processCostId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerWellAssignmentCreateManyWorkerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    wellId: string
  }

  export type IrrigationOwnerUsageCreateManyOwnerInput = {
    id?: string
    irrigationFieldUsageId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryOwnerUsageCreateManyOwnerInput = {
    id?: string
    irrigationInventoryUsageId: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerSummaryCreateManyOwnerInput = {
    id?: string
    irrigationLogId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
  }

  export type WellBillDistributionCreateManyOwnerInput = {
    id?: string
    wellBillingPeriodId: string
    fieldId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type IrrigationLogUpdateWithoutUserInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutUserInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateManyWithoutUserInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldOwnershipUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    field?: FieldUpdateOneRequiredWithoutOwnersNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutFieldOwnershipNestedInput
  }

  export type FieldOwnershipUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutFieldOwnershipNestedInput
  }

  export type FieldOwnershipUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWorkerAssignmentUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutWorkerAssignmentsNestedInput
  }

  export type FieldWorkerAssignmentUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWorkerAssignmentUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryOwnershipUpdateWithoutUserInput = {
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutOwnershipsNestedInput
  }

  export type InventoryOwnershipUncheckedUpdateWithoutUserInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryOwnershipUncheckedUpdateManyWithoutUserInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtUpdateWithoutCreditorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutCreditorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateManyWithoutCreditorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DebtUpdateWithoutDebtorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutDebtorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateManyWithoutDebtorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseContributorUpdateWithoutUserInput = {
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutContributorsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutContributorNestedInput
    notifications?: NotificationUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateWithoutUserInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutContributorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateManyWithoutUserInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutReceiverInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutReceiverInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutReceiverInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUsageUpdateWithoutUsedByInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutUsagesNestedInput
    field?: FieldUpdateOneWithoutInventoryUsagesNestedInput
    process?: ProcessUpdateOneWithoutInventoryUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateWithoutUsedByInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateManyWithoutUsedByInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessUpdateWithoutWorkerInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutWorkerInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutWorkerInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPurchaserInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debts?: DebtUpdateManyWithoutInvoiceNestedInput
    purchase?: PurchaseUpdateOneWithoutInvoicesNestedInput
    notifications?: NotificationUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPurchaserInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    debts?: DebtUncheckedUpdateManyWithoutInvoiceNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPurchaserInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentHistoryUpdateWithoutPayerInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneWithoutPaymentHistoryNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutPaymentHistoryNestedInput
    receiver?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    notifications?: NotificationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateWithoutPayerInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    receiverId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutPayerInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentHistoryUpdateWithoutReceiverInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneWithoutPaymentHistoryNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutPaymentHistoryNestedInput
    payer?: UserUpdateOneRequiredWithoutPaymentsMadeNestedInput
    notifications?: NotificationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateWithoutReceiverInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutReceiverInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryTransactionUpdateWithoutUserInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutInventoryTransactionsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutInventoryTransactionsNestedInput
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutUserInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutUserInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeasonUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: FieldUpdateManyWithoutSeasonNestedInput
    crops?: CropUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: FieldUncheckedUpdateManyWithoutSeasonNestedInput
    crops?: CropUncheckedUpdateManyWithoutSeasonNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutSeasonNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutSeasonNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutSeasonNestedInput
    irrigationLogs?: IrrigationLogUncheckedUpdateManyWithoutSeasonNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutSeasonNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateManyWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseApprovalUpdateWithoutApproverInput = {
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutApprovalsNestedInput
    notifications?: NotificationUpdateManyWithoutApprovalNestedInput
  }

  export type PurchaseApprovalUncheckedUpdateWithoutApproverInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type PurchaseApprovalUncheckedUpdateManyWithoutApproverInput = {
    purchaseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentOwnershipUpdateWithoutUserInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentUpdateOneRequiredWithoutOwnershipsNestedInput
  }

  export type EquipmentOwnershipUncheckedUpdateWithoutUserInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentOwnershipUncheckedUpdateManyWithoutUserInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUsageUpdateWithoutUserInput = {
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateWithoutUserInput = {
    processId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateManyWithoutUserInput = {
    processId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldOwnerExpenseUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldOwnership?: FieldOwnershipUpdateOneRequiredWithoutOwnerExpensesNestedInput
    processCost?: ProcessCostUpdateOneRequiredWithoutOwnerExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateWithoutUserInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    processCostId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateManyWithoutUserInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    processCostId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerWellAssignmentUpdateWithoutWorkerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutWorkerAssignmentsNestedInput
  }

  export type WorkerWellAssignmentUncheckedUpdateWithoutWorkerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerWellAssignmentUncheckedUpdateManyWithoutWorkerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellId?: StringFieldUpdateOperationsInput | string
  }

  export type IrrigationOwnerUsageUpdateWithoutOwnerInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationFieldUsage?: IrrigationFieldUsageUpdateOneRequiredWithoutOwnerUsagesNestedInput
  }

  export type IrrigationOwnerUsageUncheckedUpdateWithoutOwnerInput = {
    irrigationFieldUsageId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerUsageUncheckedUpdateManyWithoutOwnerInput = {
    irrigationFieldUsageId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageUpdateWithoutOwnerInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationInventoryUsage?: IrrigationInventoryUsageUpdateOneRequiredWithoutOwnerUsagesNestedInput
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateWithoutOwnerInput = {
    irrigationInventoryUsageId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutOwnerInput = {
    irrigationInventoryUsageId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryUpdateWithoutOwnerInput = {
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutOwnerSummariesNestedInput
  }

  export type IrrigationOwnerSummaryUncheckedUpdateWithoutOwnerInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryUncheckedUpdateManyWithoutOwnerInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillDistributionUpdateWithoutOwnerInput = {
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellBillingPeriod?: WellBillingPeriodUpdateOneRequiredWithoutDistributionsNestedInput
    field?: FieldUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    debt?: DebtUpdateOneWithoutWellBillDistributionsNestedInput
  }

  export type WellBillDistributionUncheckedUpdateWithoutOwnerInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutOwnerInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldCreateManySeasonInput = {
    id?: string
    name: string
    location: string
    size: number
    coordinates?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CropCreateManySeasonInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type PurchaseCreateManySeasonInput = {
    id?: string
    product: string
    category?: $Enums.ProductCategory
    quantity: number
    unit?: $Enums.Unit
    unitPrice: number
    totalCost: number
    paymentMethod: $Enums.PaymentMethod
    creditorPaymentDueDate?: Date | string | null
    dueDate?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    isTemplate?: boolean
    templateName?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    approvalRequired?: boolean
    approvalThreshold?: number
  }

  export type InventoryTransactionCreateManySeasonInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    inventoryId: string
    purchaseId?: string | null
    userId: string
  }

  export type ProcessCreateManySeasonInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    fieldId?: string | null
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IrrigationLogCreateManySeasonInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    wellId: string
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldExpenseCreateManySeasonInput = {
    id?: string
    fieldId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManySeasonInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type FieldUpdateWithoutSeasonInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: FieldOwnershipUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUpdateManyWithoutFieldNestedInput
    crops?: CropUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutFieldNestedInput
    processes?: ProcessUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutSeasonInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: FieldOwnershipUncheckedUpdateManyWithoutFieldNestedInput
    workerAssignments?: FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldNestedInput
    crops?: CropUncheckedUpdateManyWithoutFieldNestedInput
    fieldWells?: FieldWellUncheckedUpdateManyWithoutFieldNestedInput
    processingLogs?: ProcessingLogUncheckedUpdateManyWithoutFieldNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutFieldNestedInput
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutFieldNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutFieldNestedInput
    fieldExpenses?: FieldExpenseUncheckedUpdateManyWithoutFieldNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutFieldNestedInput
    irrigationFieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutFieldNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FieldUncheckedUpdateManyWithoutSeasonInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    size?: FloatFieldUpdateOperationsInput | number
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CropUpdateWithoutSeasonInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutCropsNestedInput
    notifications?: NotificationUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutSeasonInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateManyWithoutSeasonInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseUpdateWithoutSeasonInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    contributors?: PurchaseContributorUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutSeasonInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
    contributors?: PurchaseContributorUncheckedUpdateManyWithoutPurchaseNestedInput
    debts?: DebtUncheckedUpdateManyWithoutPurchaseNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutPurchaseNestedInput
    approvals?: PurchaseApprovalUncheckedUpdateManyWithoutPurchaseNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutSeasonInput = {
    product?: StringFieldUpdateOperationsInput | string
    category?: EnumProductCategoryFieldUpdateOperationsInput | $Enums.ProductCategory
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    creditorPaymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateName?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalThreshold?: FloatFieldUpdateOperationsInput | number
  }

  export type InventoryTransactionUpdateWithoutSeasonInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutInventoryTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutSeasonInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutSeasonInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessUpdateWithoutSeasonInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneWithoutProcessesNestedInput
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutSeasonInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutSeasonInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationLogUpdateWithoutSeasonInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutIrrigationLogsNestedInput
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutSeasonInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateManyWithoutSeasonInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    wellId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldExpenseUpdateWithoutSeasonInput = {
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutFieldExpenseNestedInput
  }

  export type FieldExpenseUncheckedUpdateWithoutSeasonInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutFieldExpenseNestedInput
  }

  export type FieldExpenseUncheckedUpdateManyWithoutSeasonInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSeasonInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSeasonInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutSeasonInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldOwnershipCreateManyFieldInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    percentage?: number
    userId: string
  }

  export type FieldWorkerAssignmentCreateManyFieldInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CropCreateManyFieldInput = {
    id?: string
    name: string
    plantedDate: Date | string
    harvestDate?: Date | string | null
    status?: $Enums.CropStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
  }

  export type FieldWellCreateManyFieldInput = {
    id?: string
    wellId: string
    createdAt?: Date | string
  }

  export type ProcessingLogCreateManyFieldInput = {
    id?: string
    date: Date | string
    processType: $Enums.ProcessType
    equipment?: string | null
    duration: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessCostCreateManyFieldInput = {
    id?: string
    processId: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUsageCreateManyFieldInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    processId?: string | null
    createdAt?: Date | string
  }

  export type ProcessCreateManyFieldInput = {
    id?: string
    type: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    workerId: string
    date: Date | string
    description?: string | null
    totalArea: number
    processedArea: number
    processedPercentage: number
    seasonId?: string | null
    inventoryDistribution?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldExpenseCreateManyFieldInput = {
    id?: string
    seasonId: string
    totalCost: number
    description: string
    expenseDate: Date | string
    sourceType: string
    sourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyFieldInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type IrrigationFieldUsageCreateManyFieldInput = {
    id?: string
    irrigationLogId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
  }

  export type WellBillDistributionCreateManyFieldInput = {
    id?: string
    wellBillingPeriodId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type FieldOwnershipUpdateWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutOwnedFieldsNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutFieldOwnershipNestedInput
  }

  export type FieldOwnershipUncheckedUpdateWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutFieldOwnershipNestedInput
  }

  export type FieldOwnershipUncheckedUpdateManyWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWorkerAssignmentUpdateWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAssignedFieldsNestedInput
  }

  export type FieldWorkerAssignmentUncheckedUpdateWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldWorkerAssignmentUncheckedUpdateManyWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CropUpdateWithoutFieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutCropsNestedInput
    notifications?: NotificationUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateWithoutFieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutCropNestedInput
  }

  export type CropUncheckedUpdateManyWithoutFieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    plantedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCropStatusFieldUpdateOperationsInput | $Enums.CropStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldWellUpdateWithoutFieldInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    well?: WellUpdateOneRequiredWithoutFieldWellsNestedInput
  }

  export type FieldWellUncheckedUpdateWithoutFieldInput = {
    wellId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldWellUncheckedUpdateManyWithoutFieldInput = {
    wellId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessingLogUpdateWithoutFieldInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutProcessingLogNestedInput
  }

  export type ProcessingLogUncheckedUpdateWithoutFieldInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutProcessingLogNestedInput
  }

  export type ProcessingLogUncheckedUpdateManyWithoutFieldInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    processType?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCostUpdateWithoutFieldInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutProcessCostsNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutProcessCostNestedInput
    notifications?: NotificationUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateWithoutFieldInput = {
    processId?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateManyWithoutFieldInput = {
    processId?: StringFieldUpdateOperationsInput | string
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageUpdateWithoutFieldInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutUsagesNestedInput
    usedBy?: UserUpdateOneRequiredWithoutInventoryUsagesNestedInput
    process?: ProcessUpdateOneWithoutInventoryUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateWithoutFieldInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateManyWithoutFieldInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessUpdateWithoutFieldInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worker?: UserUpdateOneRequiredWithoutProcessesNestedInput
    season?: SeasonUpdateOneWithoutProcessesNestedInput
    inventoryUsages?: InventoryUsageUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateWithoutFieldInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryUsages?: InventoryUsageUncheckedUpdateManyWithoutProcessNestedInput
    equipmentUsages?: EquipmentUsageUncheckedUpdateManyWithoutProcessNestedInput
    processCosts?: ProcessCostUncheckedUpdateManyWithoutProcessNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutFieldInput = {
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalArea?: FloatFieldUpdateOperationsInput | number
    processedArea?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryDistribution?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldExpenseUpdateWithoutFieldInput = {
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneRequiredWithoutFieldExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutFieldExpenseNestedInput
  }

  export type FieldExpenseUncheckedUpdateWithoutFieldInput = {
    seasonId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutFieldExpenseNestedInput
  }

  export type FieldExpenseUncheckedUpdateManyWithoutFieldInput = {
    seasonId?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutFieldInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutFieldInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutFieldInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationFieldUsageUpdateWithoutFieldInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutFieldUsagesNestedInput
    ownerUsages?: IrrigationOwnerUsageUpdateManyWithoutIrrigationFieldUsageNestedInput
  }

  export type IrrigationFieldUsageUncheckedUpdateWithoutFieldInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutIrrigationFieldUsageNestedInput
  }

  export type IrrigationFieldUsageUncheckedUpdateManyWithoutFieldInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillDistributionUpdateWithoutFieldInput = {
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellBillingPeriod?: WellBillingPeriodUpdateOneRequiredWithoutDistributionsNestedInput
    owner?: UserUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    debt?: DebtUpdateOneWithoutWellBillDistributionsNestedInput
  }

  export type WellBillDistributionUncheckedUpdateWithoutFieldInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutFieldInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldOwnerExpenseCreateManyFieldOwnershipInput = {
    id?: string
    processCostId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FieldOwnerExpenseUpdateWithoutFieldOwnershipInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processCost?: ProcessCostUpdateOneRequiredWithoutOwnerExpensesNestedInput
    user?: UserUpdateOneRequiredWithoutFieldOwnerExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateWithoutFieldOwnershipInput = {
    processCostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateManyWithoutFieldOwnershipInput = {
    processCostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldWellCreateManyWellInput = {
    id?: string
    fieldId: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyWellInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type IrrigationLogCreateManyWellInput = {
    id?: string
    startDateTime: Date | string
    duration: number
    notes?: string | null
    status?: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    seasonId?: string | null
  }

  export type WellBillingPeriodCreateManyWellInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalAmount: number
    totalUsage?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type WorkerWellAssignmentCreateManyWellInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workerId: string
  }

  export type FieldWellUpdateWithoutWellInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFieldWellsNestedInput
  }

  export type FieldWellUncheckedUpdateWithoutWellInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldWellUncheckedUpdateManyWithoutWellInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutWellInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutWellInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutWellInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationLogUpdateWithoutWellInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIrrigationLogsNestedInput
    season?: SeasonUpdateOneWithoutIrrigationLogsNestedInput
    fieldUsages?: IrrigationFieldUsageUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateWithoutWellInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldUsages?: IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    inventoryUsages?: IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    billingUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogNestedInput
    ownerSummaries?: IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutIrrigationNestedInput
  }

  export type IrrigationLogUncheckedUpdateManyWithoutWellInput = {
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WellBillingPeriodUpdateWithoutWellInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationUsages?: WellBillingIrrigationUsageUpdateManyWithoutWellBillingPeriodNestedInput
    distributions?: WellBillDistributionUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type WellBillingPeriodUncheckedUpdateWithoutWellInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationUsages?: WellBillingIrrigationUsageUncheckedUpdateManyWithoutWellBillingPeriodNestedInput
    distributions?: WellBillDistributionUncheckedUpdateManyWithoutWellBillingPeriodNestedInput
  }

  export type WellBillingPeriodUncheckedUpdateManyWithoutWellInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    totalUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerWellAssignmentUpdateWithoutWellInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worker?: UserUpdateOneRequiredWithoutWellAssignmentsNestedInput
  }

  export type WorkerWellAssignmentUncheckedUpdateWithoutWellInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerWellAssignmentUncheckedUpdateManyWithoutWellInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyCropInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutCropInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCropInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutCropInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyProcessingLogInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutProcessingLogInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutProcessingLogInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutProcessingLogInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryOwnershipCreateManyInventoryInput = {
    id?: string
    userId: string
    shareQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUsageCreateManyInventoryInput = {
    id?: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    processId?: string | null
    createdAt?: Date | string
  }

  export type InventoryTransactionCreateManyInventoryInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    purchaseId?: string | null
    userId: string
  }

  export type NotificationCreateManyInventoryInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type IrrigationInventoryUsageCreateManyInventoryInput = {
    id?: string
    irrigationLogId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
  }

  export type InventoryOwnershipUpdateWithoutInventoryInput = {
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInventoryOwnershipNestedInput
  }

  export type InventoryOwnershipUncheckedUpdateWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryOwnershipUncheckedUpdateManyWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    shareQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageUpdateWithoutInventoryInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedBy?: UserUpdateOneRequiredWithoutInventoryUsagesNestedInput
    field?: FieldUpdateOneWithoutInventoryUsagesNestedInput
    process?: ProcessUpdateOneWithoutInventoryUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateWithoutInventoryInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateManyWithoutInventoryInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutInventoryInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutInventoryTransactionsNestedInput
    purchase?: PurchaseUpdateOneWithoutInventoryTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutInventoryInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutInventoryInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutInventoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutInventoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutInventoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationInventoryUsageUpdateWithoutInventoryInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutInventoryUsagesNestedInput
    ownerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutIrrigationInventoryUsageNestedInput
  }

  export type IrrigationInventoryUsageUncheckedUpdateWithoutInventoryInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutIrrigationInventoryUsageNestedInput
  }

  export type IrrigationInventoryUsageUncheckedUpdateManyWithoutInventoryInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseContributorCreateManyPurchaseInput = {
    id?: string
    userId: string
    sharePercentage: number
    contribution: number
    expectedContribution: number
    actualContribution?: number
    remainingAmount?: number | null
    hasPaid?: boolean
    paymentDate?: Date | string | null
    isCreditor: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtCreateManyPurchaseInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    invoiceId?: string | null
  }

  export type InvoiceCreateManyPurchaseInput = {
    id?: string
    number: string
    amount: number
    issueDate: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaserId: string
  }

  export type InventoryTransactionCreateManyPurchaseInput = {
    id?: string
    type: $Enums.TransactionType
    quantity: number
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    seasonId?: string | null
    inventoryId: string
    userId: string
  }

  export type PurchaseApprovalCreateManyPurchaseInput = {
    id?: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyPurchaseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type PurchaseContributorUpdateWithoutPurchaseInput = {
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchaseContributionsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutContributorNestedInput
    notifications?: NotificationUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateWithoutPurchaseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutContributorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutContributorNestedInput
  }

  export type PurchaseContributorUncheckedUpdateManyWithoutPurchaseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    contribution?: FloatFieldUpdateOperationsInput | number
    expectedContribution?: FloatFieldUpdateOperationsInput | number
    actualContribution?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    hasPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCreditor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtUpdateWithoutPurchaseInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    invoice?: InvoiceUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutPurchaseInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateManyWithoutPurchaseInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutPurchaseInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaser?: UserUpdateOneRequiredWithoutInvoicesPurchasedNestedInput
    debts?: DebtUpdateManyWithoutInvoiceNestedInput
    notifications?: NotificationUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPurchaseInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaserId?: StringFieldUpdateOperationsInput | string
    debts?: DebtUncheckedUpdateManyWithoutInvoiceNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPurchaseInput = {
    number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaserId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryTransactionUpdateWithoutPurchaseInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutInventoryTransactionsNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutPurchaseInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutPurchaseInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseApprovalUpdateWithoutPurchaseInput = {
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneRequiredWithoutPurchaseApprovalsNestedInput
    notifications?: NotificationUpdateManyWithoutApprovalNestedInput
  }

  export type PurchaseApprovalUncheckedUpdateWithoutPurchaseInput = {
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type PurchaseApprovalUncheckedUpdateManyWithoutPurchaseInput = {
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutPurchaseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPurchaseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutPurchaseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyApprovalInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutApprovalInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutApprovalInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutApprovalInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentHistoryCreateManyContributorInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    debtId?: string | null
    payerId: string
    receiverId: string
  }

  export type NotificationCreateManyContributorInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type PaymentHistoryUpdateWithoutContributorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneWithoutPaymentHistoryNestedInput
    payer?: UserUpdateOneRequiredWithoutPaymentsMadeNestedInput
    receiver?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    notifications?: NotificationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateWithoutContributorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutContributorInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutContributorInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutContributorInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutContributorInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyPaymentInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutPaymentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPaymentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutPaymentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyTransactionInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutTransactionInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTransactionInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutTransactionInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentHistoryCreateManyDebtInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod: $Enums.PaymentMethod
    notes?: string | null
    createdAt?: Date | string
    contributorId?: string | null
    payerId: string
    receiverId: string
  }

  export type WellBillDistributionCreateManyDebtInput = {
    id?: string
    wellBillingPeriodId: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
  }

  export type NotificationCreateManyDebtInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type PaymentHistoryUpdateWithoutDebtInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributor?: PurchaseContributorUpdateOneWithoutPaymentHistoryNestedInput
    payer?: UserUpdateOneRequiredWithoutPaymentsMadeNestedInput
    receiver?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    notifications?: NotificationUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateWithoutDebtInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentHistoryUncheckedUpdateManyWithoutDebtInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    payerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type WellBillDistributionUpdateWithoutDebtInput = {
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellBillingPeriod?: WellBillingPeriodUpdateOneRequiredWithoutDistributionsNestedInput
    field?: FieldUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    owner?: UserUpdateOneRequiredWithoutWellBillDistributionsNestedInput
  }

  export type WellBillDistributionUncheckedUpdateWithoutDebtInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutDebtInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutDebtInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutDebtInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutDebtInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DebtCreateManyInvoiceInput = {
    id?: string
    amount: number
    dueDate: Date | string
    status?: $Enums.DebtStatus
    description?: string | null
    createdAt?: Date | string
    paymentDate?: Date | string | null
    reminderSent?: boolean
    lastReminderDate?: Date | string | null
    reason?: string | null
    creditorId: string
    debtorId: string
    purchaseId?: string | null
  }

  export type NotificationCreateManyInvoiceInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type DebtUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditor?: UserUpdateOneRequiredWithoutDebtsAsCreditorNestedInput
    debtor?: UserUpdateOneRequiredWithoutDebtsAsDebtorNestedInput
    purchase?: PurchaseUpdateOneWithoutDebtsNestedInput
    paymentHistory?: PaymentHistoryUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHistory?: PaymentHistoryUncheckedUpdateManyWithoutDebtNestedInput
    wellBillDistributions?: WellBillDistributionUncheckedUpdateManyWithoutDebtNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateManyWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDebtStatusFieldUpdateOperationsInput | $Enums.DebtStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    lastReminderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutInvoiceInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutInvoiceInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutInvoiceInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInventoryUsageInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutInventoryUsageInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutInventoryUsageInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutInventoryUsageInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUsageCreateManyProcessInput = {
    id?: string
    inventoryId: string
    usedQuantity: number
    usageType: $Enums.UsageType
    usedById: string
    fieldId?: string | null
    createdAt?: Date | string
  }

  export type EquipmentUsageCreateManyProcessInput = {
    id?: string
    equipmentId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessCostCreateManyProcessInput = {
    id?: string
    laborCost: number
    equipmentCost: number
    inventoryCost: number
    fuelCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fieldId: string
  }

  export type NotificationCreateManyProcessInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type InventoryUsageUpdateWithoutProcessInput = {
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutUsagesNestedInput
    usedBy?: UserUpdateOneRequiredWithoutInventoryUsagesNestedInput
    field?: FieldUpdateOneWithoutInventoryUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateWithoutProcessInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutInventoryUsageNestedInput
  }

  export type InventoryUsageUncheckedUpdateManyWithoutProcessInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    usedQuantity?: FloatFieldUpdateOperationsInput | number
    usageType?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    usedById?: StringFieldUpdateOperationsInput | string
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUsageUpdateWithoutProcessInput = {
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentUpdateOneRequiredWithoutUsagesNestedInput
    user?: UserUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateWithoutProcessInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateManyWithoutProcessInput = {
    equipmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCostUpdateWithoutProcessInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutProcessCostsNestedInput
    ownerExpenses?: FieldOwnerExpenseUpdateManyWithoutProcessCostNestedInput
    notifications?: NotificationUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateWithoutProcessInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerExpenses?: FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProcessCostNestedInput
  }

  export type ProcessCostUncheckedUpdateManyWithoutProcessInput = {
    laborCost?: FloatFieldUpdateOperationsInput | number
    equipmentCost?: FloatFieldUpdateOperationsInput | number
    inventoryCost?: FloatFieldUpdateOperationsInput | number
    fuelCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutProcessInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutProcessInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutProcessInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentOwnershipCreateManyEquipmentInput = {
    id?: string
    userId: string
    ownershipPercentage: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCapabilityCreateManyEquipmentInput = {
    id?: string
    inventoryCategory: $Enums.InventoryCategory
    canUse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUsageCreateManyEquipmentInput = {
    id?: string
    processId: string
    userId: string
    areaProcessed: number
    processedPercentage: number
    fuelConsumed: number
    unit: $Enums.Unit
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyEquipmentInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type EquipmentOwnershipUpdateWithoutEquipmentInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEquipmentOwnershipsNestedInput
  }

  export type EquipmentOwnershipUncheckedUpdateWithoutEquipmentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentOwnershipUncheckedUpdateManyWithoutEquipmentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCapabilityUpdateWithoutEquipmentInput = {
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCapabilityUncheckedUpdateWithoutEquipmentInput = {
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCapabilityUncheckedUpdateManyWithoutEquipmentInput = {
    inventoryCategory?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    canUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUsageUpdateWithoutEquipmentInput = {
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    user?: UserUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    notifications?: NotificationUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateWithoutEquipmentInput = {
    processId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutEquipmentUsageNestedInput
  }

  export type EquipmentUsageUncheckedUpdateManyWithoutEquipmentInput = {
    processId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    areaProcessed?: FloatFieldUpdateOperationsInput | number
    processedPercentage?: FloatFieldUpdateOperationsInput | number
    fuelConsumed?: FloatFieldUpdateOperationsInput | number
    unit?: EnumUnitFieldUpdateOperationsInput | $Enums.Unit
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutEquipmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutEquipmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutEquipmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyEquipmentUsageInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutEquipmentUsageInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutEquipmentUsageInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutEquipmentUsageInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldOwnerExpenseCreateManyProcessCostInput = {
    id?: string
    fieldOwnershipId: string
    userId: string
    amount: number
    percentage: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyProcessCostInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type FieldOwnerExpenseUpdateWithoutProcessCostInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fieldOwnership?: FieldOwnershipUpdateOneRequiredWithoutOwnerExpensesNestedInput
    user?: UserUpdateOneRequiredWithoutFieldOwnerExpensesNestedInput
    notifications?: NotificationUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateWithoutProcessCostInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutOwnerExpenseNestedInput
  }

  export type FieldOwnerExpenseUncheckedUpdateManyWithoutProcessCostInput = {
    fieldOwnershipId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutProcessCostInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutProcessCostInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutProcessCostInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyFieldExpenseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    ownerExpenseId?: string | null
  }

  export type NotificationUpdateWithoutFieldExpenseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutFieldExpenseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutFieldExpenseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyOwnerExpenseInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    irrigationId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
  }

  export type NotificationUpdateWithoutOwnerExpenseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    irrigation?: IrrigationLogUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutOwnerExpenseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutOwnerExpenseInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationFieldUsageCreateManyIrrigationLogInput = {
    id?: string
    fieldId: string
    percentage: number
    actualIrrigatedArea?: number | null
    createdAt?: Date | string
  }

  export type IrrigationInventoryUsageCreateManyIrrigationLogInput = {
    id?: string
    inventoryId: string
    quantity: number
    unitPrice: number
    totalCost: number
    createdAt?: Date | string
  }

  export type WellBillingIrrigationUsageCreateManyIrrigationLogInput = {
    id?: string
    wellBillingPeriodId: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerSummaryCreateManyIrrigationLogInput = {
    id?: string
    ownerId: string
    totalIrrigatedArea: number
    totalAllocatedDuration: number
    createdAt?: Date | string
  }

  export type NotificationCreateManyIrrigationInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.NotificationPriority
    isRead?: boolean
    isArchived?: boolean
    link?: string | null
    expiresAt?: Date | string | null
    targetRoles?: NotificationCreatetargetRolesInput | $Enums.Role[]
    createdAt?: Date | string
    updatedAt?: Date | string
    receiverId: string
    senderId?: string | null
    processId?: string | null
    debtId?: string | null
    purchaseId?: string | null
    inventoryId?: string | null
    fieldId?: string | null
    seasonId?: string | null
    cropId?: string | null
    wellId?: string | null
    processingLogId?: string | null
    invoiceId?: string | null
    inventoryUsageId?: string | null
    transactionId?: string | null
    paymentId?: string | null
    contributorId?: string | null
    approvalId?: string | null
    equipmentId?: string | null
    equipmentUsageId?: string | null
    processCostId?: string | null
    fieldExpenseId?: string | null
    ownerExpenseId?: string | null
  }

  export type IrrigationFieldUsageUpdateWithoutIrrigationLogInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutIrrigationFieldUsagesNestedInput
    ownerUsages?: IrrigationOwnerUsageUpdateManyWithoutIrrigationFieldUsageNestedInput
  }

  export type IrrigationFieldUsageUncheckedUpdateWithoutIrrigationLogInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerUsages?: IrrigationOwnerUsageUncheckedUpdateManyWithoutIrrigationFieldUsageNestedInput
  }

  export type IrrigationFieldUsageUncheckedUpdateManyWithoutIrrigationLogInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    actualIrrigatedArea?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryUsageUpdateWithoutIrrigationLogInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutIrrigationInventoryUsagesNestedInput
    ownerUsages?: IrrigationInventoryOwnerUsageUpdateManyWithoutIrrigationInventoryUsageNestedInput
  }

  export type IrrigationInventoryUsageUncheckedUpdateWithoutIrrigationLogInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerUsages?: IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutIrrigationInventoryUsageNestedInput
  }

  export type IrrigationInventoryUsageUncheckedUpdateManyWithoutIrrigationLogInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageUpdateWithoutIrrigationLogInput = {
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wellBillingPeriod?: WellBillingPeriodUpdateOneRequiredWithoutIrrigationUsagesNestedInput
  }

  export type WellBillingIrrigationUsageUncheckedUpdateWithoutIrrigationLogInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageUncheckedUpdateManyWithoutIrrigationLogInput = {
    wellBillingPeriodId?: StringFieldUpdateOperationsInput | string
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryUpdateWithoutIrrigationLogInput = {
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutIrrigationOwnerSummariesNestedInput
  }

  export type IrrigationOwnerSummaryUncheckedUpdateWithoutIrrigationLogInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerSummaryUncheckedUpdateManyWithoutIrrigationLogInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    totalIrrigatedArea?: FloatFieldUpdateOperationsInput | number
    totalAllocatedDuration?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutIrrigationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
    process?: ProcessUpdateOneWithoutNotificationsNestedInput
    debt?: DebtUpdateOneWithoutNotificationsNestedInput
    purchase?: PurchaseUpdateOneWithoutNotificationsNestedInput
    inventory?: InventoryUpdateOneWithoutNotificationsNestedInput
    field?: FieldUpdateOneWithoutNotificationsNestedInput
    season?: SeasonUpdateOneWithoutNotificationsNestedInput
    crop?: CropUpdateOneWithoutNotificationsNestedInput
    well?: WellUpdateOneWithoutNotificationsNestedInput
    processingLog?: ProcessingLogUpdateOneWithoutNotificationsNestedInput
    invoice?: InvoiceUpdateOneWithoutNotificationsNestedInput
    inventoryUsage?: InventoryUsageUpdateOneWithoutNotificationsNestedInput
    transaction?: InventoryTransactionUpdateOneWithoutNotificationsNestedInput
    payment?: PaymentHistoryUpdateOneWithoutNotificationsNestedInput
    contributor?: PurchaseContributorUpdateOneWithoutNotificationsNestedInput
    approval?: PurchaseApprovalUpdateOneWithoutNotificationsNestedInput
    equipment?: EquipmentUpdateOneWithoutNotificationsNestedInput
    equipmentUsage?: EquipmentUsageUpdateOneWithoutNotificationsNestedInput
    processCost?: ProcessCostUpdateOneWithoutNotificationsNestedInput
    fieldExpense?: FieldExpenseUpdateOneWithoutNotificationsNestedInput
    ownerExpense?: FieldOwnerExpenseUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutIrrigationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutIrrigationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetRoles?: NotificationUpdatetargetRolesInput | $Enums.Role[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    processId?: NullableStringFieldUpdateOperationsInput | string | null
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    cropId?: NullableStringFieldUpdateOperationsInput | string | null
    wellId?: NullableStringFieldUpdateOperationsInput | string | null
    processingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentUsageId?: NullableStringFieldUpdateOperationsInput | string | null
    processCostId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerExpenseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationOwnerUsageCreateManyIrrigationFieldUsageInput = {
    id?: string
    ownerId: string
    ownershipPercentage: number
    usagePercentage: number
    createdAt?: Date | string
  }

  export type IrrigationOwnerUsageUpdateWithoutIrrigationFieldUsageInput = {
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutIrrigationOwnerUsagesNestedInput
  }

  export type IrrigationOwnerUsageUncheckedUpdateWithoutIrrigationFieldUsageInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationOwnerUsageUncheckedUpdateManyWithoutIrrigationFieldUsageInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    ownershipPercentage?: FloatFieldUpdateOperationsInput | number
    usagePercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageCreateManyIrrigationInventoryUsageInput = {
    id?: string
    ownerId: string
    percentage: number
    quantity: number
    cost: number
    createdAt?: Date | string
  }

  export type IrrigationInventoryOwnerUsageUpdateWithoutIrrigationInventoryUsageInput = {
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutIrrigationInventoryOwnerUsagesNestedInput
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateWithoutIrrigationInventoryUsageInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IrrigationInventoryOwnerUsageUncheckedUpdateManyWithoutIrrigationInventoryUsageInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    percentage?: FloatFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageCreateManyWellBillingPeriodInput = {
    id?: string
    irrigationLogId: string
    duration: number
    percentage: number
    amount: number
    createdAt?: Date | string
  }

  export type WellBillDistributionCreateManyWellBillingPeriodInput = {
    id?: string
    fieldId: string
    ownerId: string
    basisDuration: number
    basisArea?: number | null
    basisWeight: number
    sharePercentage: number
    amount: number
    createdAt?: Date | string
    debtId?: string | null
  }

  export type WellBillingIrrigationUsageUpdateWithoutWellBillingPeriodInput = {
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    irrigationLog?: IrrigationLogUpdateOneRequiredWithoutBillingUsagesNestedInput
  }

  export type WellBillingIrrigationUsageUncheckedUpdateWithoutWellBillingPeriodInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillingIrrigationUsageUncheckedUpdateManyWithoutWellBillingPeriodInput = {
    irrigationLogId?: StringFieldUpdateOperationsInput | string
    duration?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellBillDistributionUpdateWithoutWellBillingPeriodInput = {
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    owner?: UserUpdateOneRequiredWithoutWellBillDistributionsNestedInput
    debt?: DebtUpdateOneWithoutWellBillDistributionsNestedInput
  }

  export type WellBillDistributionUncheckedUpdateWithoutWellBillingPeriodInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WellBillDistributionUncheckedUpdateManyWithoutWellBillingPeriodInput = {
    fieldId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    basisDuration?: FloatFieldUpdateOperationsInput | number
    basisArea?: NullableFloatFieldUpdateOperationsInput | number | null
    basisWeight?: FloatFieldUpdateOperationsInput | number
    sharePercentage?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}